<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vinson-sheep</title>
  
  <subtitle>Vinson Sheep is on his time zone</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2021-01-28T13:13:31.262Z</updated>
  <id>/</id>
  
  <author>
    <name>Vinson-sheep</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>turtlebot3 configuration (ubuntu 18.04 + ros melodic)</title>
    <link href="/2021/01/23/turtlebot3-configuration-ubuntu-18-04-ros-melodic/"/>
    <id>/2021/01/23/turtlebot3-configuration-ubuntu-18-04-ros-melodic/</id>
    <published>2021-01-23T12:40:20.000Z</published>
    <updated>2021-01-28T13:13:31.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>turtlebot3 安装过程异常坎坷。首先，基于wiki的turtlebot3指南由于墙的原因非常的卡，不容易加载出来；其次，turtlebot3的教程不容易找，因为turtlebot3最开始是基于ros kinetic的，也就是大部分的教程不实用于melodic；最后，turtlebot3.git官方包比较大，就算是gitee下载，中途也会断掉。</p></blockquote><p>参考资料：</p><ul><li><a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.16.24c349b9yDIcxw&amp;id=615515907725&amp;ns=1&amp;abbucket=1" target="_blank" rel="noopener">《ROS机器人开发——实用案例分析》</a></li><li><a href="https://www.ncnynl.com/archives/201906/3123.html" target="_blank" rel="noopener">Turbot3-slam入门教程-安装-PC的系统和软件安装（ubuntu18.04）</a></li><li><a href="https://blog.csdn.net/weixin_30632899/article/details/101943379" target="_blank" rel="noopener">TurtleBot3-ROS包下载速度慢如何解决</a></li><li><a href="https://blog.csdn.net/ZWYZG/article/details/103208467?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.control" target="_blank" rel="noopener">Ubuntu18.04 LTS安装ROS melodic和turtlebot3</a></li></ul><h2 id="在远程计算机下载软件"><a href="#在远程计算机下载软件" class="headerlink" title="在远程计算机下载软件"></a>在远程计算机下载软件</h2><p>下载Turtlebot 3功能包<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ros-melodic-joy ros-melodic-teleop-twist-joy ros-melodic-teleop-twist-keyboard ros-melodic-laser-<span class="keyword">proc</span><span class="title"> ros-melodic-rgbd-launch</span> ros-melodic-depthimage-to-laserscan<span class="title"> ros-melodic-rosserial-arduino</span> ros-melodic-rosserial-python<span class="title"> ros-melodic-rosserial-server</span> ros-melodic-rosserial-client<span class="title"> ros-melodic-rosserial-msgs</span> ros-melodic-amcl<span class="title"> ros-melodic-map-server</span> ros-melodic-move-base<span class="title"> ros-melodic-urdf</span> ros-melodic-xacro<span class="title"> ros-melodic-compressed-image-transport</span> ros-melodic-rqt-image-view<span class="title"> ros-melodic-gmapping</span> ros-melodic-navigation<span class="title"> ros-melodic-interactive-markers</span></span><br></pre></td></tr></table></figure></p><p>添加官方包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/catkin_ws/src</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ROBOTIS-GIT/turtlebot3_msgs.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ROBOTIS-GIT/turtlebot3.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/catkin_ws &amp;&amp; catkin_make</span></span><br></pre></td></tr></table></figure></p><p>然而第二次<code>git clone</code>可能卡在某个百分点，那么现在直接做好了一个压缩包，您可以直接下载下来，然后拷贝到您的机器人或者远程PC上。</p><p><a href="https://pan.baidu.com/s/1Iw9G4-DdToLcgC0L8yGSbQ" target="_blank" rel="noopener">下载地址</a> 提取码：ar0x</p><p>解压命令如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">xvf</span> <span class="selector-tag">turtlebot3</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure></p><h2 id="在SBC上安装软件"><a href="#在SBC上安装软件" class="headerlink" title="在SBC上安装软件"></a>在SBC上安装软件</h2><p>下载Turtlebot 3功能包<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install ros-melodic-joy ros-melodic-teleop-twist-joy ros-melodic-teleop-twist-keyboard ros-melodic-laser-<span class="keyword">proc</span><span class="title"> ros-melodic-rgbd-launch</span> ros-melodic-depthimage-to-laserscan<span class="title"> ros-melodic-rosserial-arduino</span> ros-melodic-rosserial-python<span class="title"> ros-melodic-rosserial-server</span> ros-melodic-rosserial-client<span class="title"> ros-melodic-rosserial-msgs</span> ros-melodic-amcl<span class="title"> ros-melodic-map-server</span> ros-melodic-move-base<span class="title"> ros-melodic-urdf</span> ros-melodic-xacro<span class="title"> ros-melodic-compressed-image-transport</span> ros-melodic-rqt-image-view<span class="title"> ros-melodic-gmapping</span> ros-melodic-navigation<span class="title"> ros-melodic-interactive-markers</span></span><br></pre></td></tr></table></figure></p><p>添加官方包<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/catkin_ws/src</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ROBOTIS-GIT/turtlebot3_msgs.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/ROBOTIS-GIT/turtlebot3.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ~/catkin_ws &amp;&amp; catkin_make</span></span><br></pre></td></tr></table></figure></p><p>为turtlebot 3设置udev规则<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd ~<span class="regexp">/catkin_ws/src</span><span class="regexp">/turtlebot3/turtlebot</span>3_bringup</span><br><span class="line"><span class="variable">$ </span>sudo cp ./<span class="number">99</span>-turtlebot3-cdc.rules /etc/udev/rules.d/</span><br><span class="line"><span class="variable">$ </span>sudo udevadm control --reload-rules</span><br><span class="line"><span class="variable">$ </span>sudo udevadm trigger</span><br></pre></td></tr></table></figure></p><p>如果<code>git clone</code>卡在某个百分点，参考上面。</p><h2 id="远程计算机网络配置"><a href="#远程计算机网络配置" class="headerlink" title="远程计算机网络配置"></a>远程计算机网络配置</h2><h2 id="OpenCR安装"><a href="#OpenCR安装" class="headerlink" title="OpenCR安装"></a>OpenCR安装</h2><p>参考<a href="https://www.ncnynl.com/archives/201707/1819.html" target="_blank" rel="noopener">Turtlebot3-burger入门教程-OpenCR安装</a> shell脚本安装</p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>参考<a href="https://www.ncnynl.com/archives/201707/1819.html" target="_blank" rel="noopener">Turtlebot3-burger入门教程-OpenCR安装</a></p><p>假设你已经固定好远程PC和turtlebot3的IP。</p><p>[romote PC]<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo gedit ~<span class="regexp">/.bashrc</span></span><br></pre></td></tr></table></figure></p><p>在文件末尾添加<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">ROS_MASTER_URI</span>=http://&lt;romote_pc_ip&gt;:11311</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ROS_HOSTNAME</span>=&lt;romote_pc_ip&gt;</span><br></pre></td></tr></table></figure></p><p>[turtlebot3]<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">ROS_MASTER_URI</span>=http://&lt;romote_pc_ip&gt;:11311</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">ROS_HOSTNAME</span>=&lt;turtlebot3_pc_ip&gt;</span><br></pre></td></tr></table></figure></p><h2 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h2><p>参考<a href="http://vinsongeek.cn/2018/02/01/OpenSSH%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/" target="_blank" rel="noopener">OpenSSH远程控制服务器</a> 其实安装了软件就行，不用修改配置。</p><h2 id="控制真实的turtlebot3移动"><a href="#控制真实的turtlebot3移动" class="headerlink" title="控制真实的turtlebot3移动"></a>控制真实的turtlebot3移动</h2><p>[Remote PC] 启动roscore<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>roscore</span><br></pre></td></tr></table></figure></p><p>[TurtleBot] 启动burger<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turtlebot3_bringup turtlebot3_robot.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure></p><p>[Remote PC] 启动rviz<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="builtin-name">export</span> <span class="attribute">TURTLEBOT3_MODEL</span>=burger</span><br><span class="line">$ roslaunch turtlebot3_bringup turtlebot3_model.launch</span><br></pre></td></tr></table></figure></p><p>[Remote PC] 启动进行简单远程操作测试<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch turtlebot3_teleop turtlebot3_teleop_key.<span class="built_in">launch</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;turtlebot3 安装过程异常坎坷。首先，基于wiki的turtlebot3指南由于墙的原因非常的卡，不容易加载出来；其次，turtlebot3的教程不容易找，因为turtlebot3最开始是基于ros kinetic的，也就是大部分的教程不实
      
    
    </summary>
    
      <category term="auto system" scheme="/categories/auto-system/"/>
    
    
      <category term="ROS" scheme="/tags/ROS/"/>
    
      <category term="ubuntu" scheme="/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu ros安装</title>
    <link href="/2021/01/14/ubuntu-ros%E5%AE%89%E8%A3%85/"/>
    <id>/2021/01/14/ubuntu-ros安装/</id>
    <published>2021-01-14T14:45:37.000Z</published>
    <updated>2021-01-14T15:06:54.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ros安装不出意外就会出意外，稍作记录。<br><a id="more"></a></p></blockquote><p><em>ubuntu 18.04 /</em><br><em>ros melodic</em></p><p>ros安装<a href="http://wiki.ros.org/melodic/Installation/Ubuntu" target="_blank" rel="noopener">点这里</a></p><p>一般来说，会卡在最后两个步骤：</p><h2 id="sudo-rosdep-init失败"><a href="#sudo-rosdep-init失败" class="headerlink" title="sudo rosdep init失败"></a>sudo rosdep init失败</h2><p>报错如下：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR: </span>cannot download default sources list from:</span><br><span class="line">https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list</span><br><span class="line">Website may be down.</span><br></pre></td></tr></table></figure></p><p>参考<a href="https://www.cnblogs.com/sinferwu/p/12726833.html" target="_blank" rel="noopener">此处</a></p><p>如果所有IP试过了不行，等一段时间再试。</p><p>执行完成后：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Recommended</span>: please run</span><br><span class="line"></span><br><span class="line">      rosdep update</span><br></pre></td></tr></table></figure></p><h2 id="rosdep-update失败"><a href="#rosdep-update失败" class="headerlink" title="rosdep update失败"></a>rosdep update失败</h2><p>报错如下（之类）：<br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ERROR: </span>unable to process source [https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/base.yaml]:</span><br><span class="line">&lt;urlopen error [Errno 111] Connection refused&gt; (https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/base.yaml)</span><br></pre></td></tr></table></figure></p><p>解决方法：换源多试几次就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ros安装不出意外就会出意外，稍作记录。&lt;br&gt;
    
    </summary>
    
      <category term="auto system" scheme="/categories/auto-system/"/>
    
    
      <category term="ROS" scheme="/tags/ROS/"/>
    
      <category term="ubuntu" scheme="/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>2020中大计科课程总结（研一上）</title>
    <link href="/2021/01/14/2020%E4%B8%AD%E5%A4%A7%E8%AE%A1%E7%A7%91%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93%EF%BC%88%E7%A0%94%E4%B8%80%E4%B8%8A%EF%BC%89/"/>
    <id>/2021/01/14/2020中大计科课程总结（研一上）/</id>
    <published>2021-01-14T10:29:36.000Z</published>
    <updated>2021-03-02T19:06:20.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>公开声明：此文档是一份公开的资料，是系统院的师兄师姐根据当年的上课经历总结出来的一份指南。不求回报，不为内卷，本着开源共享的精神，现在将它分享给努力奋斗的你。<br><a id="more"></a></p></blockquote><p><em>author</em></p><ul><li><em>Vinson Sheep</em></li><li><em>林寒涧溯</em></li><li><em>Struggle</em></li><li><em>Claire</em></li><li><em>Suilylylu</em></li></ul><p>学习资料可以询问你任一师兄师姐</p><h2 id="关于选课"><a href="#关于选课" class="headerlink" title="关于选课"></a>关于选课</h2><p>CS学硕的要求可以参考培养方案，总分30分，必修至少20分。写明是必选的肯定要选，但写明必修的相当于选修。如果培养方案的必修课都修完，学分远超30。也就是说，必修课是根据自己兴趣选择，无需全部修完。</p><p>PS：由于我们院特色，上学期的期末可能没有选公共课的通知（辩证或者唯物论二选一）。</p><blockquote><p>Vinson Sheep: 要冲绩点的不要选到26分，除非你已经提前学了。</p></blockquote><h2 id="计算机科学与技术理论基础（张治国）"><a href="#计算机科学与技术理论基础（张治国）" class="headerlink" title="计算机科学与技术理论基础（张治国）"></a>计算机科学与技术理论基础（张治国）</h2><p>这门课正是大名鼎鼎的<strong>计算机哲学</strong>。它以极其迷惑的课堂内容、令人不安的作业布置还有亿点点的考试范围著称。</p><p>课堂内容方面，没有课本，全靠PPT；每一年老师讲的内容都有不同；PPT上的内容都是非常老的理论，很多符号和手写字，无论你是否本科CS，都一视同仁。</p><p>作业方面，老师会定期发一些作业在网盘；作业要认真做，它是你期末考试的根本依据；由于连续的两年讲课内容还是有很大相似度的，所以做题时可以参考上一年；老师从来不提供什么标准答案，这让学生们都善于思考。</p><p>期末考试方面，它出题范围是整份PPT；题目确实简单，前提是PPT全都弄懂了，还会做题；有些内容不在历年的作业题里面，但依然会成为考点，比如elementary function；课程中后期的论文presentation在期末考有涉及，分值很高，有填空题和判断题。</p><p>年轻人耗子尾汁。</p><blockquote><p>Vinson Sheep: 分数不要抱太大期望- -！</p></blockquote><h2 id="中国特色社会主义（朱亚坤）"><a href="#中国特色社会主义（朱亚坤）" class="headerlink" title="中国特色社会主义（朱亚坤）"></a>中国特色社会主义（朱亚坤）</h2><p>2020年：老师上课是按照PPT讲解的，没有课本。平常不会点名，快到期末了会有课程讨论，这段时间会有点名。期末考试开卷，两道大题，一题依据PPT内容，另一道依据课程讨论内容。基本照抄，如果有比较新的中特课本最好。考研政治的资料也可以带到考场，以防万一。</p><blockquote><p>Vinson Sheep: 不用复习，建议写满。</p></blockquote><h2 id="数据挖掘（潘嵘）"><a href="#数据挖掘（潘嵘）" class="headerlink" title="数据挖掘（潘嵘）"></a>数据挖掘（潘嵘）</h2><p>2020年:课本为《数据挖掘——概念与算法》(Mohammed J.Zaki)。不点名，没有作业。课本里面的内容基本都讲，另外还会拓展一些神经网络的内容（RNN、CNN）等。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img/20210114data_mining.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>期末考试闭卷，题目比较开放：</p><ul><li>概率密度函数在机器学习中的作用；</li><li>SVM与神经网络的优劣对比；</li><li>什么是泛化能力，如何提高学习机的泛化性能；</li><li>聚类算法中算法重要还是相似度重要；</li><li>L1和L2正则项如何影响机器学习，如何选择；</li></ul><p>布置在期末的大作业（考试与大作业时间重叠，比较坑）：从理论和实践角度谈谈你对偏置-方差分解的理解。</p><blockquote><p>Vinson Sheep: 虽然我逃课逃了一学期，但是分数依然很高。</p></blockquote><h2 id="英语（张红霞）"><a href="#英语（张红霞）" class="headerlink" title="英语（张红霞）"></a>英语（张红霞）</h2><p>2020年：每个老师的作业量和讲课方式都不一样，但试卷是一样的。恰好张老师态度认真负责，作业量跟所有专业课之和五五开。平时上课要求记笔记，然后课后读写任务特别多，课堂上会有视听说任务。presentation会贯穿整个学期，每个人可能都会有1到2次的机会。</p><p>期末考非常难。5道阅读题，长度和六级相仿，难度和考研英语有一拼，只有25分。一道英译汉，一道汉译英，两题占了近一半分。作文题是二选一，一道是图表描述题，另一道是summary，占30分。时间非常吃紧，英语不是很好的同学可能会有压力。</p><blockquote><p>Vinson Sheep: 笔记要认真做，特别是前期。她会检查的。即使你混了一个学期，分数也很nice。</p></blockquote><h2 id="数值分析（谭志军）"><a href="#数值分析（谭志军）" class="headerlink" title="数值分析（谭志军）"></a>数值分析（谭志军）</h2><p>2020年：数值分析比较轻松，理论简单粗暴，但实用性很强，建议都入手。平时基本不点名，期末偶尔会有几次（二维码+GPS定位）。定期会有作业，认真做，认真理解，最好有一本答案书。期末考试是开卷，题目很多，真的要做会花很多时间。试卷上70-80%的内容都是书上的题目，直接照抄。剩下的20-30%是原创内容，它会以小题形式卡你。对全书了如指掌是冲分的秘诀，否则你甚至找不到抄的地方，它可能是一些定理的证明。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img/20210114numeric_analysis.png" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>Vinson Sheep: 小破站有视频,可以提前学。没有像师兄说的人人95分，实际大概不到90分吧，不知道怎么算分的。</p></blockquote><h2 id="统计模式识别（孙蕾）"><a href="#统计模式识别（孙蕾）" class="headerlink" title="统计模式识别（孙蕾）"></a>统计模式识别（孙蕾）</h2><p>孙老师感觉还是比较平易近人，上课气氛比较轻松，而且老师知识点讲解也是很清楚。课程内容的话是统计模式识别相关的算法，可以作为人工智能领域的入门课程，课程内容也比较容易掌握。当然只是入门课程，想要深入了解这个领域还得学习其他知识。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img/20210114statistic_pattern_recognition.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>作业的话也比较简单有趣，感觉在作业中学习更能得到提升，任务基本都是图像相关的。</p><ol><li>基于Fisher算法的印章提取任务</li><li>基于Kmeans算法的车牌提取任务</li><li>基于主成分分析算法的人脸识别任务（最终大作业）</li></ol><p>当然，课程最后还得自己选择一篇近几年课程相关知识的文献进行阅读并做汇报，需要自己安排时间，避免和其他课程的期末任务冲突。<br>个人觉得这门课的话能学到很多基本的算法，而且估计孙老师给分也比较高，强烈建议入手。</p><p><em>by 林寒涧溯</em></p><h2 id="模式识别（胡俊）"><a href="#模式识别（胡俊）" class="headerlink" title="模式识别（胡俊）"></a>模式识别（胡俊）</h2><p>模式识别（<strong>胡俊</strong>）电子与通信工程学院</p><p>2020年：课本为《深度学习》（花书），书本内容没讲完讲了一半吧，会偶尔点名，每节课都会点人问问题，但问题其实都不难，回答不上来也没什么，老师很好。</p><p>考核形式：<br>两次大作业，老师说交了就不会挂你，“我的课可以优先级放最后”，老师原话，神仙老师我哭了。</p><ul><li>第一次作业<ol><li>mnist手写体识别</li><li>基于numpy搭建全连接神经网络</li><li>实现基于BP，SGD的训练</li><li>对比sigmoid和relu激活函数的区别</li><li>Softmax输出类别，交叉熵损失函数</li><li>制造欠拟合，过拟合效果</li><li>绘制训练loss曲线和测试loss曲线</li><li>Python+jupyter语言实现</li><li>每一步用都要注释</li><li>Jupyter要输出中间结果</li><li>制造过拟合，添加正则化纠偏</li></ol></li><li>第二次作业：<ol><li>在第一次作业的基础上，将SGD梯度下降算法替换为nesterov momentum RMSProp算法；</li><li>加入BN算法</li></ol></li></ul><p><em>by Suilylylu</em></p><h2 id="音视频编码（梁凡）"><a href="#音视频编码（梁凡）" class="headerlink" title="音视频编码（梁凡）"></a>音视频编码（梁凡）</h2><p>电信学院的选修课，两学分。</p><p>关于选电信学院（也就是自己学院以外）课程的方式：首先在选课界面搜索外院的课程，选课，然后跟自己学院教务老师打声招呼在系统上同意，再和任课老师说明情况在所选院系的系统上同意。</p><p>注意时间，在本学院已经同意但所选课程院系没有同意期间，学生应该是无法自行退课的。</p><p>一周就上一次课，没点过名，期末交一个大作业就行。</p><p>大作业内容是复现一个课程内容相关的论文即可，随意选，比较简单。</p><p><em>by Claire</em></p><h2 id="关于补修"><a href="#关于补修" class="headerlink" title="关于补修"></a>关于补修</h2><p>如果本科就是CS或者相关专业的，请忽略。</p><p>CS学硕的培养方案是跟数据院的一样，里面有这么一条：</p><blockquote><p>补修课程要求：非本专业本科毕业生应补修3门本专业本科课程中的2门。必须考试通过，不计学分。要求在第一学年内完成。</p></blockquote><p>然而，实现这个要求对我们院的学生是非常困难的。正常来说，学院会为我们办理好各种事务，但是我们院实际上不太在意这个事情；另外，由于你补的课在数据院，要想对应的任课老师给你一个分数，必须经过数据院的同意，也就是要开证明；最后，由于研一上的课程已经够多了，在增添课程会在期末有压力。</p><p>注意一个基本的事实：你并不在数据院，而是在系统院。换句话说，你补修的事情，是培养方案规定的，但培养方案是由你学院说了算。所以补修的事情可能不用过分担心（可能打脸）。</p><p>假设你是个认真严谨的人，希望补修：首先你需要去数据院咨询一下科研与研究生秘书，她会让你填表，然后让我们院盖章；盖完章之后，再拿给数据院盖章；最后，这份证明交给任课老师，她会让你参加考试，并给出证明。</p><h2 id="关于前沿讲座"><a href="#关于前沿讲座" class="headerlink" title="关于前沿讲座"></a>关于前沿讲座</h2><p><strong>前沿讲座是一个大坑</strong></p><p>前沿讲座是CS学硕的必选课，它只开在上学期。毫无疑问，数据院那边的培养模式是完善的，它自动给你安排讲座，你不用操心。虽然我们院的学生也选了课，但一点讲座的消息都没有，处境非常尴尬。基本上，我们两届的师兄师姐都没怎么上过讲座，不知道有没有分。只能听学院安排了。</p><p>假设你是个认真严谨的人，希望听讲座：你得联系一个热情的数据院同学，让他/她在每次有讲座消息时候通知你，或者给你签到；15次签到之后，你就成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;公开声明：此文档是一份公开的资料，是系统院的师兄师姐根据当年的上课经历总结出来的一份指南。不求回报，不为内卷，本着开源共享的精神，现在将它分享给努力奋斗的你。&lt;br&gt;
    
    </summary>
    
      <category term="other" scheme="/categories/other/"/>
    
    
      <category term="computer science" scheme="/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>在ROS中使用Python3</title>
    <link href="/2020/10/26/%E5%9C%A8ROS%E4%B8%AD%E4%BD%BF%E7%94%A8Python3/"/>
    <id>/2020/10/26/在ROS中使用Python3/</id>
    <published>2020-10-26T14:34:19.000Z</published>
    <updated>2020-10-26T14:44:20.379Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ROS默认支持python 2.7的，如果要想ROS上运行python3脚本，那么就需要配置一番。<br><a id="more"></a></p></blockquote><p><em>假设你已经安装了ROS melodic</em></p><p>参考文章：<br><a href="https://blog.csdn.net/bluewhalerobot/article/details/80952776" target="_blank" rel="noopener">在ROS中使用Python3</a></p><h2 id="修改python文件"><a href="#修改python文件" class="headerlink" title="修改python文件"></a>修改python文件</h2><p>在你的python文件的顶部添加该shebang<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python3</span></span><br></pre></td></tr></table></figure></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有创建virtualenv的话，注意需要使用pip3</span></span><br><span class="line">$ pip <span class="keyword">install</span> catkin-tools</span><br><span class="line">$ pip <span class="keyword">install</span> rospkg</span><br></pre></td></tr></table></figure><h2 id="运行脚本文件"><a href="#运行脚本文件" class="headerlink" title="运行脚本文件"></a>运行脚本文件</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python3</span> a_py_file.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ROS默认支持python 2.7的，如果要想ROS上运行python3脚本，那么就需要配置一番。&lt;br&gt;
    
    </summary>
    
      <category term="auto system" scheme="/categories/auto-system/"/>
    
    
      <category term="python3" scheme="/tags/python3/"/>
    
      <category term="ROS" scheme="/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>qgroundcontrol安装（ubuntu版）</title>
    <link href="/2020/10/26/qgroundcontrol%E5%AE%89%E8%A3%85%EF%BC%88ubuntu%E7%89%88)/"/>
    <id>/2020/10/26/qgroundcontrol安装（ubuntu版)/</id>
    <published>2020-10-26T07:32:31.000Z</published>
    <updated>2020-10-26T14:31:27.178Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>QGC的官网是有墙的，加上我的ubuntu上没有梯子，所以整个过程比较麻烦。好在东拼西凑国内的一些文章终于解决了这个问题。<br><a id="more"></a></p></blockquote><p>参考文章:</p><ol><li><a href="https://www.cnblogs.com/sawyer22/p/9300822.html" target="_blank" rel="noopener">PX4地面站QGroundControl在ubuntu下的安装</a></li><li><a href="http://www.yoyojacky.com/?p=137" target="_blank" rel="noopener">QGroundControl用户指南</a></li></ol><h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h2><ul><li><a href="https://s3-us-west-2.amazonaws.com/qgroundcontrol/latest/QGroundControl.AppImage" target="_blank" rel="noopener">下载QGroundControl.AppImage</a></li><li><a href="https://s3-us-west-2.amazonaws.com/qgroundcontrol/latest/QGroundControl.tar.bz2" target="_blank" rel="noopener">下载QGroundControl.tar.bz2</a></li></ul><h2 id="2-安装QGC"><a href="#2-安装QGC" class="headerlink" title="2. 安装QGC"></a>2. 安装QGC</h2><p>解压压缩包<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">jxf</span> <span class="selector-tag">QGroundControl</span><span class="selector-class">.tar</span><span class="selector-class">.bz2</span></span><br></pre></td></tr></table></figure></p><p>安装附加软件包<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install espeak libespeak-<span class="built_in">dev</span> libudev-<span class="built_in">dev</span> libsdl1<span class="number">.2</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></p><h2 id="3-安装AppImage"><a href="#3-安装AppImage" class="headerlink" title="3. 安装AppImage"></a>3. 安装AppImage</h2><p>使用终端<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./QGroundControl.AppImage</span><br><span class="line">./QGroundControl.AppImage  (<span class="keyword">or</span> <span class="keyword">double</span> <span class="built_in">click</span> <span class="built_in">run</span>)</span><br></pre></td></tr></table></figure></p><p>此时可能出现如下错误<br><img src alt><br>按照提示执行即可<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G dialout <span class="variable">$USER</span></span><br><span class="line">sudo apt-<span class="builtin-name">get</span> <span class="builtin-name">remove</span> modemmanager</span><br></pre></td></tr></table></figure></p><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4. 运行"></a>4. 运行</h2><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> qgroundcontrol</span><br><span class="line">./qgroundcontrol-<span class="built_in">start</span>.sh</span><br></pre></td></tr></table></figure><p>当然可以双击<strong>qgroundcontrol.AppImage</strong>打开QGC.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;QGC的官网是有墙的，加上我的ubuntu上没有梯子，所以整个过程比较麻烦。好在东拼西凑国内的一些文章终于解决了这个问题。&lt;br&gt;
    
    </summary>
    
      <category term="auto system" scheme="/categories/auto-system/"/>
    
    
      <category term="无人机" scheme="/tags/%E6%97%A0%E4%BA%BA%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib中文显示设置</title>
    <link href="/2020/10/05/matplotlib%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E8%AE%BE%E7%BD%AE/"/>
    <id>/2020/10/05/matplotlib中文显示设置/</id>
    <published>2020-10-05T14:34:01.000Z</published>
    <updated>2020-10-05T14:38:57.048Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用pyplot绘制图像的时候，发现中文显示不全，于是总结了一些文章，希望之后碰到类似问题的时候能够得到参考。<br><a id="more"></a></p></blockquote><h2 id="查看系统字体"><a href="#查看系统字体" class="headerlink" title="查看系统字体"></a>查看系统字体</h2><p><a href="https://blog.csdn.net/qq_41498261/article/details/103835747" target="_blank" rel="noopener">Windows——matplotlib添加中文字体</a></p><h2 id="设置matplotlib字体"><a href="#设置matplotlib字体" class="headerlink" title="设置matplotlib字体"></a>设置matplotlib字体</h2><p><a href="https://www.cnblogs.com/hhh5460/p/4323985.html" target="_blank" rel="noopener">matplotlib显示中文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用pyplot绘制图像的时候，发现中文显示不全，于是总结了一些文章，希望之后碰到类似问题的时候能够得到参考。&lt;br&gt;
    
    </summary>
    
      <category term="后端" scheme="/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
      <category term="matplotlib" scheme="/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>利用mat文件实现matlab和python之间的数据交换</title>
    <link href="/2020/09/28/%E5%88%A9%E7%94%A8mat%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0matlab%E5%92%8Cpython%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2/"/>
    <id>/2020/09/28/利用mat文件实现matlab和python之间的数据交换/</id>
    <published>2020-09-28T10:10:11.000Z</published>
    <updated>2020-09-28T10:35:01.358Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>matlab原本是支持对python子函数的调用，这对于一般的参数（比如array、double等）能够适用，然而当参数为一个大型矩阵的时候，python子函数就频频报错。如果传入的大矩阵依然是一个二维数组，那应当能通过[i]的方式进行访问，显然matlab对大型矩阵的实现与其他数据不同。利用mat文件传输正是解决这个问题的方法。<br><a id="more"></a></p></blockquote><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>我们在<strong>tool.py</strong>文件中可以设计一个python子函数，对传入参数进行类型打印：<br><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(a):</span><br><span class="line">  print(<span class="keyword">type</span>(a))</span><br></pre></td></tr></table></figure></p><p>然后在matlab中调用<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">py</span><span class="selector-class">.tool</span><span class="selector-class">.test</span>(<span class="selector-tag">a_big_matrix</span>)</span><br></pre></td></tr></table></figure></p><p>a_big_matrix可以是一个大型图像数据；程序运行结果为：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> '<span class="symbol">memoryview</span>'&gt;</span><br></pre></td></tr></table></figure></p><p>memoryview? 根据python3自身定义的memoryview对象，利用下标[i]确实是能访问内容的，然而这里由matlab传入的memoryview却不行。</p><p>利用<strong>mat文件</strong>存取大型矩阵可以屏蔽掉语言上的差异。</p><h2 id="python存取mat文件"><a href="#python存取mat文件" class="headerlink" title="python存取mat文件"></a>python存取mat文件</h2><p>读取<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> scio</span><br><span class="line"></span><br><span class="line"><span class="title">dataFile</span> = '<span class="type">E</span>://<span class="class"><span class="keyword">data</span>.mat'</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> = scio.loadmat(<span class="title">dataFile</span>)</span></span><br></pre></td></tr></table></figure></p><p>保存<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataNew = <span class="string">'E://dataNew.mat'</span></span><br><span class="line">scio.savemat(dataNew, &#123;<span class="string">'A'</span><span class="symbol">:data</span>[<span class="string">'A'</span>]&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="matlab存取mat文件"><a href="#matlab存取mat文件" class="headerlink" title="matlab存取mat文件"></a>matlab存取mat文件</h2><p>读取<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span>(<span class="string">'E:\room\MATLAB\apt\file1.mat'</span>,<span class="string">'A'</span>);   %从指定文件夹中读取变量A</span><br></pre></td></tr></table></figure></p><p>保存<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save(<span class="string">'file1.mat'</span>,<span class="string">'A'</span>)<span class="comment">;    %从指定文件夹中保存变量A</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;matlab原本是支持对python子函数的调用，这对于一般的参数（比如array、double等）能够适用，然而当参数为一个大型矩阵的时候，python子函数就频频报错。如果传入的大矩阵依然是一个二维数组，那应当能通过[i]的方式进行访问，显然matlab对大型矩阵的实现与其他数据不同。利用mat文件传输正是解决这个问题的方法。&lt;br&gt;
    
    </summary>
    
      <category term="语言学习" scheme="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
      <category term="matlab" scheme="/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>(ubuntu)DOSBox编写汇编语言程序</title>
    <link href="/2020/06/16/ubuntu-DOSBox%E7%BC%96%E5%86%99%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F/"/>
    <id>/2020/06/16/ubuntu-DOSBox编写汇编语言程序/</id>
    <published>2020-06-16T04:21:20.000Z</published>
    <updated>2020-06-16T04:36:59.023Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在学习汇编语言，无奈win10并不能自带debug。虽然能够安装DOSBox，但是不兼容masm.exe、link.exe等等。此文章转载了一篇关于在ubuntu中部署DOSBox实现编译连接.asm文件的文章。<br><a id="more"></a></p></blockquote><p><a href="https://blog.csdn.net/qq_41584385/article/details/101855795" target="_blank" rel="noopener">文章来源</a></p><h2 id="一、安装dosbox"><a href="#一、安装dosbox" class="headerlink" title="一、安装dosbox"></a>一、安装dosbox</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install dosbox</span><br></pre></td></tr></table></figure><p>安装成功之后可以通过命令行输入<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">dosbox</span></span><br></pre></td></tr></table></figure></p><p>来开启，也可以在左下角“显示应用程序”中打开。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img/20200616_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="二、操作步骤"><a href="#二、操作步骤" class="headerlink" title="二、操作步骤"></a>二、操作步骤</h2><h3 id="1、选择一个目录，其中尽可能准备好以下文件"><a href="#1、选择一个目录，其中尽可能准备好以下文件" class="headerlink" title="1、选择一个目录，其中尽可能准备好以下文件"></a>1、选择一个目录，其中尽可能准备好以下文件</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img/20200616_2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>这些文件中，必须有<strong>MASM.EXE</strong>和<strong>LINK.EXE</strong>。</p><p>调试需要，最好配上<strong>DEBUG.EXE</strong>。</p><p>另外，<strong>hello.asm</strong>文件是提前用vim编辑器写好的，即输出hello world。</p><p>附上这些文件的<a href="https://pan.baidu.com/s/1GwUaIruPeLQUoKVMq5_ROw#list/path=%2F" target="_blank" rel="noopener">下载链接</a>，提取码：<strong>ev2k</strong></p><p>应该注意，默认的版本是不支持中文的，所以尽量避免输出中文，或者安装汉化版本。</p><p>hello.asm内容如下：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.model</span>  small<span class="comment">;小型存储模式</span></span><br><span class="line"><span class="meta">.stack</span><span class="comment">;定义堆栈段</span></span><br><span class="line"><span class="meta">.data</span><span class="comment">;定义数据段</span></span><br><span class="line">string<span class="built_in">db</span>   <span class="string">'Hello, world!'</span><span class="comment">;预存字符串、</span></span><br><span class="line"><span class="built_in">db</span>   <span class="number">0dh</span>, <span class="number">0ah</span>, <span class="string">'$'</span><span class="comment">;回车换行结束</span></span><br><span class="line"><span class="meta">.code</span><span class="comment">;定义代码段</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span>   <span class="built_in">ax</span>, @data<span class="comment">;装数据段(段</span></span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">ds</span>, <span class="built_in">ax</span><span class="comment">; 地址送DS)</span></span><br><span class="line"><span class="keyword">lea</span>    <span class="built_in">dx</span>, string  <span class="comment">;调用21H号</span></span><br><span class="line"><span class="keyword">mov</span>   <span class="number">ah</span>, <span class="number">9</span><span class="comment">; 中断，显示</span></span><br><span class="line"><span class="keyword">int</span>   <span class="number">21h</span><span class="comment">; 字符串</span></span><br><span class="line"><span class="keyword">mov</span>   <span class="built_in">ax</span>, <span class="number">4c00h</span><span class="comment">;调用21H号中</span></span><br><span class="line"><span class="keyword">int</span>   <span class="number">21h</span><span class="comment">; 断，返回</span></span><br><span class="line">end   start<span class="comment">; 结束汇编</span></span><br></pre></td></tr></table></figure></p><h3 id="2、打开dosbox后，运行hello-asm"><a href="#2、打开dosbox后，运行hello-asm" class="headerlink" title="2、打开dosbox后，运行hello.asm"></a>2、打开dosbox后，运行hello.asm</h3><p>（1）设置虚拟磁盘c为上述文件存储的目录，以笔者目录为例：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount c <span class="regexp">/home/</span>zhanwangc<span class="regexp">/download/m</span>asm</span><br></pre></td></tr></table></figure></p><p>（2）进到虚拟磁盘c<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">c:</span></span><br></pre></td></tr></table></figure></p><p>（3）显示目录下情况，查看文件是否齐全<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span></span><br></pre></td></tr></table></figure></p><p>（4）编译为obj文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masm hello.<span class="keyword">asm</span></span><br></pre></td></tr></table></figure></p><p>输入上述命令后，连续点击三个回车，即默认编译完成。</p><p>（5）生成可执行文件<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">link</span> <span class="selector-tag">hello</span><span class="selector-class">.obj</span></span><br></pre></td></tr></table></figure></p><p>也是连续点击三个回车，默认生成。</p><p>（6）运行<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">hello</span><span class="selector-class">.exe</span></span><br></pre></td></tr></table></figure></p><p>运行成功显示如下：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img/20200616_3.png" alt title>                </div>                <div class="image-caption"></div>            </figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在学习汇编语言，无奈win10并不能自带debug。虽然能够安装DOSBox，但是不兼容masm.exe、link.exe等等。此文章转载了一篇关于在ubuntu中部署DOSBox实现编译连接.asm文件的文章。&lt;br&gt;
    
    </summary>
    
      <category term="语言学习" scheme="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ubuntu" scheme="/tags/ubuntu/"/>
    
      <category term="assembly language" scheme="/tags/assembly-language/"/>
    
  </entry>
  
  <entry>
    <title>2020中山大学系统科学与工程学院（复试经验）</title>
    <link href="/2020/06/09/2020%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6%E7%B3%BB%E7%BB%9F%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%AD%A6%E9%99%A2%EF%BC%88%E5%A4%8D%E8%AF%95%E7%BB%8F%E9%AA%8C%EF%BC%89/"/>
    <id>/2020/06/09/2020中山大学系统科学与工程学院（复试经验）/</id>
    <published>2020-06-09T07:32:31.000Z</published>
    <updated>2021-01-14T10:32:42.321Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>2020年中山大学系统科学与工程学院（复试），计算机科学与技术（学硕），拟录取。<br><a id="more"></a></p></blockquote><h2 id="1-我"><a href="#1-我" class="headerlink" title="1. 我"></a>1. 我</h2><p>跨考生，本科化学。初试359，复试352.15，总分711.15，排名第二。</p><p>复试书目：</p><ul><li>《C Prime Plus》（第六版）（Stephen Prata）</li><li>《模拟考场 二级C》、《上机考试题库 二级C》</li><li>《离散数学》（第二版）（曲婉玲 耿素云 张立昂）</li><li>《计算机英语学生用书》（第三版）（姜同强 苗天顺）</li><li>《数学专业英语》（第三版）（吴烔圻）</li><li>《算法笔记》（胡凡 曾磊）</li><li>《算法笔记——上机训练实战指南》（胡凡 曾磊）</li><li>《软件工程导论》（第六版）（张海藩 牟永敏）</li><li>《数据库系统概论》（第五版）（王珊 萨师煊）</li><li>《数字电子技术》（第四版）（江晓安 周慧鑫 付少锋）</li><li>《408四大金刚》、《数学一三大猛兽》</li><li>《人工智能》（相关书籍）</li><li>《网络安全》（未完成）</li></ul><p>事实证明，复习的都不考</p><h2 id="2-考情分析"><a href="#2-考情分析" class="headerlink" title="2. 考情分析"></a>2. 考情分析</h2><p>2019年，中大数据院和系统院在CS上统一招生。数据院招生14个，系统院招生10个。</p><p>2020年，中大数据院和系统院分开招生。数据院招生12人，系统院只有15个名额，且全部用于调剂（很迷惑）。系统院的调剂会比数据院的正式复试晚很多很多，也就是说，系统院就是给你第二次机会了。</p><p>今年系统院复试线为280（非常低），从招收情况看，只要复试分数及格，点击就送。</p><p>CS进入复试的一共11人，刷了5人，证明不是胡来的。</p><h2 id="3-复试内容"><a href="#3-复试内容" class="headerlink" title="3. 复试内容"></a>3. 复试内容</h2><h3 id="3-1-自我介绍（中文）"><a href="#3-1-自我介绍（中文）" class="headerlink" title="3.1 自我介绍（中文）"></a>3.1 自我介绍（中文）</h3><p>这个环节是我没想到了，我那时候几乎蒙了。历年计算机面试都没有进行自我介绍，还好我之前在数据院面试的时候准备了一份（没有用上），内容不太适用于新学院。</p><p>老师会给你两分钟介绍，然后进行提问。</p><ul><li>Q1：你是往届生，考研的前一年主要是干什么？</li><li>Q2：大学期间有学过什么跟计算机相关的课程？</li><li>Q3：学过数据结构的吧？说说什么是哈希函数？</li></ul><h3 id="3-2-英语翻译"><a href="#3-2-英语翻译" class="headerlink" title="3.2 英语翻译"></a>3.2 英语翻译</h3><p>就是给出一篇短文，长度大概是半张A4纸，字很大。要求先朗读短文，比较简单。然后要求翻译前两句话，比较难，但是意思到位就行。我抽到了关于网络安全的文章，要求翻译的句子语法异常复杂，但是抽取句子关键字然后大概翻译一下就过关，老师也没有问什么。</p><h3 id="3-3-专业面试"><a href="#3-3-专业面试" class="headerlink" title="3.3 专业面试"></a>3.3 专业面试</h3><p>给出是个编号，一个编号对应一道题，让你抽两道题。</p><ul><li>Q1：C语言中有什么程序结构？（我第一次看成数据结构了，实际上很简单，但是我一开始没往那方面想）</li><li>Q2：什么是对称加密和非对称加密（网络安全，我偏偏就没有补这课）</li></ul><h3 id="3-4-拓展面试"><a href="#3-4-拓展面试" class="headerlink" title="3.4 拓展面试"></a>3.4 拓展面试</h3><p>还是抽题。</p><ul><li>Q：什么是机器学习？有哪些类型？（具体忘了，大概就是这么个意思）</li><li>追问：机器学习算法的有哪些？举几个例子。</li><li>追问：请论述机器学习和深度学习的关系（深度学习是实现方式之一）</li><li>追问：如果我把你分配到网络安全，你会怎么做？（问这问题是因为我一直强调AI的作用，送命题）</li></ul><h2 id="4-碎碎念"><a href="#4-碎碎念" class="headerlink" title="4. 碎碎念"></a>4. 碎碎念</h2><p>今年疫情使得复试情况特殊，但是这是系统院今年第一次自己组织复试，很可能下一年就照着这个模板进行线下复试。不管怎么样，自我介绍、线上机试等都是必须准备的。</p><p>系统院今年复试特别的难。数据院复试考的大部分都是基本知识，都是你应该会，只是比较偏门。系统院的复试范围跟数据院一致，却延伸了网络安全、人工智能、区块链（其他考生提供）等题目，对跨考生及其不利。跨考生要想成功，可能需要跳出中大的复试目录，比较累。</p><p>中大的复试特别墨迹。我先列出时间线给大家感受一下：</p><ul><li>2020.5.06，第一波高校开始复试；</li><li>2020.5.14，数据院发复试通知；</li><li>2020.5.19，数据院开始复试；</li><li>2020.5.20，调剂系统开启；</li><li>2020.5.24，数据院发复试结果；</li><li>2020.6.04，系统院发复试通知；</li><li>2020.6.09，系统院发复试结果</li></ul><p>注意到，<strong>第一波复试</strong>到<strong>数据院发结果</strong>这段时间大于两周，第一波复试到系统院发结果这段时间大于一个月，这意味着你考中大基本就没有外校调剂了。历年中大华工都是很迟复试的，所以慎入。</p><p>另外，<strong>数据院发复试结果</strong>到<strong>系统院发复试通知</strong>这段时间大于十天，这段时间足够一个在数据院被刷的CS考生在校外递交材料、调剂复试、出成绩可。也就是说，很多高分人才在等待中流失，最后在系统院报名的寥寥无几（3/15）。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;2020年中山大学系统科学与工程学院（复试），计算机科学与技术（学硕），拟录取。&lt;br&gt;
    
    </summary>
    
      <category term="other" scheme="/categories/other/"/>
    
    
      <category term="computer science" scheme="/tags/computer-science/"/>
    
  </entry>
  
  <entry>
    <title>pycharm模块安装</title>
    <link href="/2020/06/07/pycharm%E6%A8%A1%E5%9D%97%E5%AE%89%E8%A3%85/"/>
    <id>/2020/06/07/pycharm模块安装/</id>
    <published>2020-06-07T11:10:58.000Z</published>
    <updated>2020-06-09T10:35:11.154Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>直接在linux终端中使用pip3安装pygame，能够在终端中使用import导入。然而在pycharm却没有发现相应模块，这里是使用pycharm进行开发时候正确的安装模块姿势。<br><a id="more"></a></p></blockquote><p><code>File</code>-&gt;<code>Settings</code>-&gt;<code>Project:untitled</code>-&gt;<code>Project interperter</code>-&gt;<code>+</code>-&gt;search &amp;&amp; install</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;直接在linux终端中使用pip3安装pygame，能够在终端中使用import导入。然而在pycharm却没有发现相应模块，这里是使用pycharm进行开发时候正确的安装模块姿势。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python文件和目录操作</title>
    <link href="/2020/06/05/python%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/"/>
    <id>/2020/06/05/python文件和目录操作/</id>
    <published>2020-06-05T10:46:58.000Z</published>
    <updated>2020-06-05T11:06:53.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用系统模块os，对文件和目录进行操作。<br><a id="more"></a></p></blockquote><ul><li>在 终端 / 文件浏览器、 中可以执行常规的 文件 / 目录 管理操作，例如：<br>创建、重命名、删除、改变路径、查看目录内容、……</li><li>在 Python 中，如果希望通过程序实现上述功能，需要导入 <strong>os 模块</strong></li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>01</td><td>rename</td><td>重命名文件</td><td>os.rename(原文件名， 目标文件名)</td></tr><tr><td>02</td><td>remove</td><td>删除文件</td><td>os.remove(文件名)</td></tr></tbody></table><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>01</td><td>listdir</td><td>目录列表</td><td>os.listdir(目录名)</td></tr><tr><td>02</td><td>mkdir</td><td>创建目录</td><td>os.mkdir(目录名)</td></tr><tr><td>03</td><td>rmdir</td><td>删除目录</td><td>os.rmdir(目录名)</td></tr><tr><td>04</td><td>getcwd</td><td>获取当前目录</td><td>os.getcwd()</td></tr><tr><td>05</td><td>chdir</td><td>修改当前目录</td><td>os.chdir(目标目录)</td></tr><tr><td>06</td><td>path.isdir</td><td>判断是否是目录</td><td>os.path.isdir(文件路径)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用系统模块os，对文件和目录进行操作。&lt;br&gt;
    
    </summary>
    
      <category term="语言学习" scheme="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python包（package）与发布</title>
    <link href="/2020/06/05/python%E5%8C%85%EF%BC%88package%EF%BC%89%E4%B8%8E%E5%8F%91%E5%B8%83/"/>
    <id>/2020/06/05/python包（package）与发布/</id>
    <published>2020-06-05T10:34:58.000Z</published>
    <updated>2020-06-05T10:45:29.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>将模块进行打包，并且发布给其他开发者使用<br><a id="more"></a></p></blockquote><h2 id="1-包"><a href="#1-包" class="headerlink" title="1. 包"></a>1. 包</h2><h3 id="1-1-包概念"><a href="#1-1-包概念" class="headerlink" title="1.1 包概念"></a>1.1 包概念</h3><ul><li>包 是一个 <strong>包含多个模块</strong> 的 特殊目录</li><li>目录下有一个 特殊的文件 <code>__init__.py</code></li><li>包名的 命名方式 和变量名一致，小写字母 + _</li></ul><h3 id="1-2-init"><a href="#1-2-init" class="headerlink" title="1.2 __init__"></a>1.2 <code>__init__</code></h3><p>要在外界使用 包 中的模块，需要在 <code>__init__.py</code> 中指定 对外界提供的模块列表</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 当前目录 导入 模块列表</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> send_message</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> receive_message</span><br></pre></td></tr></table></figure><blockquote><p>注意：上述方式会让你开发的时候不得不使用多重点表示法去调用函数<code>package.sub_package.func()</code>，替换的方法是直接在<code>__init__</code>中编写函数，这样调用函数时应该编写<code>package.func()</code>。这和其他系统模块一致。</p></blockquote><h2 id="2-发布模块"><a href="#2-发布模块" class="headerlink" title="2. 发布模块"></a>2. 发布模块</h2><p>如果希望自己开发的模块，分享 给其他人，可以按照以下步骤操作</p><h3 id="2-1-制作发布压缩包步骤"><a href="#2-1-制作发布压缩包步骤" class="headerlink" title="2.1 制作发布压缩包步骤"></a>2.1 制作发布压缩包步骤</h3><p>在模块同一目录下创建 <strong>setup.py</strong>，输入：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core import setup</span><br><span class="line"></span><br><span class="line">setup(<span class="attribute">name</span>=<span class="string">"hm_message"</span>,  # 包名</span><br><span class="line">      <span class="attribute">version</span>=<span class="string">"1.0"</span>,  # 版本</span><br><span class="line">      <span class="attribute">description</span>=<span class="string">"itheima's 发送和接收消息模块"</span>,  # 描述信息</span><br><span class="line">      <span class="attribute">long_description</span>=<span class="string">"完整的发送和接收消息模块"</span>,  # 完整描述信息</span><br><span class="line">      <span class="attribute">author</span>=<span class="string">"itheima"</span>,  # 作者</span><br><span class="line">      <span class="attribute">author_email</span>=<span class="string">"itheima@itheima.com"</span>,  # 作者邮箱</span><br><span class="line">      <span class="attribute">url</span>=<span class="string">"www.itheima.com"</span>,  # 主页</span><br><span class="line">      py_modules=[<span class="string">"hm_message.send_message"</span>,</span><br><span class="line">                  <span class="string">"hm_message.receive_message"</span>])</span><br></pre></td></tr></table></figure></p><p>构建模块<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python3</span> setup.<span class="keyword">py</span> build</span><br></pre></td></tr></table></figure></p><p>生成发布压缩包<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python3</span> setup.<span class="keyword">py</span> sdist</span><br></pre></td></tr></table></figure></p><h3 id="2-2-安装模块"><a href="#2-2-安装模块" class="headerlink" title="2.2 安装模块"></a>2.2 安装模块</h3><p>将模块给予使用者，然后让他安装模块的系统上<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar -zxvf hm_message-<span class="number">1.0</span><span class="selector-class">.tar</span>.gz</span><br><span class="line"></span><br><span class="line">$ sudo python3 setup<span class="selector-class">.py</span> install</span><br></pre></td></tr></table></figure></p><h3 id="2-3-卸载模块"><a href="#2-3-卸载模块" class="headerlink" title="2.3 卸载模块"></a>2.3 卸载模块</h3><p>直接从安装目录下，把安装模块的 目录 删除就可以<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.5/<span class="title">dist</span>-<span class="title">packages</span>/</span></span><br><span class="line">$ sudo rm -r hm_message*</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;将模块进行打包，并且发布给其他开发者使用&lt;br&gt;
    
    </summary>
    
      <category term="语言学习" scheme="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python模块测试</title>
    <link href="/2020/06/05/python%E6%A8%A1%E5%9D%97%E6%B5%8B%E8%AF%95/"/>
    <id>/2020/06/05/python模块测试/</id>
    <published>2020-06-05T10:29:58.000Z</published>
    <updated>2020-06-05T10:33:56.942Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用<strong>name</strong>字符串实现模块测试，而不影响主程序的使用<br><a id="more"></a></p></blockquote><h2 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h2><p><code>__name__</code> 是 <code>Python</code> 的一个内置属性，记录着一个 字符串。</p><p>如果 是被其他文件导入的，<code>__name__</code> 就是 模块名</p><p>如果 是当前执行的程序 <code>__name__</code> 是 <code>__main__</code></p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 导入模块</span></span><br><span class="line"><span class="meta"># 定义全局变量</span></span><br><span class="line"><span class="meta"># 定义类</span></span><br><span class="line"><span class="meta"># 定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 在代码的最下方</span></span><br><span class="line">def main():</span><br><span class="line">    # ...</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"><span class="meta"># 根据 __name__ 判断是否执行下方代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用&lt;strong&gt;name&lt;/strong&gt;字符串实现模块测试，而不影响主程序的使用&lt;br&gt;
    
    </summary>
    
      <category term="语言学习" scheme="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python单例设计模式</title>
    <link href="/2020/06/03/python%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>/2020/06/03/python单例设计模式/</id>
    <published>2020-06-03T15:30:58.000Z</published>
    <updated>2020-06-02T16:27:48.715Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>单例设计模式——让类创建的对象，在系统中只有唯一的一个实例。每一次执行 类名() 返回的对象，内存地址是相同的<br><a id="more"></a></p></blockquote><h2 id="new-方法"><a href="#new-方法" class="headerlink" title="__new__ 方法"></a><code>__new__</code> 方法</h2><ul><li>使用 <strong>类名()</strong> 创建对象时，Python 的解释器 <strong>首先</strong> 会 调用 <code>__new__</code> 方法为对象 <strong>分配空间</strong><br><code>__new__</code> 是一个 由 object 基类提供的 内置的静态方法，主要作用有两个：<ul><li>1) 在内存中为对象 <strong>分配空间</strong></li><li>2) <strong>返回</strong> 对象的引用</li></ul></li><li>Python 的解释器获得对象的 <strong>引用* 后，将引用作为 </strong>第一个参数**，传递给 <code>__init__</code>方法</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>关键：<strong>自定义<code>__new__</code>方法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义类属性记录单例对象引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 判断类属性是否已经被赋值</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.instance = super().__new__(cls)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 返回类属性的单例引用</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;单例设计模式——让类创建的对象，在系统中只有唯一的一个实例。每一次执行 类名() 返回的对象，内存地址是相同的&lt;br&gt;
    
    </summary>
    
      <category term="语言学习" scheme="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python类属性和类方法</title>
    <link href="/2020/06/02/python%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
    <id>/2020/06/02/python类属性和类方法/</id>
    <published>2020-06-02T15:30:58.000Z</published>
    <updated>2020-06-02T16:21:24.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录python类属性和类方法，并且引申静态方法<br><a id="more"></a></p></blockquote><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><ul><li><strong>类属性</strong> 就是给 <strong>类对象</strong> 中定义的 <strong>属性</strong></li><li>通常用来记录 与这个类相关 的特征</li><li>类属性 不会用于记录 具体对象的特征</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img/20200602_1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class</span> Tool(object):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用赋值语句，定义类属性，记录创建工具对象的总数</span></span><br><span class="line">    <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    def __init__(self, <span class="built_in">name</span>):</span><br><span class="line">        self.<span class="built_in">name</span> = <span class="built_in">name</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 针对类属性做一个计数+1</span></span><br><span class="line">        Tool.<span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建工具对象</span></span><br><span class="line">tool1 = Tool(<span class="string">"斧头"</span>)</span><br><span class="line">tool2 = Tool(<span class="string">"榔头"</span>)</span><br><span class="line">tool3 = Tool(<span class="string">"铁锹"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 知道使用 Tool 类到底创建了多少个对象?</span></span><br><span class="line">print(<span class="string">"现在创建了 %d 个工具"</span> % Tool.<span class="built_in">count</span>)</span><br></pre></td></tr></table></figure><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><ul><li><strong>类方法</strong> 就是针对 <strong>类对象</strong> 定义的方法</li><li>在 <strong>类方法</strong> 内部可以直接访问 <strong>类属性</strong> 或者调用其他的 <strong>类方法</strong></li></ul><p>语法如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 类方法名<span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li><p>在开发时，如果需要在 类 中封装一个方法，这个方法：</p><ul><li>既 <strong>不需要</strong> 访问 <strong>实例属性</strong> 或者调用 <strong>实例方法</strong></li><li>也 <strong>不需要</strong> 访问 <strong>类属性</strong> 或者调用 <strong>类方法</strong></li></ul></li><li>这个时候，可以把这个方法封装成一个 <strong>静态方法</strong></li></ul><p>语法如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 静态方法名<span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录python类属性和类方法，并且引申静态方法&lt;br&gt;
    
    </summary>
    
      <category term="语言学习" scheme="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python私有属性和私有方法</title>
    <link href="/2020/06/02/python%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/"/>
    <id>/2020/06/02/python私有属性和私有方法/</id>
    <published>2020-06-02T14:30:58.000Z</published>
    <updated>2020-06-02T08:03:36.572Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录python私有属性和私有方法的实现，并且讨论两者的实现方式<br><a id="more"></a></p></blockquote><h2 id="应用场景及定义方式"><a href="#应用场景及定义方式" class="headerlink" title="应用场景及定义方式"></a>应用场景及定义方式</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到</li><li><strong>私有属性</strong> 就是 对象 不希望公开的 属性</li><li><strong>私有方法</strong> 就是 对象 不希望公开的 方法</li></ul><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><ul><li>在 定义属性或方法时，在 属性名或者方法名前 <strong>增加 两个下划线</strong>，定义的就是 私有 属性或方法</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/img/20200602.png" alt="类图" title>                </div>                <div class="image-caption">类图</div>            </figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(<span class="keyword">self</span>, name)</span></span><span class="symbol">:</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="comment"># 不要问女生的年龄</span></span><br><span class="line">        <span class="keyword">self</span>.__age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__secret</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">        print(<span class="string">"我的年龄是 %d"</span> % <span class="keyword">self</span>.__age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaofang = Women(<span class="string">"小芳"</span>)</span><br><span class="line"><span class="comment"># 私有属性，外部不能直接访问</span></span><br><span class="line"><span class="comment"># print(xiaofang.__age)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 私有方法，外部不能直接调用</span></span><br><span class="line"><span class="comment"># xiaofang.__secret()</span></span><br></pre></td></tr></table></figure><h2 id="伪私有属性和私有方法（科普）"><a href="#伪私有属性和私有方法（科普）" class="headerlink" title="伪私有属性和私有方法（科普）"></a>伪私有属性和私有方法（科普）</h2><blockquote><p>提示：在日常开发中，<strong>不要使用这种方式，访问对象的 私有属性 或 私有方法</strong></p></blockquote><p><code>Python</code> 中，并没有 真正意义 的 私有</p><ul><li>在给 属性、方法 命名时，实际是对 名称 做了一些特殊处理，使得外界无法访问到</li><li>处理方式：在 名称 前面加上 _类名 =&gt; _类名__名</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 私有属性，外部不能直接访问到</span></span><br><span class="line"><span class="keyword">print</span>(xiaofang._Women__age)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 私有方法，外部不能直接调用</span></span><br><span class="line">xiaofang._Women__secret()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录python私有属性和私有方法的实现，并且讨论两者的实现方式&lt;br&gt;
    
    </summary>
    
      <category term="语言学习" scheme="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python高级数据类型常用操作</title>
    <link href="/2020/05/30/python%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>/2020/05/30/python高级数据类型常用操作/</id>
    <published>2020-05-30T14:30:58.000Z</published>
    <updated>2020-06-02T07:44:36.581Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录python高级数据类型的常用操作，便于查阅<br><a id="more"></a></p></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><table><thead><tr><th>序号</th><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>增加</td><td>列表.insert(索引, 数据)</td><td>在指定位置插入数据</td></tr><tr><td></td><td></td><td>列表.append(数据)</td><td>在末尾追加数据</td></tr><tr><td></td><td></td><td>列表.extend(列表2)</td><td>将列表2 的数据追加到列表</td></tr><tr><td>2</td><td>修改</td><td>列表[索引] = 数据</td><td>修改指定索引的数据</td></tr><tr><td>3</td><td>删除</td><td>del 列表[索引]</td><td>删除指定索引的数据</td></tr><tr><td></td><td></td><td>列表.remove[数据]</td><td>删除第一个出现的指定数据</td></tr><tr><td></td><td></td><td>列表.pop</td><td>删除末尾数据</td></tr><tr><td></td><td></td><td>列表.pop(索引)</td><td>删除指定索引数据</td></tr><tr><td></td><td></td><td>列表.clear</td><td>清空列表</td></tr><tr><td>4</td><td>统计</td><td>len(列表)</td><td>列表长度</td></tr><tr><td></td><td></td><td>列表.count(数据)</td><td>数据在列表中出现的次数</td></tr><tr><td>5</td><td>排序</td><td>列表.sort()</td><td>升序排序</td></tr><tr><td></td><td></td><td>列表.sort(reverse=True)</td><td>降序排序</td></tr><tr><td></td><td></td><td>列表.reverse()</td><td>逆序、反转</td></tr></tbody></table><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><table><thead><tr><th>序号</th><th>关键字/函数/方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>tuple.index(“value”)</td><td>查找值为value的元素下标</td></tr><tr><td>2</td><td>tuple.count(“value”)</td><td>统计值为count的元素个数</td></tr></tbody></table><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典和列表非常相似</p><table><thead><tr><th>序号</th><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>取值</td><td>dict.values()</td><td>获取所有value</td></tr><tr><td></td><td></td><td>dict.keys()</td><td>获取所有key</td></tr><tr><td></td><td></td><td>dict.item()</td><td>获取所有键值对</td></tr><tr><td>2</td><td>合并</td><td>dict.update(dict2)</td><td>将dict2合并到dict中</td></tr><tr><td>3</td><td>删除</td><td>dict.pop(“key”)</td><td>删除key对应的键值对</td></tr><tr><td></td><td></td><td>del dict[“key”]</td><td>除key对应的键值对</td></tr></tbody></table><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><table><thead><tr><th>序号</th><th>关键字/函数/方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>string.index(“sub_string”)</td><td>查找字串sub_string第一次出现的下标</td></tr><tr><td>2</td><td>string.count(“sub_string”)</td><td>统计字串sub_string出现的次数</td></tr><tr><td>3</td><td>len(string)</td><td>返回字符串的长度</td></tr></tbody></table><h3 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.isspace()</td><td>如果 string 中只包含空格，则返回 True</td></tr><tr><td>string.isalnum()</td><td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True</td></tr><tr><td>string.isalpha()</td><td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td></tr><tr><td>string.isdecimal()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code></td></tr><tr><td>string.isdigit()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>、<code>⑴</code>、<code>\u00b2</code></td></tr><tr><td>string.isnumeric()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>，<code>汉字数字</code></td></tr><tr><td>string.istitle()</td><td>如果 string 是标题化的(每个单词的首字母大写)则返回 True</td></tr><tr><td>string.islower()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True</td></tr><tr><td>string.isupper()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True</td></tr></tbody></table><h3 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.startswith(str)</td><td>检查字符串是否是以 str 开头，是则返回 True</td></tr><tr><td>string.endswith(str)</td><td>检查字符串是否是以 str 结束，是则返回 True</td></tr><tr><td>string.find(str, start=0, end=len(string))</td><td>检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 <code>-1</code></td></tr><tr><td>string.rfind(str, start=0, end=len(string))</td><td>类似于 find()，不过是从右边开始查找</td></tr><tr><td>string.index(str, start=0, end=len(string))</td><td>跟 find() 方法类似，不过如果 str 不在 string 会报错</td></tr><tr><td>string.rindex(str, start=0, end=len(string))</td><td>类似于 index()，不过是从右边开始</td></tr><tr><td>string.replace(old_str, new_str, num=string.count(old))</td><td>把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</td></tr></tbody></table><h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr><td>string.title()</td><td>把字符串的每个单词首字母大写</td></tr><tr><td>string.lower()</td><td>转换 string 中所有大写字符为小写</td></tr><tr><td>string.upper()</td><td>转换 string 中的小写字母为大写</td></tr><tr><td>string.swapcase()</td><td>翻转 string 中的大小写</td></tr></tbody></table><h3 id="文本对齐"><a href="#文本对齐" class="headerlink" title="文本对齐"></a>文本对齐</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.ljust(width)</td><td>返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.rjust(width)</td><td>返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.center(width)</td><td>返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</td></tr></tbody></table><h3 id="去除空白字符"><a href="#去除空白字符" class="headerlink" title="去除空白字符"></a>去除空白字符</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.lstrip()</td><td>截掉 string 左边（开始）的空白字符</td></tr><tr><td>string.rstrip()</td><td>截掉 string 右边（末尾）的空白字符</td></tr><tr><td>string.strip()</td><td>截掉 string 左右两边的空白字符</td></tr></tbody></table><h3 id="拆分和连接"><a href="#拆分和连接" class="headerlink" title="拆分和连接"></a>拆分和连接</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.partition(str)</td><td>把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)</td></tr><tr><td>string.rpartition(str)</td><td>类似于 partition() 方法，不过是从右边开始查找</td></tr><tr><td>string.split(str=””, num)</td><td>以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td></tr><tr><td>string.splitlines()</td><td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td></tr><tr><td>string.join(seq)</td><td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td></tr></tbody></table><h2 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录python高级数据类型的常用操作，便于查阅&lt;br&gt;
    
    </summary>
    
      <category term="语言学习" scheme="/categories/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>pycharm costomized configuration</title>
    <link href="/2020/05/29/pycharm%20costomized%20configuration/"/>
    <id>/2020/05/29/pycharm costomized configuration/</id>
    <published>2020-05-29T14:30:58.000Z</published>
    <updated>2020-05-29T14:30:27.358Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>PyCharm Community Edition is a free and open-source IDE which is perfect for pure Python coding. For professional Web and Scientific development see PyCharm Professional Edition.</p></blockquote><a id="more"></a><h2 id="default-restoring"><a href="#default-restoring" class="headerlink" title="default restoring"></a>default restoring</h2><p>type in console<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -r ~/.PyCharm2016<span class="number">.3</span></span><br></pre></td></tr></table></figure></p><p>filename <code>PyCharm2016.3</code> can be changed as your need.</p><h2 id="interpreter-selecting"><a href="#interpreter-selecting" class="headerlink" title="interpreter selecting"></a>interpreter selecting</h2><p>enter into <code>file</code> -&gt; <code>settings</code> -&gt; <code>Project:xxx</code> -&gt; <code>project interpreter</code> -&gt; select your new interpreter.</p><h2 id="font-style"><a href="#font-style" class="headerlink" title="font style"></a>font style</h2><p><code>file</code>-&gt;<code>settings</code>-&gt;<code>editor</code>-&gt;<code>colors &amp; fonts</code>-&gt;<code>font</code> or <code>console font</code> -&gt; choose your favor font style and size.</p><h2 id="download-and-install"><a href="#download-and-install" class="headerlink" title="download and install"></a>download and install</h2><ol><li>download package from relative web site. (nomally xxx.tar.gz)</li><li>decompress the package</li><li>move the folder to <code>/opt</code></li><li>change current location to <code>/opt/pycharm-xxx/bin</code></li><li>run <code>./pycharm.sh</code></li></ol><h2 id="console-word-wraps"><a href="#console-word-wraps" class="headerlink" title="console word wraps"></a>console word wraps</h2><ol><li>open the python console</li><li>click the first button <code>soft-wrap</code> </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;PyCharm Community Edition is a free and open-source IDE which is perfect for pure Python coding. For professional Web and Scientific development see PyCharm Professional Edition.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="python" scheme="/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>n皇后问题</title>
    <link href="/2020/05/10/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>/2020/05/10/n皇后问题/</id>
    <published>2020-05-10T03:43:21.000Z</published>
    <updated>2020-05-10T07:31:47.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>n皇后问题是指在n*n的国际象棋棋盘上放置n个皇后，使得n个皇后两两均不在同一行、同一列、同一条对角线上，求合法的方案数。<br><a id="more"></a></p></blockquote><p>根本方法是利用<code>全排列</code>和<code>筛选</code>。</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;math.h&gt;</span><br><span class="line"><span class="built_in">int</span> count=<span class="number">0</span>, n;</span><br><span class="line"><span class="built_in">int</span> P[MAX], Hash[MAX]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">void</span> generateP(index)&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==n+<span class="number">1</span>)&#123;  <span class="comment">// 递归边界</span></span><br><span class="line">        <span class="built_in">int</span> i,j, flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;  <span class="comment">// 筛选</span></span><br><span class="line">            <span class="keyword">for</span> (j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(abs(i-j)==abs(P[i]-P[j])) flag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">1</span>) count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Hash[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            P[index]=i;</span><br><span class="line">            Hash[i]==<span class="number">1</span>;</span><br><span class="line">            generateP(index+<span class="number">1</span>);</span><br><span class="line">            Hash[i]==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;n皇后问题是指在n*n的国际象棋棋盘上放置n个皇后，使得n个皇后两两均不在同一行、同一列、同一条对角线上，求合法的方案数。&lt;br&gt;
    
    </summary>
    
      <category term="algorithum" scheme="/categories/algorithum/"/>
    
    
      <category term="算法" scheme="/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>英文短文朗读规则</title>
    <link href="/2020/04/22/%E8%8B%B1%E6%96%87%E7%9F%AD%E6%96%87%E6%9C%97%E8%AF%BB%E8%A7%84%E5%88%99-md/"/>
    <id>/2020/04/22/英文短文朗读规则-md/</id>
    <published>2020-04-22T15:06:07.000Z</published>
    <updated>2020-04-22T15:12:21.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A manual for speaking English.<br><a id="more"></a></p></blockquote><h1 id="发音规则"><a href="#发音规则" class="headerlink" title="发音规则"></a>发音规则</h1><p>中文说圆润，多加练习。</p><h2 id="1-词中重音"><a href="#1-词中重音" class="headerlink" title="1. 词中重音"></a>1. 词中重音</h2><p>名词多数第一个重读，二元动词放在第二个音节</p><h2 id="2-句中重音"><a href="#2-句中重音" class="headerlink" title="2. 句中重音"></a>2. 句中重音</h2><ol><li>一个内容词，重读；</li><li>两个内容词，第二个重读；</li><li>a+n : stress n；</li><li>a+a+n: stress first a and n；</li><li>n+n : stress the first n (+ing = n)；</li><li>v-prep: stress v (make-up)；</li><li>n+ prep : stress prep；</li><li>人名地名: stress the last；</li><li>Abbr: strss the last letter；<br>10 .from me/ for them 全部轻读</li><li>prep + 两个词以上，要重读最后一个</li><li>anything是虚的</li></ol><h2 id="3-升降调"><a href="#3-升降调" class="headerlink" title="3. 升降调"></a>3. 升降调</h2><ol><li>yes/no (声调)</li><li>wh (降调)</li><li>并列词 除了最后一个降调，其他升调</li><li>介绍性语句，升调</li></ol><h2 id="4-省略"><a href="#4-省略" class="headerlink" title="4. 省略"></a>4. 省略</h2><ol><li>元音合并、辅音省略</li><li>her him he she 省略辅音</li><li>辅音一致可以省略一个 sh sh</li></ol><h2 id="5-浊化"><a href="#5-浊化" class="headerlink" title="5. 浊化"></a>5. 浊化</h2><ol><li>辅音字母在两元音之间要被浊化 photo -&gt; phodo</li><li>p-b t-d s-z c-g-k f-v 浊化</li></ol><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><p>basically/actually/practically/physically/accidentally/generally 省略a音</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;A manual for speaking English.&lt;br&gt;
    
    </summary>
    
      <category term="English" scheme="/categories/English/"/>
    
    
      <category term="发音" scheme="/tags/%E5%8F%91%E9%9F%B3/"/>
    
  </entry>
  
</feed>
