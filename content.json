{"meta":{"title":"Vinson-sheep","subtitle":"Vinson Sheep is on his time zone","description":"分享技术和生活的博客","author":"Vinson-sheep","url":""},"pages":[{"title":"About","date":"2020-03-18T09:36:35.482Z","updated":"2017-09-22T16:30:56.768Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"关于我@card{ yangyongsheng 别名vinson、Vinson-sheep、文森羊。 暨南大学在校学生。 记得一开始，自己什么也不懂，对于编辑器是何物也是茫然。渐渐接触了html和css后，开始对网站的编码感兴趣，于是选择了前端方向发展。不过我究竟还是个初学者，为了解更多知识，我还上网找了不少资料、看了不少书籍。我发现，像CSDN和知乎这些社交类平台，大家都很乐意分享自己的知识。不知是否是有利益驱使，他们这种乐于分享的精神是我很赞赏的。 偶然看到有些技术大咖会有自己的博客，他们会利用自己这个平台构建一个知识分享的社区，对我来说，这是梦幻般的事情。同样通过代码世界的子民分享的知识，我学习了javascript而又跑去后端构建数据库和编写脚本。途中种种bug还有前行者的细心解答，让我收益匪浅。代码世界的前行，究竟还是少不了其他子民的共同努力。 我想做个浪漫的人，这个博客为此诞生了。我希望通过这个网站发布一些技术文章、图片甚至是自己写的小说，为你的生活添上色彩。 如果你喜欢，欢迎点赞和评论。 } 关于本网站@card{ www.vinsongeek.com是用来分享信息和做学习记录的个人博客。 博客文章并非100%，内容多少会参考其他博主的资料，所以我尽可能地在每篇文章底部注明来源，以示尊重。 如果本站文章侵犯了其他笔者的原创作品，请联系删除。 本站文章不作商业用途，如需转载请联系站长。 } 联系方式@card{ QQ: 775014077 邮箱: `775014077@qq.com` }"},{"title":"categories","date":"2017-09-21T06:08:02.000Z","updated":"2017-09-22T14:41:25.245Z","comments":false,"path":"categories/index.html","permalink":"/categories/index.html","excerpt":"","text":""},{"title":"画廊","date":"2020-03-18T09:36:35.490Z","updated":"2019-02-16T13:12:50.912Z","comments":false,"path":"gallery/index.html","permalink":"/gallery/index.html","excerpt":"","text":"Miku 这是我接触SAI上色的第一幅作品。个人对于上色还是挺自信的，嘿嘿，先舔屏 涂鸦作品 以学院团学会代表身份参加的涂鸦大赛，拿个三等奖 暨妹妹 暨妹妹是我喜欢为数不多的几个角色之一，特意画了一下她生气的样子，看来我在某方面没救了。"},{"title":"tags","date":"2017-09-21T06:07:44.000Z","updated":"2017-09-21T06:08:43.039Z","comments":false,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python文件和目录操作","slug":"python文件和目录操作","date":"2020-06-05T10:46:58.000Z","updated":"2020-06-05T11:06:53.391Z","comments":true,"path":"2020/06/05/python文件和目录操作/","link":"","permalink":"/2020/06/05/python文件和目录操作/","excerpt":"使用系统模块os，对文件和目录进行操作。","text":"使用系统模块os，对文件和目录进行操作。 在 终端 / 文件浏览器、 中可以执行常规的 文件 / 目录 管理操作，例如：创建、重命名、删除、改变路径、查看目录内容、…… 在 Python 中，如果希望通过程序实现上述功能，需要导入 os 模块 文件操作 序号 方法名 说明 示例 01 rename 重命名文件 os.rename(原文件名， 目标文件名) 02 remove 删除文件 os.remove(文件名) 目录操作 序号 方法名 说明 示例 01 listdir 目录列表 os.listdir(目录名) 02 mkdir 创建目录 os.mkdir(目录名) 03 rmdir 删除目录 os.rmdir(目录名) 04 getcwd 获取当前目录 os.getcwd() 05 chdir 修改当前目录 os.chdir(目标目录) 06 path.isdir 判断是否是目录 os.path.isdir(文件路径)","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"python包（package）与发布","slug":"python包（package）与发布","date":"2020-06-05T10:34:58.000Z","updated":"2020-06-05T10:45:29.818Z","comments":true,"path":"2020/06/05/python包（package）与发布/","link":"","permalink":"/2020/06/05/python包（package）与发布/","excerpt":"将模块进行打包，并且发布给其他开发者使用","text":"将模块进行打包，并且发布给其他开发者使用 1. 包1.1 包概念 包 是一个 包含多个模块 的 特殊目录 目录下有一个 特殊的文件 __init__.py 包名的 命名方式 和变量名一致，小写字母 + _ 1.2 __init__要在外界使用 包 中的模块，需要在 __init__.py 中指定 对外界提供的模块列表 123# 从 当前目录 导入 模块列表from . import send_messagefrom . import receive_message 注意：上述方式会让你开发的时候不得不使用多重点表示法去调用函数package.sub_package.func()，替换的方法是直接在__init__中编写函数，这样调用函数时应该编写package.func()。这和其他系统模块一致。 2. 发布模块如果希望自己开发的模块，分享 给其他人，可以按照以下步骤操作 2.1 制作发布压缩包步骤在模块同一目录下创建 setup.py，输入：1234567891011from distutils.core import setupsetup(name=\"hm_message\", # 包名 version=\"1.0\", # 版本 description=\"itheima's 发送和接收消息模块\", # 描述信息 long_description=\"完整的发送和接收消息模块\", # 完整描述信息 author=\"itheima\", # 作者 author_email=\"itheima@itheima.com\", # 作者邮箱 url=\"www.itheima.com\", # 主页 py_modules=[\"hm_message.send_message\", \"hm_message.receive_message\"]) 构建模块1$ python3 setup.py build 生成发布压缩包1$ python3 setup.py sdist 2.2 安装模块将模块给予使用者，然后让他安装模块的系统上123$ tar -zxvf hm_message-1.0.tar.gz$ sudo python3 setup.py install 2.3 卸载模块直接从安装目录下，把安装模块的 目录 删除就可以12$ cd /usr/local/lib/python3.5/dist-packages/$ sudo rm -r hm_message*","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"python模块测试","slug":"python模块测试","date":"2020-06-05T10:29:58.000Z","updated":"2020-06-05T10:33:56.942Z","comments":true,"path":"2020/06/05/python模块测试/","link":"","permalink":"/2020/06/05/python模块测试/","excerpt":"利用name字符串实现模块测试，而不影响主程序的使用","text":"利用name字符串实现模块测试，而不影响主程序的使用 name属性__name__ 是 Python 的一个内置属性，记录着一个 字符串。 如果 是被其他文件导入的，__name__ 就是 模块名 如果 是当前执行的程序 __name__ 是 __main__ 测试代码12345678910111213# 导入模块# 定义全局变量# 定义类# 定义函数# 在代码的最下方def main(): # ... pass# 根据 __name__ 判断是否执行下方代码if __name__ == \"__main__\": main()","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"python单例设计模式","slug":"python单例设计模式","date":"2020-06-03T15:30:58.000Z","updated":"2020-06-02T16:27:48.715Z","comments":true,"path":"2020/06/03/python单例设计模式/","link":"","permalink":"/2020/06/03/python单例设计模式/","excerpt":"单例设计模式——让类创建的对象，在系统中只有唯一的一个实例。每一次执行 类名() 返回的对象，内存地址是相同的","text":"单例设计模式——让类创建的对象，在系统中只有唯一的一个实例。每一次执行 类名() 返回的对象，内存地址是相同的 __new__ 方法 使用 类名() 创建对象时，Python 的解释器 首先 会 调用 __new__ 方法为对象 分配空间__new__ 是一个 由 object 基类提供的 内置的静态方法，主要作用有两个： 1) 在内存中为对象 分配空间 2) 返回 对象的引用 Python 的解释器获得对象的 引用* 后，将引用作为 第一个参数**，传递给 __init__方法 实现关键：自定义__new__方法12345678910111213class MusicPlayer(object): # 定义类属性记录单例对象引用 instance = None def __new__(cls, *args, **kwargs): # 1. 判断类属性是否已经被赋值 if cls.instance is None: cls.instance = super().__new__(cls) # 2. 返回类属性的单例引用 return cls.instance","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"python类属性和类方法","slug":"python类属性和类方法","date":"2020-06-02T15:30:58.000Z","updated":"2020-06-02T16:21:24.796Z","comments":true,"path":"2020/06/02/python类属性和类方法/","link":"","permalink":"/2020/06/02/python类属性和类方法/","excerpt":"记录python类属性和类方法，并且引申静态方法","text":"记录python类属性和类方法，并且引申静态方法 类属性 类属性 就是给 类对象 中定义的 属性 通常用来记录 与这个类相关 的特征 类属性 不会用于记录 具体对象的特征 12345678910111213141516171819class Tool(object): # 使用赋值语句，定义类属性，记录创建工具对象的总数 count = 0 def __init__(self, name): self.name = name # 针对类属性做一个计数+1 Tool.count += 1# 创建工具对象tool1 = Tool(\"斧头\")tool2 = Tool(\"榔头\")tool3 = Tool(\"铁锹\")# 知道使用 Tool 类到底创建了多少个对象?print(\"现在创建了 %d 个工具\" % Tool.count) 类方法 类方法 就是针对 类对象 定义的方法 在 类方法 内部可以直接访问 类属性 或者调用其他的 类方法 语法如下123@classmethoddef 类方法名(cls): pass 静态方法 在开发时，如果需要在 类 中封装一个方法，这个方法： 既 不需要 访问 实例属性 或者调用 实例方法 也 不需要 访问 类属性 或者调用 类方法 这个时候，可以把这个方法封装成一个 静态方法 语法如下123@staticmethoddef 静态方法名(): pass","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"python私有属性和私有方法","slug":"python私有属性和私有方法","date":"2020-06-02T14:30:58.000Z","updated":"2020-06-02T08:03:36.572Z","comments":true,"path":"2020/06/02/python私有属性和私有方法/","link":"","permalink":"/2020/06/02/python私有属性和私有方法/","excerpt":"记录python私有属性和私有方法的实现，并且讨论两者的实现方式","text":"记录python私有属性和私有方法的实现，并且讨论两者的实现方式 应用场景及定义方式应用场景 在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到 私有属性 就是 对象 不希望公开的 属性 私有方法 就是 对象 不希望公开的 方法 定义方式 在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线，定义的就是 私有 属性或方法 类图 123456789101112131415161718class Women: def __init__(self, name): self.name = name # 不要问女生的年龄 self.__age = 18 def __secret(self): print(\"我的年龄是 %d\" % self.__age)xiaofang = Women(\"小芳\")# 私有属性，外部不能直接访问# print(xiaofang.__age)# 私有方法，外部不能直接调用# xiaofang.__secret() 伪私有属性和私有方法（科普） 提示：在日常开发中，不要使用这种方式，访问对象的 私有属性 或 私有方法 Python 中，并没有 真正意义 的 私有 在给 属性、方法 命名时，实际是对 名称 做了一些特殊处理，使得外界无法访问到 处理方式：在 名称 前面加上 _类名 =&gt; _类名__名 12345# 私有属性，外部不能直接访问到print(xiaofang._Women__age)# 私有方法，外部不能直接调用xiaofang._Women__secret()","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"python高级数据类型常用操作","slug":"python高级数据类型常用操作","date":"2020-05-30T14:30:58.000Z","updated":"2020-06-02T07:44:36.581Z","comments":true,"path":"2020/05/30/python高级数据类型常用操作/","link":"","permalink":"/2020/05/30/python高级数据类型常用操作/","excerpt":"记录python高级数据类型的常用操作，便于查阅","text":"记录python高级数据类型的常用操作，便于查阅 列表 序号 分类 关键字 / 函数 / 方法 说明 1 增加 列表.insert(索引, 数据) 在指定位置插入数据 列表.append(数据) 在末尾追加数据 列表.extend(列表2) 将列表2 的数据追加到列表 2 修改 列表[索引] = 数据 修改指定索引的数据 3 删除 del 列表[索引] 删除指定索引的数据 列表.remove[数据] 删除第一个出现的指定数据 列表.pop 删除末尾数据 列表.pop(索引) 删除指定索引数据 列表.clear 清空列表 4 统计 len(列表) 列表长度 列表.count(数据) 数据在列表中出现的次数 5 排序 列表.sort() 升序排序 列表.sort(reverse=True) 降序排序 列表.reverse() 逆序、反转 元组 序号 关键字/函数/方法 说明 1 tuple.index(“value”) 查找值为value的元素下标 2 tuple.count(“value”) 统计值为count的元素个数 字典字典和列表非常相似 序号 分类 关键字 / 函数 / 方法 说明 1 取值 dict.values() 获取所有value dict.keys() 获取所有key dict.item() 获取所有键值对 2 合并 dict.update(dict2) 将dict2合并到dict中 3 删除 dict.pop(“key”) 删除key对应的键值对 del dict[“key”] 除key对应的键值对 字符串 序号 关键字/函数/方法 说明 1 string.index(“sub_string”) 查找字串sub_string第一次出现的下标 2 string.count(“sub_string”) 统计字串sub_string出现的次数 3 len(string) 返回字符串的长度 判断类型 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字 string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 查找和替换 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 大小写转换 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 文本对齐 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 去除空白字符 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 拆分和连接 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\\r’, ‘\\t’, ‘\\n’ 和空格 string.splitlines() 按照行(‘\\r’, ‘\\n’, ‘\\r\\n’)分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 公共方法","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"/tags/Python/"}]},{"title":"pycharm costomized configuration","slug":"pycharm costomized configuration","date":"2020-05-29T14:30:58.000Z","updated":"2020-05-29T14:30:27.358Z","comments":true,"path":"2020/05/29/pycharm costomized configuration/","link":"","permalink":"/2020/05/29/pycharm costomized configuration/","excerpt":"PyCharm Community Edition is a free and open-source IDE which is perfect for pure Python coding. For professional Web and Scientific development see PyCharm Professional Edition.","text":"PyCharm Community Edition is a free and open-source IDE which is perfect for pure Python coding. For professional Web and Scientific development see PyCharm Professional Edition. default restoringtype in console1$ rm -r ~/.PyCharm2016.3 filename PyCharm2016.3 can be changed as your need. interpreter selectingenter into file -&gt; settings -&gt; Project:xxx -&gt; project interpreter -&gt; select your new interpreter. font stylefile-&gt;settings-&gt;editor-&gt;colors &amp; fonts-&gt;font or console font -&gt; choose your favor font style and size. download and install download package from relative web site. (nomally xxx.tar.gz) decompress the package move the folder to /opt change current location to /opt/pycharm-xxx/bin run ./pycharm.sh console word wraps open the python console click the first button soft-wrap","categories":[{"name":"工具","slug":"工具","permalink":"/categories/工具/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"n皇后问题","slug":"n皇后问题","date":"2020-05-10T03:43:21.000Z","updated":"2020-05-10T07:31:47.533Z","comments":true,"path":"2020/05/10/n皇后问题/","link":"","permalink":"/2020/05/10/n皇后问题/","excerpt":"n皇后问题是指在n*n的国际象棋棋盘上放置n个皇后，使得n个皇后两两均不在同一行、同一列、同一条对角线上，求合法的方案数。","text":"n皇后问题是指在n*n的国际象棋棋盘上放置n个皇后，使得n个皇后两两均不在同一行、同一列、同一条对角线上，求合法的方案数。 根本方法是利用全排列和筛选。 暴力法12345678910111213141516171819202122232425#include &lt;math.h&gt;int count=0, n;int P[MAX], Hash[MAX]=&#123;0&#125;;void generateP(index)&#123; if(index==n+1)&#123; // 递归边界 int i,j, flag=1; for(i=1;i&lt;=n;i++)&#123; // 筛选 for (j=i+1;j&lt;=n;j++)&#123; if(abs(i-j)==abs(P[i]-P[j])) flag=0; &#125; &#125; if(flag==1) count++; return; &#125; // 递归 int i; for(i=1;i&lt;=n;i++)&#123; if(Hash[i]==0)&#123; P[index]=i; Hash[i]==1; generateP(index+1); Hash[i]==0; &#125; &#125;&#125; 回溯法略","categories":[{"name":"algorithum","slug":"algorithum","permalink":"/categories/algorithum/"}],"tags":[{"name":"算法","slug":"算法","permalink":"/tags/算法/"}]},{"title":"英文短文朗读规则","slug":"英文短文朗读规则-md","date":"2020-04-22T15:06:07.000Z","updated":"2020-04-22T15:12:21.800Z","comments":true,"path":"2020/04/22/英文短文朗读规则-md/","link":"","permalink":"/2020/04/22/英文短文朗读规则-md/","excerpt":"A manual for speaking English.","text":"A manual for speaking English. 发音规则中文说圆润，多加练习。 1. 词中重音名词多数第一个重读，二元动词放在第二个音节 2. 句中重音 一个内容词，重读； 两个内容词，第二个重读； a+n : stress n； a+a+n: stress first a and n； n+n : stress the first n (+ing = n)； v-prep: stress v (make-up)； n+ prep : stress prep； 人名地名: stress the last； Abbr: strss the last letter；10 .from me/ for them 全部轻读 prep + 两个词以上，要重读最后一个 anything是虚的 3. 升降调 yes/no (声调) wh (降调) 并列词 除了最后一个降调，其他升调 介绍性语句，升调 4. 省略 元音合并、辅音省略 her him he she 省略辅音 辅音一致可以省略一个 sh sh 5. 浊化 辅音字母在两元音之间要被浊化 photo -&gt; phodo p-b t-d s-z c-g-k f-v 浊化 6. 其他basically/actually/practically/physically/accidentally/generally 省略a音","categories":[{"name":"English","slug":"English","permalink":"/categories/English/"}],"tags":[{"name":"发音","slug":"发音","permalink":"/tags/发音/"}]},{"title":"visual c++ 2010 express: LNK1123","slug":"visual-c-2010-express-LNK1123","date":"2020-03-28T10:37:42.000Z","updated":"2020-03-28T10:59:38.772Z","comments":true,"path":"2020/03/28/visual-c-2010-express-LNK1123/","link":"","permalink":"/2020/03/28/visual-c-2010-express-LNK1123/","excerpt":"","text":"the first time I installed visual c++ express 2010, I found that there are something wrong in progress funtion. It said : LINK : fatal error LNK1123: failure during conversion to COFF: file invalid or corrupt. If I just compile my .cpp file, it works well. But when runing the .exe file, it is not. The key problem is that the cvtres.exe in VC directory does not work, because it is too old to support the application. However, the windows system has a new one. That is, when the application start to work, it will find the old one and ignore the other. The solution is simple. First, open ...\\VCExpress\\VC\\bin and find out cvtres.exe. Second, rename cvtres.exe to cvtres_old.exe. OKay, your app is working well.","categories":[{"name":"工具","slug":"工具","permalink":"/categories/工具/"}],"tags":[{"name":"visual c++","slug":"visual-c","permalink":"/tags/visual-c/"}]},{"title":"How to make Atom adapted to Markdown by Plug-ins","slug":"How-to-make-Atom-adapted-to-Markdown-by-Plug-ins","date":"2019-04-01T16:33:57.000Z","updated":"2019-04-01T16:45:55.164Z","comments":true,"path":"2019/04/02/How-to-make-Atom-adapted-to-Markdown-by-Plug-ins/","link":"","permalink":"/2019/04/02/How-to-make-Atom-adapted-to-Markdown-by-Plug-ins/","excerpt":"Atom is light application for simple modification. Usually, I use Atom to write Markdown. Althouth it has a default configuration, it is not enough for me to type a MD document dignity elegantly. So, Plug-ins is required.","text":"Atom is light application for simple modification. Usually, I use Atom to write Markdown. Althouth it has a default configuration, it is not enough for me to type a MD document dignity elegantly. So, Plug-ins is required. Just several steps, let’s go! go into the interfacePackages&gt;&gt;Settings View&gt;&gt;Open&gt;&gt;Install download what you need language-markdown markdown-writer markdown-preview Then you can press Ctrl+Shift+M to open Markdown preview. That’s all! Bye.","categories":[{"name":"工具","slug":"工具","permalink":"/categories/工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"/tags/markdown/"}]},{"title":"漫画正弦 Comic Sine","slug":"曲线求解Curve-Solving","date":"2019-04-01T14:17:24.000Z","updated":"2019-04-01T17:17:19.356Z","comments":true,"path":"2019/04/01/曲线求解Curve-Solving/","link":"","permalink":"/2019/04/01/曲线求解Curve-Solving/","excerpt":"最近，我的老师们讲述了他们的现实故事和独有的人生真理，让我对于人生真理求解的过程有了进一步的理解。现实，它在我人生某个阶段抛出了一个终极问题：人生求解曲线应该是怎么样的？于是有了这篇文章。这篇文章讲述了一个业余梦想家的故事。","text":"最近，我的老师们讲述了他们的现实故事和独有的人生真理，让我对于人生真理求解的过程有了进一步的理解。现实，它在我人生某个阶段抛出了一个终极问题：人生求解曲线应该是怎么样的？于是有了这篇文章。这篇文章讲述了一个业余梦想家的故事。 2025年，中国又完成了一个小目标。某些人，期待狂欢。 雨露清晨，美国纽约。小号中式房间里，Sine习惯性地穿上了他那洗的发白T裇和牛仔裤，带上了标志性的右指套。捎上一份不那么重要的演讲稿，Sine打开了房门，走下了楼梯。 今天，和其他时间稍微不一样。 一个披着红色头发的少年，站在街角，等待着命运的到来。Sine走出公寓门口，刚转了身，少年尾随其后，从腰间掏出了一把USP，往那个人心脏处开了一枪。Sine倒下了。临死瞬间，Sine看着天空，脑海记忆闪烁。 时间倒退27年。 那时候，Sine还没得到“他的名字”，他最初叫“李正弦”。出生前，他父亲从书架上摸出了一本古老的《高等数学》，快速浏览片刻，就指着那个弯曲的图像，为他命了名，希望他长大能当个数学家，并在日常中给他灌输知识。 但在正弦5岁那年，有一件事情改变了他的轨道。当时，日本动漫产业飞速发展，无数至今为人熟知的作品市场挂在中国电视屏幕。正弦当时深深迷上了《灌篮高手》，他用了他2个月的零花钱，买了好几本正版的漫画书。他第一次被平面图形和篮球运动的碰撞深深打动。他把书翻了又翻，每次细看总有不一样的快乐。这件事后来被父亲知道了，以有碍学习之名，将漫画书撕个粉碎。 但他内心感受到召唤，来自二维世界的召唤。 正弦像很多孩子那样，度过了小学、中学、高中。正弦很刻苦学习，在年级排名也不差，父亲因此也不怎么在意他那小小的兴趣。他有时拿起铅笔画画，用歪曲的图像阐述着他曾经幼稚的故事。有时上网冲浪，翻遍各大网站寻找优秀的漫画作品。他有一些志同道合的朋友，这些朋友都对二维世界非常沉迷。他对他的朋友吹牛说，他大学要学动画。 但现实是一条曲线。 高考填报志愿期间，正弦背着父母，把志愿改成了二本学校，专业改成了动画制作。这次“尝试偷渡”首先被老师发现了，再后是父母。正弦免不了父亲的一顿毒打，一向疼爱儿子的妈妈，这次也站在父亲那边。正弦的成绩确实可以上一本，但它远远不够拿到一个他想要的专业。面对灼热的气氛，正弦人生第一次跪了下来，他说，这是他人生唯一的请求，这是他所喜欢的专业，他最钟爱的事业，请父母相信，他一定会做得很好的。父母潸然泪下，点了点头。 本应是这样的。 实际那个男孩，他的所有勇气，在跪下之前，早已消逝。他早就知道，那时候的中国动画行业非常不景气，原因首先是国家的不支持，其次是盗版泛滥，漫画家和动画公司要想幸存，几乎不可能。这样一条路，连自己也看不到未来。他顺从了父母的想法，填了一本的学校，学了跟数学有关的专业。 从那时起，整个大学期间，每当他看到了优秀的设计、精良的动画，内心就会被绞痛。 未完待续…","categories":[{"name":"短篇小说","slug":"短篇小说","permalink":"/categories/短篇小说/"}],"tags":[{"name":"短篇小说","slug":"短篇小说","permalink":"/tags/短篇小说/"},{"name":"short novel","slug":"short-novel","permalink":"/tags/short-novel/"}]},{"title":"chrome extension","slug":"谷歌浏览器插件chrome-extension（英文）","date":"2019-04-01T12:55:26.000Z","updated":"2020-03-18T13:09:36.233Z","comments":true,"path":"2019/04/01/谷歌浏览器插件chrome-extension（英文）/","link":"","permalink":"/2019/04/01/谷歌浏览器插件chrome-extension（英文）/","excerpt":"Several days ago, I re-installed my computer system, means I have lost my chrome extensions I showed fancy to. Back then, however, I slipped up and spent time a lot to handle this extension. For friendly using in the future, I take a note about the process.","text":"Several days ago, I re-installed my computer system, means I have lost my chrome extensions I showed fancy to. Back then, however, I slipped up and spent time a lot to handle this extension. For friendly using in the future, I take a note about the process. 程序包无效 The package is invalidWhile there are a lot of useful extensions to install, I attempt to go throuth the google store to pick up them. Sadly, domestic wall is too steady that I can’t drop by the site. What about installing by hand? For some reasons, it doesn’t work! A paper written by ppdyhappy sort the problem. Firstly, you should download a .crx extension package you like from the extension site. Of course, when you draw the .crx package into the chrome, it will respond with the package is invalid. Change the file extensive name .crx of what you have downloaded into .zip or .rar. Right click this file. After decompressed with decompression software like WINRAR, you will get a new folder. Key in Address Bar chrome://extensions/ to open the chrome browser extensive management interface. Switch on the Developer mode(开发者模式), and choose 加载正在开发的扩展程序..，upload the folder you have decompressed. Normally, you have added a extension to chrome. If you suffer from the attendant problme, you can click original site in search of solution. 必备插件 Essential extension1. 谷歌访问助手 Google Access AssistantGoogle Access Assistant is a awesome extension, allowing you to access google.com(谷歌搜索)、mail.google.com（gmail邮箱） and chrome store(谷歌商店访问) without VPN. But you just can use it in 12 hours unless you follow the action of this site. Because of being modified by third party, it smells of nasty money. 2. TampermonkeyThis extension allow you to download file beyond 1G in the Baidu website, instead of download a PC application in addition. What you should do is just to download the Tampermonkey and pose apropriate script. More detail about how is in this site 图文详解如何利用chrome插件tampermonkey突破百度云盘下载限制 3. Adblock PlusWhen you are surfing online, there are no end of websites showing off their product by Ad block. Since you have Adblock Plus, you get rid of chaos and click throuth the website more quickly.","categories":[],"tags":[{"name":"chrome extension","slug":"chrome-extension","permalink":"/tags/chrome-extension/"},{"name":"browser","slug":"browser","permalink":"/tags/browser/"}]},{"title":"关于科学使用计算机","slug":"关于科学使用计算机","date":"2019-03-27T16:00:04.000Z","updated":"2019-04-06T08:02:54.012Z","comments":true,"path":"2019/03/28/关于科学使用计算机/","link":"","permalink":"/2019/03/28/关于科学使用计算机/","excerpt":"想象一下，你的上司，或者你的男女朋友，不经意看见你的电脑桌面有十几二十个图标，会有什么反应？你把你的房间收拾得很好，但总不能让你的电脑留下”Nasty”的骂名对吧？根据我的个人经验，总结了计算机管理中比较好的“习惯”。","text":"想象一下，你的上司，或者你的男女朋友，不经意看见你的电脑桌面有十几二十个图标，会有什么反应？你把你的房间收拾得很好，但总不能让你的电脑留下”Nasty”的骂名对吧？根据我的个人经验，总结了计算机管理中比较好的“习惯”。 总的来说，计算机管理方法是——优雅 内容有点多，但是坚持下真的可以赢得上司的加分 桌面管理1.桌面凌乱桌面保持整洁，像博主我的桌面就只有5个图标，这样能够提高效率。This PC是我的电脑；Sundries是杂物，专门放一些无法分类的小文件，比如头像等；Entertain是娱乐文件夹，放置了所有程序的快捷方式；Recycle Bin是垃圾桶；Work Place是工作文件夹，无论是学习资料，还是最近的工作文件（毕业论文），我都放进去了，当然是“软链接”。 my desktop 2. 软链接使用比如我正在写毕业论文，我要进入This Pc，然后又点击别的什么玩意，找啊找啊，多麻烦。这时候，请使用软链接，在Work Place文件夹中新建一个short cut。 short cut 让它指向你的毕业论文文件夹即可，这时候就可以用Work Place进入你的毕业论文文件夹了。当你写完论文了，又可以将这个软链接删除。 3. Start开始的使用大家可以欣赏下我的Start（win 10）。按键盘左下角的win键进入，或者windows默认的左下角（对应图中的右上角）。 desktop 我习惯把常用软件都放在这个地方，这样快捷方便，而且很优雅，这是我推荐win 10的原因（win7/xp的朋友自然没这种待遇）。 4. 关于桌面管理软件某些软件，比如wallpaper诸如之类的软件，能够为你的桌面增加一些模块，有的能够列出你常用的软件，有的为你的桌面装扮炫酷的壁纸和特效。这类软件前者占用资源相对较少，后者则非常恐怖。但如果你的电脑已经进入暮年了，那还是不要用这些花里胡哨的东西了。 管理软件1. 杀毒软件首推火绒。火绒是非常简洁的杀毒软件，内含垃圾清理等模块，基本满足一般PC的需求，并且不会有弹窗，杀毒性能优秀。永远不推荐360，360有很多捆绑软件，稍有不甚就下载了。当长期使用360，后台一些程序会长期占用你的CPU和内存，但它没什么作用，这跟病毒有什么区别？ 2. 驱动软件硬件要配合软件，长期更新硬件驱动（比如显卡驱动）有助于让你的计算机再相同配置下跑得更快。 我推荐鲁大师和驱动精灵。我常用的是鲁大师，没什么，就是用习惯了。驱动精灵用过一段时间，但是弹窗相对厉害，就停止了。 其他软件1. 浏览器推荐用谷歌的chrome，除了快，还能使用一些插件。其他浏览器像firefox、opera、Edge等，我都推荐，但是chrome真的公认的优秀。很多前后端（网页）做得比较垃圾（我不是指谁，就是说我学校的教务系统），需要用到360、UC一类浏览器，但我还是建议，长期使用chrome比较好。360等浏览器可以留在你的硬盘，但一定要屏蔽掉所有副作用，比如篡改你的主页（最恶心，没有之一）。 2. 没想到，嘿嘿习惯养成1. 开机不启动很多软件，比如鲁大师，会设置开机启动。但我明明有了火绒这个真爱了，为甚么还要你这个二奶呢？不用的程序请禁用掉，否则从开机开始一直占用你的资源。否则，不要问为什么会卡。 2. 下载的软件不要放在C盘C盘是系统盘，应该保持它只放系统文件就可以了。如果有病毒感染，第一时间受灾的必定是系统盘，更不用说挽救你桌面的毕业论文了。 3. 删除捆绑软件360等总是捆绑一些软件污染我们的电脑，记得在控制面板清理干净。 4. 定期杀毒和清理垃圾不用多说了，大家都懂。 5. 实在不行，那就重装我给许多人装过系统，但是部分反映他们的电脑很快就很卡。这就很奇怪了，我明明给你们装的是同一个ghost安装包，我自己重装也是用这个安装包。计算机很少会出现系统不兼容的问题，因为…系统不兼容硬件诶，那可是大事情啊，老是吃软饭的微软居然会做出不靠谱的系统？我对于“系统不兼容硬件”这种观点保持怀疑的态度，更何况已经更新了许多个版本了。但不管怎么说，人生苦短，实在不行，我选择重装。重装教程 保持计算机整洁是个好习惯。多折腾、多去折磨那些陷害我们的捆绑软件，是对强迫他们提升服务体验的间接途径，是一个优秀消费者的维权意识体验，是让自己后院（你的PC）长期绿树开花的优秀习惯。最后，祝每位看到最后的读者，能为自己的上司带来美好的清晨。 end","categories":[],"tags":[{"name":"计算机管理","slug":"计算机管理","permalink":"/tags/计算机管理/"}]},{"title":"removable disk病毒删除","slug":"removable-disk病毒删除","date":"2019-03-01T16:55:22.000Z","updated":"2019-03-01T17:11:28.049Z","comments":true,"path":"2019/03/02/removable-disk病毒删除/","link":"","permalink":"/2019/03/02/removable-disk病毒删除/","excerpt":"前阵子在红外实验室的电脑发现了一个病毒，名为removable disk。当你将U盘插入到感染病毒的电脑中，你U盘里面的东西会“消失”。","text":"前阵子在红外实验室的电脑发现了一个病毒，名为removable disk。当你将U盘插入到感染病毒的电脑中，你U盘里面的东西会“消失”。 要处理这个病毒，可以选择以下方法（亲测）。 将U盘在别的电脑清空，保留一个杀毒软件安装包（杀毒软件我推荐火绒） 将U盘插入到受病毒感染的电脑上，这时候可以发现东西都不见了 操作：我的电脑-&gt;查看-&gt;隐藏的项目，可以在U盘看到存在一个无名隐藏文件夹 点击这个无名隐藏的文件夹，可以看到你U盘里面的东西都转移到这里了 将文件夹里面的东西（杀毒软件安装包）复制到U盘的主目录，然后打开杀毒软件安装包，安装杀毒软件 进入杀毒软件进行全盘杀毒（像火绒这类杀完毒都会报警），这时候重启发现U盘的东西还在（成功了） 为了避免已经中毒的U盘再次感染电脑，请保留杀毒软件 完成","categories":[],"tags":[{"name":"病毒","slug":"病毒","permalink":"/tags/病毒/"}]},{"title":"win10专业版安装","slug":"win10专业版安装","date":"2019-02-16T13:30:34.000Z","updated":"2019-03-01T16:53:58.315Z","comments":true,"path":"2019/02/16/win10专业版安装/","link":"","permalink":"/2019/02/16/win10专业版安装/","excerpt":"win10专业版，半年激活一下，安装流程记录。","text":"win10专业版，半年激活一下，安装流程记录。 1. 重装准备 一个8G以上的U盘，最好将里面的东西清理干净 在PC上安装大白菜U盘启动盘制作工具 启动大白菜工具，进入操作界面（如图） 大白菜界面 选择要刻录的U盘，再点击一键制作成USB启动盘 可以选择性点击模拟启动，观看PE操作界面 准备一个win10专业纯净版ghost，后缀为iso，复制到U盘里面（PE和iso文件是独立的） 2. 重装开始 重启电脑，一般来说，不需要设置BIOS的启动顺序，直接就能进入PE选择界面（如图） 大白菜选择界面 选择启动Win10 X64 PE（2G以上启动），进入PE PE 之后操作，按照官方操作指南即可 另外，选择ghost的时候，建议选择Win10专业纯净版，因为个人自己下载的ghost并没有被识别。 3. 重装问题垃圾捆绑软件大白菜这个ghost，表面是写着纯净版，实际上捆绑了五六个如360等流氓软件，通用方法：进入控制面板逐一删除。 数字间隔问题通过默认输入法打汉字，字距没有问题，但英文、数字等都有很大间隔，看起来很不和谐，这是圆角半角的问题，建议方法：参照这里 fn关闭问题笔记本特有问题。输入一些字符的时候（比如0）会输出0键上面另外的符号（如)），如果按着fn键再按0，这才输出0。这个是fn键默认开启的原因，建议方法：同时按下Fn+Num lock关闭fn键 不能连接校园网这个是输入法问题，解决以上两个问题即可解决。 win10激活问题普通家庭版Win10是可以免费的，但是由于安装的是专业版，功能更为强大，目前没有完美的破解方案，所以只能通过“薛定谔的激活”来维持。建议方法：保存并使用自带KMSAuto工具 旧系统清除问题安装了新系统之后，旧系统残留在其他地方，这使得用户每次开机都得选择启动盘，这非常麻烦，最好是将旧系统盘格式化，但是用新系统格式化旧系统盘会提示权限不够。建议方法：进入PE，点击分区工具，格式化旧系统盘 删除引导即使格式化旧系统盘，旧引导可能残留。建议方法：进入PE，点击引导修复，处理掉旧印度","categories":[],"tags":[{"name":"装机","slug":"装机","permalink":"/tags/装机/"}]},{"title":"英语重音和升降调规则总结","slug":"英语重音和升降调规则总结","date":"2018-05-27T09:02:47.000Z","updated":"2018-05-27T14:27:55.323Z","comments":true,"path":"2018/05/27/英语重音和升降调规则总结/","link":"","permalink":"/2018/05/27/英语重音和升降调规则总结/","excerpt":"看过《RWBY》后非常陶醉于其中的美式幽默和快速流利的oral English，虽然这学期有语音语调的课程，但并没有认真学。以至于我现在找了许多资料，总结一下英语重音和升降调规则。","text":"看过《RWBY》后非常陶醉于其中的美式幽默和快速流利的oral English，虽然这学期有语音语调的课程，但并没有认真学。以至于我现在找了许多资料，总结一下英语重音和升降调规则。 学英语很多年了，但是老师从来就没有教过你如何正确发音……另一方面，我们缺乏与外国人直接交流的经验。下面总结英语口语的关键点 （长期更新） 弱读和重读一般来说，实意词（名词、动词、形容词、副词等）需要重读，虚词（it、the等）需要弱读。一个单词被重读，是不需要重读所有的音节的，我们仅仅需要处理这个单词的词重音就可以了。 对于双音节词语来说，如果重音在前，读起来像拼音的一声; 如果重音在后，读起来就想拼音的四声。 重音规则1. 名词 一般都重读1There is a 'book on the 'desk. 2. 形容词 一般都应重读1The 'sky is 'blue. 3. 数词 一般都应重读1His 'first daughter is fif'teen. 4. 动词 主要动词，或称实意动词、行为动词 都要重读1He 'takes a 'walk after 'supper 'every 'day. 5. 副词，大部分副词需要重读1They can speak English 'fluently. 6. 代词常重读的代词有： 指示代词1'This is 'not what I 'mean. 但如指示代词前后都有重音时，该指示代词失去重音。1'How do you 'like those 'little ones? 反身代词 1He him'self cooked the dinner. 不定代词 1We are 'many, they are 'few. 疑问代词 1'What can I 'do for you? 更详细看这里 Stress Time汉语是音节计时型语言，一句话的长短往往取决于一句话中音节数目的多少。 英语是重音计时型语言，一句话的长短往往取决于一句话中重音数目的多少。 比如，12好！太好了！ // 四个stress Time，四个时间单位Good! Wonderful! // 重音落在good和won，两个时间单位 停顿为什么我们会跟读英语的时候感觉跟不上气了？ 我们在讲英文的时候其实和讲中文一样，在说的时候是不会在意哪里需要停顿，但是我们中文说得很好，英文就有困难了。这就需要大量练习去适应英语口语的停顿规则。","categories":[{"name":"英语学习","slug":"英语学习","permalink":"/categories/英语学习/"}],"tags":[{"name":"英语","slug":"英语","permalink":"/tags/英语/"}]},{"title":"C语言之按位运算符","slug":"C语言之按位运算符","date":"2018-04-20T12:53:52.000Z","updated":"2018-04-20T14:31:11.255Z","comments":true,"path":"2018/04/20/C语言之按位运算符/","link":"","permalink":"/2018/04/20/C语言之按位运算符/","excerpt":"实话说，写了一年多的代码了，从来没有想过要对数据进行按位运算。接触之后发现这跟《数据逻辑》的部分知识结构相吻合，比如与门、或门、非门等。相信学计算机的大家们早已烂透在心底了。我这里做一个记录，方便以后写C的时候查询。","text":"实话说，写了一年多的代码了，从来没有想过要对数据进行按位运算。接触之后发现这跟《数据逻辑》的部分知识结构相吻合，比如与门、或门、非门等。相信学计算机的大家们早已烂透在心底了。我这里做一个记录，方便以后写C的时候查询。 在C语言中，可以单独操控变量中的位。 处理一个值中的位的两个C工具：位运算符和位字段 位运算符按位逻辑运算符二进制反码或按位取反：~一元运算符~把1变为0，把0变为1。例子如下：1234~(10011010) // 表达式(01100101) // 结果值val = ~val; 按位与：&amp;二元运算符&amp;通过逐位比较两个运算对象，生成一个新值。对于每个位，只有两个运算对象中相应的位都为1时，结果才为1。例子如下：12345(10010011)&amp;(00111101) // 表达式(00010001) // 结果值val &amp;= 0377;val = val &amp; 0377; 按位或：|二元运算符，通过逐位比较两个运算对象，生成一个新值。对于每个位，如果两个运算对象中相应的位为1，结果就为1.12345(10010011)|(00111101) // 表达式(10111111) // 结果值val |= 0377;val = val | 0377; 按位异或：^二位运算符……逐位比较两个运算对象。对于每个位，如果两个运算对象中相应的位一个为1（但不是两个为1），结果为1。12345(10010011)^(00111101) // 表达式(10101110) // 结果值val ^= 0377;val = val ^ 0377; 移位运算符下面介绍C的移位运算符。移位运算符向左或右移动位。 左移：&lt;&lt;左侧运算对象移出左末端位的值丢失，用0填充空出的位置。12(10001010) &lt;&lt; 2 // 表达式(00101000) // 结果值 右移：&gt;&gt;对于无符号类型，用0填充空出的位置。12(10001010) &gt;&gt; 2 // 表达式，无符号值(00100010) // 所有系统都得到该结果值 对于有符号类型，其结果取决于机器。1234(10001010) &gt;&gt; 2 // 表达式，有符号值(00100010) // 在某些系统中的结果值(10001010) &gt;&gt; 2 // 表达式，有符号值(11100010) // 在另一些系统上的结果值 位字段操控位的第二种方法是位字段。 下面的声明建立一个4个1位的字段：123456struct &#123; unsigned int autfd : 1; unsigned int bldfc : 1; unsigned int undln : 1; unsigned int itals : 1;&#125; 这时候就能通过下列语句赋值：12prnt.itals = 0;prnt.undln = 1; 注意需要赋的值不能超过位数所能表示的最大数值，不然会占用下一个unsigned int类型的存储位置。","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"/tags/C语言/"}]},{"title":"C语言对const的一些理解","slug":"C语言对const的一些理解","date":"2018-04-13T17:08:00.000Z","updated":"2018-04-13T17:45:00.384Z","comments":true,"path":"2018/04/14/C语言对const的一些理解/","link":"","permalink":"/2018/04/14/C语言对const的一些理解/","excerpt":"编写过ES6的我对const用得也不多，看了一些关于const的特殊用法之后，觉得我对const有了新的理解。","text":"编写过ES6的我对const用得也不多，看了一些关于const的特殊用法之后，觉得我对const有了新的理解。 windows 10 初始化数据我们来初始化一些数据：1234double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;const double locked[4] = &#123;0.08, 0.075, 0.0725, 0.07&#125;;const double *pc = rates;double *pnc = rates; rates数组是可读可写的，locked只能读，第三、四句将rates的首地址赋值给pc、pnc指针(注意，此处使用了const，而pnc没有)。 开始测试第一次1pc[0] = 0.0; 操作无效，这非常合理，因为使用了const。 第二次1rates[5] = 0.0; 操作有效，证明了数组rate的物理地址赋值给pc依然没有改变rates的性质。这看来也非常合理。 第三次1pnc = locked; 操作无效。可能你还没有发现究竟发生了什么事情？我一一罗列出来(为了方便，const表示使用了const的，no-const相反)： const空指针能被const数组赋值，也能被no-const数组赋值 no-const空指针不能被const数组赋值，但依然可以被no-const数组赋值 无论是const还是no-const空指针，被赋值后不会改变原来数组的可写性 结果分析const好比是一个标识符，它能表示某个变量是只读的。注意只是标识某个变量，不是物理地址。 所以const double *pc = rates;中，pc被标识为只读，故调用pc这指针变量的一切表达式都会视数组为只读，如pc[0] = 0.0;。 而rates没有使用const初始化，故调用rates这指针变量的一切表达式都会视数组为可读可写，如rates[5] = 0.0;。 但是no-const空指针不能被const数组赋值是什么操作呢？其实是编译器在保护const数组。如果随便将物理地址重新赋值给一个新的指针就能改变数组的可写性，那么初始化声明中const就被架空了。","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"原创","slug":"原创","permalink":"/tags/原创/"},{"name":"C语言","slug":"C语言","permalink":"/tags/C语言/"}]},{"title":"C语言为什么不能解引用未初始化的指针——实践归纳","slug":"C语言为什么不能解引用未初始化的指针——实践归纳","date":"2018-04-13T16:35:17.000Z","updated":"2018-04-13T17:05:15.466Z","comments":true,"path":"2018/04/14/C语言为什么不能解引用未初始化的指针——实践归纳/","link":"","permalink":"/2018/04/14/C语言为什么不能解引用未初始化的指针——实践归纳/","excerpt":"解引用是返回内存地址中保存的值。为什么不能直接返回未初始化的指针呢？在我第一次看书的时候，十分困惑，于是手动设计了一些代码测试了一下，在此作总结。","text":"解引用是返回内存地址中保存的值。为什么不能直接返回未初始化的指针呢？在我第一次看书的时候，十分困惑，于是手动设计了一些代码测试了一下，在此作总结。 windows 10 问题在哪为了阐述这篇文章的重要性。首先，编译后尝试运行下列程序：12345678910#include &lt;stdio.h&gt;int main(void)&#123; int *ptr = 0;// *ptr = 0; printf(\"%d\", ptr); return 0;&#125; 系统返回了0，证明程序是正常工作的。 于是我们稍微修改一下代码：1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123; int *ptr; *ptr = 0; printf(\"%d\", ptr); return 0;&#125; 编译后运行。嗯？xxx.exe 已停止工作！ 对比前后代码，其实逻辑都是一样的。只是ptr处的值使用了*ptr=0来赋予。 归纳解析引用《C primer plus》的一段话： 12&gt; int * pt; // 未初始化指针&gt; *pt = 5; // 严重的错误 为何不行？第2行的意思是把5储存在pt指向的位置。但是pt未被初始化，其值是一个随机值，所以不知道5将存储在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针时，系统只分配了存储指针本身的内存，并未肥胖存储数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。 刚声明pt指针的时候，指针并没有指向任何的地址。 但是对比我自己设计的两个小程序，我个人目前是这样认为的：int *ptr = 0;是初始化声明，由于是一条语句完成，编译器分析得出0为初始值，则为ptr指针分配数据存储的内存，并且将具体的物理地址返回给ptr。但是如果分两条语句去写int *ptr;*ptr = 0;，指针声明的时候，编译器分析得出此处没有初始值，则不分配数据内存。而遇到第二条语句的时候，编译器解读为将0赋值给ptr指针所指的数据地址仅此而已，它的具体操作是将数据覆盖，但是没有分配内存。这就解析了为何同一个变量被多次赋值，其物理地址都不发生变化。其根本原因是编译器只更换数据，没有申请内存空间。 那么，设计代码*ptr = 0中，0究竟赋值到什么地方去了？《C primer plus》表示母鸡噢。 解决方案实际上内存的申请是有专用的函数malloc()，每次声明一个指针之前要想想要不要手动申请内存空间。","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"/tags/C语言/"}]},{"title":"C语言之函数原型声明——详解","slug":"C语言之函数原型声明——详解","date":"2018-04-11T10:44:39.000Z","updated":"2018-04-11T11:17:38.263Z","comments":true,"path":"2018/04/11/C语言之函数原型声明——详解/","link":"","permalink":"/2018/04/11/C语言之函数原型声明——详解/","excerpt":"以前写javascript的时候解析器会有变量声明提前这一功能，但是C语言不会提前，相反我们编写的代码中需要函数原型声明。何谓函数原型声明呢？我在这篇文章中会详细讨论。总之，函数原型声明实现起来简单，但是非常重要。","text":"以前写javascript的时候解析器会有变量声明提前这一功能，但是C语言不会提前，相反我们编写的代码中需要函数原型声明。何谓函数原型声明呢？我在这篇文章中会详细讨论。总之，函数原型声明实现起来简单，但是非常重要。 javascript的变量声明提前是指函数中的所有变量会在函数执行之前放在函数的参数链上，如果没写过js，可以理解为变量声明自动被放在函数的开头，这样之后的表达式访问自然就没有问题了。 但是C语言不会，它要求被调用的函数和变量需要在表达式之前，所以我们的代码中不能把函数和变量声明放在任意地方。于是就有函数原型声明一说。 无论写什么语言，相信我们都已经养成了先声明变量再调用变量的习惯。但是函数就不一定了。在写高级语言的时候，我们习惯把程序主体函数(main)放在前边，被调用的函数放在底部。这样能够给与工程很明确的结构。 既然C语言需要将被调用的函数放在调用函数前面，那么整体代码肯定是头重脚轻的。 我们来看看正确的做法：摘录一个书本的例子《C Primer Plus》p127123456789101112131415161718192021// pound.c -- 定义一个带参数的函数#include &lt;stdio.h&gt;void pound(int n);int main(void)&#123; int times = 5; char ch = '!'; float f = 6.0f; pound(times); pound(ch); pound(f); return 0;&#125;void pound(int n)&#123; while (n-- &gt; 0) printf(\"#\"); printf(\"\\n\");&#125; 编译后运行，结果是123############################################ 在这里，函数原型声明是void pound(int n);，非常简单，对吧？仅仅一条简单的语句就能避免头重脚轻的状况。 但是我们要注意格式！ 下面我们来讨论这条语句是怎么工作的： 在ANSI C之前，C使用的是函数声明，而不是函数原型。函数声明只声明了函数名和返回值，没有指明参数类型。为了向下兼容，C现在仍然允许这样的形式1void pound(); /* ANSI C之前的函数声明 */ 我们不妨用上面的语句试一试，会得出什么结果？12###################################### 对比上面的输出结果，第三行的返回明显没有了，为什么呢？（md的空行打不出来，郁闷） 摘录自《C Primer Plus》p128 第一次函数调用，pound(times)没有问题，因为times是int类型。第二次函数调用，pound(ch)也没问题，因为即使缺少函数原型，C也会把char和short类型自动升级为int类型。第三次函数调用,pound(f)会失败，因为缺少函数原型，float会被自动升级为double，这没什么用。虽然程序仍然能运行，但是输出的内容不正确。在函数调用中显式强制类型转换，可以修复这个问题：pound((int)f); // 把f强制类型转换为正确的类型注意，如果f的值太大，超过了int类型表示的范围，这样做也不行。 如果实际参数和函数的形式参数类型不一致，编译器会自动将实际参数类型“升级”。“升级”是按照int、float、double等从左到右递增顺序，结合上面书本解析，得出的结论是函数原型声明中带有对形式参数类型的声明，能够在函数被调用之前显式改变实参类型，避免了隐式类型转换的混乱，以及输出结果的不正确。","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"/tags/C语言/"}]},{"title":"C语言数据类型上溢下溢——实验","slug":"C语言数据类型上溢下溢——实验","date":"2018-04-10T12:04:00.000Z","updated":"2018-04-10T12:32:04.321Z","comments":true,"path":"2018/04/10/C语言数据类型上溢下溢——实验/","link":"","permalink":"/2018/04/10/C语言数据类型上溢下溢——实验/","excerpt":"通过试验（即编写带有此类问题的程序）观察系统如何处理整数上溢、浮点数上溢和浮点数下溢的情况。","text":"通过试验（即编写带有此类问题的程序）观察系统如何处理整数上溢、浮点数上溢和浮点数下溢的情况。 windows 10 编写程序：12345678910111213#include&lt;stdio.h&gt;int main(void)&#123; int i=2147483647; float a=3.4e38*100.0f; float b=-0.1234e-10/10.0f; printf(\"%d %d %d\\n\",i,i+1,i+2); printf(\"%f\\n\",a); printf(\"%f\\n\",b); return 0;&#125; 得出结果：1232147483647 -2147483648 -21474836471.#INF00-0.000000 结果分析： 从整数的三个结果来看，2147483647是32位int整数所能表示最大的正整数，在此之上加一，数值会在允许的数值范围内循环递增。 float浮点数的存储方式相对复杂，从结果上看a的运算已经超出编译器所能提供位数的范围，统一变成了1.#INF00，即无穷大。 浮点数的下溢，统一变成-0.00000","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"/tags/C语言/"}]},{"title":"C语言浮点数舍入错误","slug":"C语言浮点数舍入错误","date":"2018-04-10T10:42:58.000Z","updated":"2018-04-10T10:59:32.654Z","comments":true,"path":"2018/04/10/C语言浮点数舍入错误/","link":"","permalink":"/2018/04/10/C语言浮点数舍入错误/","excerpt":"浮点数舍入错误已经是个很经典的问题了，恰好在书上看到我认为合理的解释，适当记录一下。","text":"浮点数舍入错误已经是个很经典的问题了，恰好在书上看到我认为合理的解释，适当记录一下。 浮点数舍入错误 详细可查阅《C Primer Plus (第六版) 中文版》 p59 给定一个数，加上那个1，再减去原来给定的数，结果是多少？你认为一定是1.但是，下面的浮点数给出了不同的答案。 123456789101112/* floaterr.c --演示舍入错误 */#include &lt;stdio.h&gt;int main(void)&#123; float a,b; b = 2.0e20 + 1.0; a = b - 2.0e20; printf(\"%f \\n\", a); return 0;&#125; 该程序输出如下：1230.000000 ←Linux系统下的老式gcc-13584010575872.000000 ←Trubo C 1.54008175468544.000000 ←XCode 4.5、Visual Studio 2012、当前版本的gcc 得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20是2后面有20个0.如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要存储21位数字。而float类型的数字通常只能存储按指数比例缩小或放大6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。 小结：舍入错误的根本原因可以归纳为是系统没有分配足够的空间来存储浮点数，以至于在存储过程中被逼舍掉一部分有效数值，计算结果自然是错误的。解决方案是为计算选用恰当的数据类型：一是要保证位数足够，二是在一的基础上尽可能节省内存。 (测试以上代码，如果你得出0.000000，那么你的编译器很可能是用32位表示一个浮点数。)","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"/tags/C语言/"}]},{"title":"hexo -d提交出错解决方案","slug":"hexo-d提交出错解决方案","date":"2018-04-10T07:16:59.000Z","updated":"2018-04-10T07:23:36.467Z","comments":true,"path":"2018/04/10/hexo-d提交出错解决方案/","link":"","permalink":"/2018/04/10/hexo-d提交出错解决方案/","excerpt":"hexo不用一段时间就会出各种各样新奇的问题，特别是时间紧张的这段时间出幺蛾子，真让我抓狂。记录一下。","text":"hexo不用一段时间就会出各种各样新奇的问题，特别是时间紧张的这段时间出幺蛾子，真让我抓狂。记录一下。 如往常一样，执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo d，发现到了hexo d这一步出了错误。 先贴上报错代码：123456789101112131415161718fatal: HttpRequestException encountered. ▒▒▒▒▒▒▒▒ʱ▒▒▒▒bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'https://github.com': No errorFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/do cs/troubleshooting.htmlError: fatal: HttpRequestException encountered. ��������ʱ����bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'https://github.com': No error at ChildProcess.&lt;anonymous&gt; (h:\\blog\\node_modules\\_hexo-util@0.6.1@hexo-util \\lib\\spawn.js:37:17) at emitTwo (events.js:125:13) at ChildProcess.emit (events.js:213:7) at ChildProcess.cp.emit (h:\\blog\\node_modules\\_cross-spawn@4.0.2@cross-spawn \\lib\\enoent.js:40:29) at maybeClose (internal/child_process.js:927:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:211:5) 解决方案是：修改配置文件：根目录下的_config.yml，修改deploy节点。 原来的配置为1234567deploy: type: git repo: https://github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git branch: master 修改为如下：1234567deploy: type: git repo: https://&#123;yourname&#125;:&#123;yourpassword&#125;@github.com/&#123;yourname&#125;/&#123;yourname&#125;.github.io.git branch: master 完成！ 传送门： 有关使用 Hexo 和 GitHub 搭建博客，出现 hexo -d 报错如何解决？","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"}]},{"title":"C语言中%s和%c的区别","slug":"C语言中-s和-c的区别","date":"2018-04-10T04:29:28.000Z","updated":"2018-04-10T06:48:50.461Z","comments":true,"path":"2018/04/10/C语言中-s和-c的区别/","link":"","permalink":"/2018/04/10/C语言中-s和-c的区别/","excerpt":"写习惯了Javascript，发现C语言下除了%s还有%c。一开始不了解%c的功能，在编写一些初级C程序会频繁报错。下面我记录一下关于%c的作用。","text":"写习惯了Javascript，发现C语言下除了%s还有%c。一开始不了解%c的功能，在编写一些初级C程序会频繁报错。下面我记录一下关于%c的作用。 %c%c格式对应的是单个字符。 所以在输入多个字符的时候，它只会读取第一个字符，之后的字符是无法读入完成任务的，那么也就是说，只进行一次读取工作的C函数表达方式。 参考下列例子：12345678910#include &lt;stdio.h&gt;int main(void)&#123; char c; c = 'c'; printf(\"The character is %c\", c); return 0;&#125; %s%S格式对应的是字符串。 S通常表示复数，也是多个的意思，那么在字符中表示字符串。 参考下列例子：123456789#include &lt;stdio.h&gt;int main(void)&#123; char s[12] = \"string\"; printf(\"The whole string is %s\", s); return 0;&#125; 传送门： C语言字符串处理","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"/tags/C语言/"}]},{"title":"关于Linux日常运维","slug":"关于Linux日常运维","date":"2018-02-02T12:40:51.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2018/02/02/关于Linux日常运维/","link":"","permalink":"/2018/02/02/关于Linux日常运维/","excerpt":"对于Linux管理员来说，安装和配置好一个应用系统只是完成了万里长征的第一步，此后无休止地进行健康检测、性能优化、数据备份与恢复以及处理日常问题等才是噩梦的开始。","text":"对于Linux管理员来说，安装和配置好一个应用系统只是完成了万里长征的第一步，此后无休止地进行健康检测、性能优化、数据备份与恢复以及处理日常问题等才是噩梦的开始。 摘录自《Linux操作系统基础教程（第二版）——王良明》 第十章》 进程管理进程的状态有就绪、运行、暂停、不可中断等待、可中断等待和僵尸状态。 僵尸进程是杀不死的，消灭僵尸进程的两个方法是重启计算机或者杀死其父进程。 序号 命令 说明 1 Ps命令 查看系统的进程（UID：进程ID号，PPID：父进程ID号，UID：启动该进程的用户ID，CMD：执行的程序，NI：优先级） 2 ps axjf 显示进程树 3 ps -elf 显示进程的优先级 4 top 查看系统中的任务和资源消耗情况 5 pstree 以树状结构显示进程 6 nice -n -15 ls -R / 以优先级-15运行程序ls -R / 7 renice 调整进程的优先级，普通用户只能调整为大于自己的进程的优先级 8 renice 5 12022 把12022号进程的优先级调整为5 9 renice +4 -u daemon root 把属于用户daemon和root的所有进程的优先级调整到4 10 renice -5 -g class1 把属于组class1的所有进程的优先值调低5级，等于提高了5个优先级 11 renice -1 987 -u zsan -p 32 把987和32号进程以及属于用户zsan的全部进程的优先级调到1 12 kill -&lt;信号&gt; &lt;目标&gt; 给进程发送信号，当&lt;目标&gt;大于0时表示具体的进程号，等于0时表示与当前进程同组的所有进程，等于-1时表示所有大于1的进程，-n时表示属于组号n的全部进程（n&gt;1）。普通用户发送的信号有限制 13 kill -l 列出全部的有效信号 14 kill -9 1235 向1235号进程发KILL信号，强行杀死它 15 kill -HUP 0 向与当前进程同组的所有进程发送挂起信号 16 kill -3 -1000 向属于组1000的全部进程发送信号3 系统资源管理计算机系统的四大资源包括CPU资源、内存资源、文件系统资源和I/O设备资源。 编写过程序的人应该很清楚——内存资源的消耗量和程序代码的实行速度往往成正比，即为了节约资源，往往以牺牲代码执行速度为代价。 查看CPU使用情况 序号 命令 说明 1 uptime 查看CPU运行的时间和平均负荷 2 more /proc/cpuinfo 查看CPU的参数指标 3 sar -u ALL 10 5 以10s为周期，连续统计5次所有CPU的使用情况 4 top 查看系统中的任务和资源消耗情况（详细看后面说明） 命令top的显示结果 top命令实时显示各种资源的使用情况，按Q键可以退出。该图显示了7个方面的信息，从上往下依次如下： 当前时间和系统运行时间，图上显示已经运行了1小时34分钟。 Loader average:0.72,1.00,1.09，表示的前5、10、15min就绪队列的平均长度。 有219个进程，1个运行，165个在睡眠，停止进程数为0，僵尸进程数为0 CPU使用情况：普通用户进程消耗14.8% us，内核模式消耗3.3%，低优先级用户进程消耗0.0%，CPU空闲率为81.9%。 内存（Mem）使用情况：总内存大小为8092724KB，已经使用了2170384KB，剩余3567188KB，2355152KB用于硬盘的物理缓冲（Buffer）和硬盘的文件系统缓冲（Cache）。 交换区（Swap）使用情况：交换区总大小4194300KB，目前全是空闲的。 显示所有进程，默认是按CPU使用率由大到小排序。PR——Priority（优先级）、NI——Nice、VIRT——虚拟内存大小、RES——物理内存大小、SHR——共享内存大小、S——进程状态。 查看虚拟内存使用情况 序号 命令 说明 1 free 查询内存使用的简要信息 2 more /proc/meminfo 查看内存的参数指标 3 vmstat 20 8 以20s为周期，连续统计8次内存的动态使用情况 4 sar -rR 30 60 以30s为周期，连续统计60次内存使用情况 查看分区的使用情况 序号 命令 说明 1 fdisk -l 查看计算机中所有硬盘和USB盘的分区 2 df -T 查看已经挂载分区的使用情况 3 du -sh/etc 统计“/etc”占用磁盘的大小 4 iostat -d -x sda1 60 10 以60s为周期，连续统计10次分区“/dev/sda1”的使用情况 5 iostat -p sda 30 6 以30s为周期，连续统计6次硬盘sda上所有分区的使用情况 6 sar -rR 30 60 以30s为周期，连续统计60次内存使用情况 查看网络使用情况 序号 命令 说明 1 ping 192.168.10.100 检查与计算机192.168.10.100之间的网络是否畅通 2 traceroute www.veryopen.org 跟踪到达www.veryopen.org的网络路径 3 route 显示本机路由表 4 ifconfig 显示本机所有网卡的配置参数 5 ethtool eth0 查看eth0网卡设置 6 netstat -tlnp 查看被监听的TCP端口 7 netstat -unlp 查看被监听的UDP端口 8 sar -n DEV 30 100 统计全部网卡的流量（以30s为周期统计100次） 9 sar -n EDEV 50 70 统计全部网卡的出错流量（以50s为周期统计70次） 定时任务Linux系统中，定时任务分为两类，第一类是周期性任务（执行多次），另一类是一次性任务（执行一次）。 周期性定时任务采用命令crontab -e进入编辑定时任务界面，每一行代表一个定时任务。格式是： 分钟 小时 日期 月份 星期 调度的作业（命令） 序号 定时任务 说明 1 10 4 * /bin/databasebackup.bash 每一天的4:10执行/bin/databasebackup.bash 2 0 4 /2 * /usr/sbin/slapcat 每隔一天的4点钟执行命令 3 0 22 * 5,8,11 1-5 wall “It’s 10pm” 5月、8月和11月的工作日晚上10点向所有的登录用户发消息 4 5 4 tue /bin/echo “Sunday” 每个周二的4:05执行命令 5 0 23,1-7/2,8 * /usr/sbin/ntpdate 每天晚上11点到第二天早上7点之间每隔两小时以及早上8点执行时间同步命令 一次性定时任务采用命令at和batch可以安排一次性任务，at是定时任务，batch是条件任务，即满足某种条件（例如平均负荷很低）时执行命令。一次性任务中的命令一执行完毕（不管成功与否），对应的任务就自动消失。 序号 定时任务 说明 1 at [-f file] time 在time时点执行file文件中的命令，如果没有指定file文件，那么从标准输入设备读取命令 2 at 22:00 &lt;&lt;&lt;”shutdown -h now” 今晚晚上10点关闭系统，如果现在已经过了10点，那么次日晚上10点关机 3 at now+10 minutes &lt;&lt;&lt;”wall notice.txt” 再过10min广播文件notice.txt的内容 4 at -l 列出全部的一次性定时任务 5 at -r 6 删除6号定时任务 6 … 详细看p124","categories":[{"name":"工具","slug":"工具","permalink":"/categories/工具/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"OpenSSH远程控制服务器","slug":"OpenSSH远程控制服务器","date":"2018-02-01T12:39:03.000Z","updated":"2018-04-10T03:45:06.000Z","comments":true,"path":"2018/02/01/OpenSSH远程控制服务器/","link":"","permalink":"/2018/02/01/OpenSSH远程控制服务器/","excerpt":"以前连接Linux都是用蠢方法（点阿里云的远程连接按钮），尝试OpenSSH之后，把玩服务器又是另一个故事了。","text":"以前连接Linux都是用蠢方法（点阿里云的远程连接按钮），尝试OpenSSH之后，把玩服务器又是另一个故事了。 server: Ubuntu 14.04 ;Local Os: deepin 15.4.1 SSH服务器的配置OpenSSH在服务器的配置非常简单。 对于红帽阵营，使用下面的命令安装1yum install openssh-server 对于Ubuntu阵营，采用下面的命令安装1apt-get install openssh-server 我使用的是阿里云服务器，里面的SSH一开始就是开启的。 一般使用默认配置即可，你也可以修改/etc/ssh/sshd.config配置OpenSSH服务器。 为了加快登录速度，可以增加配置项UseDNS no，即关闭登录时反向解析IP。 SSH默认端口为22，为了安全性，你可以将端口修改为Port7209。 一旦配置项被修改了，需要重启服务：12/etc/init.d/ssh reload # Ubuntusystemctl reload sshd.service # 红帽7.0 此时可以使用命令netstat -tnlp查看全部被监听的TCP端口，如：123vinson@vinson-PC:~$ netstat -tnlptcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN -tcp6 0 0 :::22 :::* LISTEN - SSH客户端Linux系统直接用SSH命令即可。 安装客户端：1$ sudo apt-get install openssh-client 同样，deepin上自带，无需安装。 在终端输入以下命令即可远程连接（亲测）：1ssh -p 7209 root@xxx.xxx.xxx.xxx 此时需要密码，按步骤操作即可。 如果遇到提示The authenticity of host &#39;hostname&#39; can&#39;t be established，可以按照这里操作。 Windows登录工具有putty.exe、SecureCRT、SSH Secure Shell Clien，都是字符界面登录工具。","categories":[{"name":"工具","slug":"工具","permalink":"/categories/工具/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"vi/vim介绍","slug":"vi-vim介绍","date":"2018-02-01T09:03:52.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2018/02/01/vi-vim介绍/","link":"","permalink":"/2018/02/01/vi-vim介绍/","excerpt":"vim用得少，一般都是用gedit小改文本。记录一下vi/vim使用方法。","text":"vim用得少，一般都是用gedit小改文本。记录一下vi/vim使用方法。 vim介绍 vim由荷兰的布莱姆-米勒开发，遵循GPL开源协议，其中还有一些条款建议使用者向荷兰ICCF捐款，以帮助乌干达的艾滋病患者，尤其是那些儿童艾滋病患者。后来布莱姆-米勒加盟Google公司。——《Linux操作系统基础教程》 vim的功能非常强大，几乎能够编辑当前所有文件，可以不用鼠标，只用命令。 直接输入vim，可以查看版本号、作者姓名等信息。 输入:q可以突出vim编辑界面。 vim的三种模式vim的三种模式是指插入模式、命令模式、底行模式。 命令模式命令模式可以理解为插入模式和底行模式的中介。 打开vim就会直接进入命令模式。 在插入模式下按下Esc，可以返回命令模式。 清空底行模式的字符就会自动返回命令模式。 下面是命令模式下光标移动的快捷键： 序号 命令 说明 1 h,j,k,l 上、下、左、右移动光标。当然采用光标键也可以，但建议不采用光标键 2 Ctrl+F 上翻页 3 Ctrl+B 下翻页 4 % 跳到匹配的括号处，如光标目前在“{”处，按%后跳到对应的“}”处 5 ^ 跳到行首 6 $ 跳到行尾 7 gg 跳到文件第一行 8 [n]G 跳到第n行或者文件末尾（省略[n]时） 9 ‘’ (连续两个单引号)跳到上一个位置 10 m&lt;标签&gt; 在光标所在行定义一个标签，标签那只能是一个字母，如ma定义的标签a 11 ‘&lt;标签&gt; 光标跳到&lt;标签&gt;处。如’b跳到之前已经定义的标签b处 替换和查找： 序号 命令 说明 1 /wlm 往前查找wlm，伺候按N继续查找下一个（如果文件中包含多个wlm)，如果找到文件末尾还继续按N，则又从头开始找 2 ?key12 往后查找key12，按N继续差早下一个（如果文件中包含多个key12) 3 :g/old1/s//new3/g 文件中所有的old1替换成new3 4 :g/old/s//news/gc 类似上面第三条命令，但替换前先确认 5 :10,40g/abc/s//1234/g 10~40行之间的abc替换成1234 插入模式在命令模式下输入a，A，i，I，o，O中的任意一个字符就会进入插入模式。 序号 命令 说明 1 i 在当前位置（光标所在的位置）前插入 2 I 在光标所在的行首插入 3 a 在当前位置（光标所在的位置）后插入 4 A 在光标所在的行尾插入 5 o 在当前行下方插入一空行。同时进入插入模式 6 O 在当前行上方插入一空行，同时进入插入模式 7 C 先删除到行尾的全部字符，然后进入插入模式 底行模式底行模式是用来输入命令的。在命令模式下按:（冒号）键进入底行模式。 常用命令有： 序号 命令 说明 1 w 存盘 2 x 存盘并退出vim 3 q 不存盘退出 4 wq 存盘并退出vim 5 q! 强制退出 6 w newfile.txt 另存为newfile.txt 省略部分命令，详细见《Linux操作系统基础教程（第二版）》 vim配置文件如果存在~/.vimrc文件，vim在启动的时候都会先执行这个文件中的命令。 例如我的~/.vimrc的内容如下：12345678set autoindentsyntax enableset nuset nowrapset ts=4set hlsearchset rulerset showcmd","categories":[{"name":"工具","slug":"工具","permalink":"/categories/工具/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"Linux常用命令杂烩","slug":"Linux常用命令杂烩","date":"2018-01-31T11:47:43.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2018/01/31/Linux常用命令杂烩/","link":"","permalink":"/2018/01/31/Linux常用命令杂烩/","excerpt":"最近看了一些有关Linux的书籍，记录一下一些常用的命令或者快捷键，方便自己查阅。","text":"最近看了一些有关Linux的书籍，记录一下一些常用的命令或者快捷键，方便自己查阅。 摘录自《Linux操作系统基础教程（第二版）》——王良明 编著 bash快捷键《基础教程（二）》p65 命令行其实就是行编辑器——在这里编辑即将要执行的命令。在这个小小的编辑器里（只有一行），bash提供了许多快捷键，掌握最常用的几个快捷键并灵活运用，能带来意想不到的高效便利。 序号 快捷键 说明 1 Ctrl+A 光标跳到行首 2 Ctrl+E 光标跳到行尾 3 Ctrl+U 删除从光标位置到行首的所有字符 4 Ctrl+K 删除从光标位置道行尾的所有字符 5 Ctrl+W 删除光标左侧的一个单词 6 Ctrl+L 清屏 常用通用命令 序号 命令 说明 1 help 列出所有内部命令 2 help alias 取得内部命令alias的帮助信息 3 man 5 passwd 获取passwd命令的帮助信息（默认在1号节中找） 文件权限管理《基础教程（二）》p57 序号 命令 说明 1 chmod 644 file 修改文件file的权限为rw-r–r– 2 chmod -R 755 ./abc 把目录abc及其子目录下的所有文件的权限改成755 3 chown zsan file 修改file的主人为用户zsan 4 chgrp class2 file 修改file的组群为class2 列文件和解压包《基础教程（二）》p59 序号 命令 说明 1 ls 以列方式列出当前目录下的文件和目录 2 ls -l 以行方式列出当前目录下的文件的详细信息 3 ls -la 意义同上，但隐藏文件也显示出来 4 ls -lt 按文件修改时间排序显示 5 ls -lS 按文件大小排序显示 6 ls -lh 文件大小转换为人们易读的方式显示 7 ls -R 递归显示下层目录中的内容 8 tar -cvf abc.tar ./123 打包“/123”目录为abc.tar 9 tar -xvf abc.tar 解压到当前目录下 9 tar -tvf abc.tar 显示包中的文件 10 tar -czf file.tar.gz ./123 压缩（gzip压缩格式) 11 tar -xzf file.tar.gz 解压 12 tar -cjf file.tar.bz2 ./123 压缩（bzip2压缩格式） 13 tar -xjf file.tar.bz2 解压 关机/重启/退出《基础教程（二）》p69 序号 命令 说明 1 shutdown -h now 立即关机 2 shutdown -h +10 “请各位退出” 10分钟后关机，同时广播通告 3 shutdown -r 16:30 在16:30重启计算机 4 shutdown -h 23:59 在23:59关机 5 reboot 立即重启电脑 6 halt 立即关机（比较粗暴），另一个命令是poweroff 7 exit 退出登录（注销） 8 sync 把磁盘I/O高速缓存中的内容同步到磁盘 9 systemctl hibernate 进入睡眠 10 systemctl rescue 系统进入急救模式 bash内部命令 序号 命令 说明 1 history、history -c、history -w 显示历史命令、清除历史命令、把命令缓冲区中的命令输出道HISTFILE定义的文件中 2 alias、alias l=’ls -la’、alias woman=man 显示全部的命令别名、定义命令别名l、定义命令别名woman。此后，执行命令l实际上就是执行“ls -la” 3 unalias woman 删除别名woman 4 which ls 显示命令ls所在的目录 5 echo “I love you” 在屏幕上显示信息 6 export ABC=”Hello World” 定义用户环境变量ABC，值是“Hello World” 7 env 显示所有用户的环境变量 8 unset CBA 删除Shell变量CBA 9 source ~/.bashrc或者.~/.bashrc 执行“~/.bashrc”并输出里面定义的环境变量 10 pwd 显示用户所在的当前目录 系统信息相关命令 序号 命令 说明 1 date +”%Y-%m-%d %H:%M” 按格式显示系统时间，如2014-06-23 16:29 2 date 072316312014 设置系统时间，格式是[MMDDhhmm[[CC]YY][.ss]] 3 cal、cal -y 显示本月日历、显示本年日历 4 clear 清屏（相当于快捷键Ctrl+L） 5 bc 高精度计算机。输入quit退出bc 6 Ubuntu系统：service sshd restart 红帽7.0：systemctl restart sshd.service 重启sshd服务，Ubuntu系统中所有的服务脚本在/etc/init.d/目录下，其他动作还有stop——停止服务、start——启动服务、status——查看服务状态、reload——使服务重读配置文件 7 systemctl -t service 显示全部的服务（红帽7.0特有的命令） 8 sysv-rc-conf –list 显示全部的服务（Ubuntu特有的命令） 9 update-rc.d ssh defaults 在2,3,4,5运行级别启动服务ssh，在0,1,6关闭服务ssh（Ubuntu阵营） 10 uptime 简要显示系统的连续运行时间、当前用户数和负荷 11 uname -a 显示操作系统的信息 12 df -T 显示已挂载分区的使用情况 13 du -sh /etc/ 查看目录/etc占用磁盘的大小 14 dmesg 显示系统启动日志 文件操作命令 序号 命令 说明 1 tree /etc/ 显示/etc的目录树 2 touch abc1 如果abc1事先存在，就把它的修改时间改为现在的系统时间，如果不存在就创建一个空文件 3 find /etc/ -name sshd* 在/etc/及其子目录中查找以sshd开头的文件 4 find /etc -mmin 10 递归查找/etc及其子目录中最近十分钟中内修改过的文件 5 ls / &#124; tee /tmp/abc.txt tee建立二通，一方面输出到屏幕，一方面输出到文件/tem/abc.txt/ 6 diff file1 file2 显示两个文件的差异 7 du -sh /etc/ 查看目录/etc占用磁盘的大小 8 split -b 4M bigfile.dat part- 把文件bigfile.dat切割成4M大小的以part-为前缀的文件，如part-aa、part-ab等。合并文件可以采用命令cat：cat part-aa&gt;bigfile1.dat &amp;&amp; catpart-ab&gt;&gt;bigfile1.dat .. 9 grep “UsePam yes” * 在当前目录下的所有文件中查找包含UsePam yes的行 10 grep -R wlm /etc/ * 递归查找/etc/中以及子目录中的所有文件，把包含wlm的行显示出来 11 dd if=/dev/zero of=1.bat bs=512 count=1024 从设备/dev/zero读取0并写入到文件1.dat中，每一次读取512个字节，共读取1024次，因此1.dat的大小是0.5MB，即512×1024 12 dd if=/dev/sda of=/boot/mainboot bs=512 count=1 把文件/boot/mainboot文件中，共512个字节 13 od -t x1 mainboot 以十六进制显示文件mainboot的内容(x1的1是数字！) 14 xxd 2.dat &gt;2.txt ，xxd -r 2.txt &gt;2.dat 把二进制文件2.dat转换为十六进制字符文件2.txt，第二个命令做相反操作 15 sed -i ‘s&#124;oldw&#124;new12&#124;g’ file1.txt 把文件file1.txt中的所有oldw替换成new12 16 gzip 2.dat 压缩2.dat，压缩后的文件名为2.dat.gz 17 gzip -d 2.dat.gz 解压 18 bzip2 file2.dat 压缩file2.dat，压缩后的文件名是file2.dat.bz2。对于大文件，bzip2的压缩效率要高于gzip 19 bzip2 -d file2.dat.bz2 解压 20 strings /bin/ls 显示二进制文件/bin/ls里的可见字符 进程及任务管理相关命令 序号 命令 说明 1 ps -ef 显示当前系统中的进程。第二列是进程号，最后一列是该进程执行的二进制程序 2 kill -9 7208 立即杀死进程号为7208的进程。本质上是向进程7208发送信号9，这是马上结束进程的信号，其他的信号可用命令kill-l查看 3 pkill -9-u osadmin 立即杀死用户osadmin的全部进程，用户被动退出系统 4 killall -9 sendmail 杀死由程序sendmail产生的全部进程 5 jobs 显示后台任务，第一列是任务号 6 fg 、 fg 2 把最靠前的任务切换到前台、把2号任务切换到前台 7 Ctrl+Z 把正在执行的前台任务切换到后台，并暂停运行。例如正在用vim编辑一个文件，这时可以按Ctrl+Z把vim切到后台，然后执行fg又可切回到前台 8 bg 、 bg 3 继续在后台执行最靠前的那个暂停的后台任务，继续在后台执行3号任务。 9 nohup command1 &amp; 在后台执行command1命令，且脱离用户登录的终端，这样即使用户登出，命令也不会退出。 网络相关命令 序号 命令 说明 1 netstat -tnlp 显示处于监听状态的TCP端口 2 netstat -unlp 显示处于监听状态的UDP端口 3 ifconfig 显示网卡参数。红帽7.0还可以使用命令nmcli dev查看全部网络设备 4 ethtool eth0 查看第一块网卡的链路状态，例如是否链接交换机。注意：红帽7.0的网卡命名为ensx 5 ifconfig eth1 add 192.168.0.10 up 配置第二块网卡地址为192.168.0.10，并启动它 6 ifup eth0、ifdown eth1 启动第一块网卡、禁用第二块网卡 7 ping 192.168.1.100、ping www.baidu.com 向另一台计算机发ICMP包来检测网络是否连通。 8 route 显示路由表 9 route add -net 192.168.10.0 netmask 255.255.255.0 gw 10.2.65.1 增加一条到达192.168.10.0网段的路由，网关是10.2.65.1 10 traceroute www.veryopen.org 跟踪到达www.veryopen.org的路由路径","categories":[{"name":"工具","slug":"工具","permalink":"/categories/工具/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"}]},{"title":"PM2使用入门指南（转）","slug":"PM2使用入门指南（转）","date":"2018-01-24T09:27:07.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2018/01/24/PM2使用入门指南（转）/","link":"","permalink":"/2018/01/24/PM2使用入门指南（转）/","excerpt":"PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。下面就对PM2进行入门性的介绍，基本涵盖了PM2的常用的功能和配置。","text":"PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。下面就对PM2进行入门性的介绍，基本涵盖了PM2的常用的功能和配置。 先贴上原贴PM2实用入门指南 安装全局安装，简直不能更简单。1npm install -g pm2 目录介绍pm2安装好后，会自动创建下面目录。看文件名基本就知道干嘛的了，就不翻译了。 $HOME/.pm2will contain all PM2 related files $HOME/.pm2/logswill contain all applications logs $HOME/.pm2/pidswill contain all applications pids $HOME/.pm2/pm2.logPM2 logs $HOME/.pm2/pm2.pid PM2 pid $HOME/.pm2/rpc.sockSocket file for remote commands $HOME/.pm2/pub.sockSocket file for publishable events $HOME/.pm2/conf.jsPM2 Configuration 入门教程挑我们最爱的express应用来举例。一般我们都是通过npm start启动应用，其实就是调用node ./bin/www。那么，换成pm2就是 注意，这里用了--watch参数，意味着当你的express应用代码发生变化时，pm2会帮你重启服务，多贴心。1pm2 start ./bin/www --watch 入门太简单了，没什么好讲的。直接上官方文档：http://pm2.keymetrics.io/docs/usage/quick-start 常用命令启动 参数说明： --watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。 -i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。 --ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot; -n --name：应用的名称。查看应用信息的时候可以用到。 -o --output &lt;path&gt;：标准输出日志文件的路径。 -e --error &lt;path&gt;：错误输出日志文件的路径。 --interpreter &lt;interpreter&gt;will contain all PM2 related files完整命令行参数列表：地址1pm2 start app.js --watch -i 2 重启1pm2 restart app.js 停止停止特定的应用。可以先通过pm2 list获取应用的名字（–name指定的）或者进程id。1pm2 stop app_name|app_id 如果要停止所有应用，可以1pm2 stop all 删除类似pm2 stop，如下12pm2 stop app_name|app_idpm2 stop all 查看进程状态1pm2 list 查看某个进程的信息123456789101112131415161718192021[root@iZ94wb7tioqZ pids]# pm2 describe 0Describing process with id 0 - name oc-server┌───────────────────┬──────────────────────────────────────────────────────────────┐│ status │ online ││ name │ oc-server ││ id │ 0 ││ path │ /data/file/qiquan/over_the_counter/server/bin/www ││ args │ ││ exec cwd │ /data/file/qiquan/over_the_counter/server ││ error log path │ /data/file/qiquan/over_the_counter/server/logs/app-err-0.log ││ out log path │ /data/file/qiquan/over_the_counter/server/logs/app-out-0.log ││ pid path │ /root/.pm2/pids/oc-server-0.pid ││ mode │ fork_mode ││ node v8 arguments │ ││ watch &amp; reload │ ││ interpreter │ node ││ restarts │ 293 ││ unstable restarts │ 0 ││ uptime │ 87m ││ created at │ 2016-08-26T08:13:43.705Z │└───────────────────┴──────────────────────────────────────────────────────────────┘ 配置文件简单说明 配置文件里的设置项，跟命令行参数基本是一一对应的。 可以选择yaml或者json文件，就看个人洗好了。 json格式的配置文件，pm2当作普通的js文件来处理，所以可以在里面添加注释或者编写代码，这对于动态调整配置很有好处。 如果启动的时候指定了配置文件，那么命令行参数会被忽略。（个别参数除外，比如–env）例子举个简单例子，完整配置说明请参考官方文档。12345678910111213141516171819202122&#123; \"name\" : \"fis-receiver\", // 应用名称 \"script\" : \"./bin/www\", // 实际启动脚本 \"cwd\" : \"./\", // 当前工作路径 \"watch\": [ // 监控变化的目录，一旦变化，自动重启 \"bin\", \"routers\" ], \"ignore_watch\" : [ // 从监控目录中排除 \"node_modules\", \"logs\", \"public\" ], \"watch_options\": &#123; \"followSymlinks\": false &#125;, \"error_file\" : \"./logs/app-err.log\", // 错误日志路径 \"out_file\" : \"./logs/app-out.log\", // 普通日志路径 \"env\": &#123; \"NODE_ENV\": \"production\" // 环境参数，当前指定为生产环境 &#125;&#125; 重新启动前面已经提到了，这里贴命令行，更多点击这里。1pm2 start app.js --watch 这里是监控整个项目的文件，如果只想监听指定文件和目录，建议通过配置文件的watch、ignore_watch字段来设置。 环境切换在实际项目开发中，我们的应用经常需要在多个环境下部署，比如开发环境、测试环境、生产环境等。在不同环境下，有时候配置项会有差异，比如链接的数据库地址不同等。 对于这种场景，pm2也是可以很好支持的。首先通过在配置文件中通过env_xx来声明不同环境的配置，然后在启动应用时，通过--env参数指定运行的环境。 环境配置声明首先，在配置文件中，通过env选项声明多个环境配置。简单说明下： env为默认的环境配置（生产环境），env_dev、env_test则分别是开发、测试环境。可以看到，不同环境下的NODE_ENV、REMOTE_ADDR字段的值是不同的。 在应用中，可以通过process.env.REMOTE_ADDR等来读取配置中生命的变量。123456789101112\"env\": &#123; \"NODE_ENV\": \"production\", \"REMOTE_ADDR\": \"http://www.example.com/\"&#125;,\"env_dev\": &#123; \"NODE_ENV\": \"development\", \"REMOTE_ADDR\": \"http://wdev.example.com/\"&#125;,\"env_test\": &#123; \"NODE_ENV\": \"test\", \"REMOTE_ADDR\": \"http://wtest.example.com/\"&#125; 启动指明环境假设通过下面启动脚本（开发环境），那么，此时process.env.REMOTE_ADDR的值就是相应的http://wdev.example.com/，可以自己试验下。1pm2 start app.js --env dev 负载均衡命令如下，表示开启三个进程。如果-i 0，则会根据机器当前核数自动开启尽可能多的进程。12pm2 start app.js -i 3 # 开启三个进程pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程 参考文档：点击查看 日志查看除了可以打开日志文件查看日志外，还可以通过pm2 logs来查看实时日志。这点对于线上问题排查非常重要。 比如某个node服务突然异常重启了，那么可以通过pm2提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。1pm2 logs 其他省略。","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"nodejs","slug":"nodejs","permalink":"/tags/nodejs/"}]},{"title":"webpack和express开发部署","slug":"webpack和express开发部署","date":"2018-01-19T04:47:57.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2018/01/19/webpack和express开发部署/","link":"","permalink":"/2018/01/19/webpack和express开发部署/","excerpt":"花了好多天时间研究webpack，但是网上的webpack的教程大多数都很老了，大概是因为webpack3和其他版本配置文件写法不一样。webpack是一个非常机智的打包机，能够将html文件引用的图像、js、css文件等打包成你需要的文件，避免了客户端对文件的大量请求，提高性能。此外，webpack结合express、vue等，能够提供一套相对完善的开发模式。","text":"花了好多天时间研究webpack，但是网上的webpack的教程大多数都很老了，大概是因为webpack3和其他版本配置文件写法不一样。webpack是一个非常机智的打包机，能够将html文件引用的图像、js、css文件等打包成你需要的文件，避免了客户端对文件的大量请求，提高性能。此外，webpack结合express、vue等，能够提供一套相对完善的开发模式。 webpack 3.10.0 这篇博客是针对webpack+express的多页面开发。很多人以为webpack是用于SPA（单页面应用）开发，事实上多页面也是webpack的功能之一，只是对webpack的配置会更加复杂些。如果懂多页面开发配置，那单页面不so easy? 本文章假设你已经对webpack和express有一定的熟悉程度，另外推荐几篇文章： 入门Webpack，看这篇就够了 webpack+express多页站点开发 webpack 中文文档(v3.5.5) webpack-hot-middleware 插件的使用 配合着github源码食用更佳https://github.com/Vinson-sheep/Webpack-MPA-example github的源代码中包含必要的备注，可以方便理解各种配置的作用。 大概步骤可以分为： express的部署 重构项目目录 webpack的部署 supervisor的部署 1. express的部署123456789101112// 应用生成器$ cnpm install express-generator -g// 在适当地方执行，会生成应用目录$ express Webpack_MPA// 进入应用目录$ cd Webpack_MPA// 安装各种依赖$ cnpm install// Linux或者MacOS$ DEBUG=myapp npm start// 打开http://localhost:3000/// 测试安装是否成功 express官方文档 2. 重构项目目录保持共有文件的内容不变，重构项目目录： 项目结构 bin是express生成器的启动文件价，/bin/www是启动文件。routes是路由文件价。src是网站资源文件夹，修改的代码都在这个文件夹里面。static是webpack输出文件夹，同时是express的静态文件存放处。views存放webpack输出的视图文件，如.html。app.js是项目的入口文件，但实际启动的是bin/www。webpack.config.js是webpack的配置文件。 3. webpack的部署webpack的部署，其实就是webpack.config.js的配置。 1. 基本组件包的安装 本地安装webpack,webpack-dev-server,webpack-dev-middleware、webpack-hot-middleware 本地安装加载器loader。可能用到的加载器包有：style-loader、css-loader、css、less、less-loader、scss-loader、html-loader、file-loader、url-loader、raw-loader、babel-core、babel-loader、babel-plugin-transform-runtime、babel-preset-env、css-hot-loader、babel-runtime 安装插件plugin：extract-text-webpack-plugin、html-webpack-plugin 另外还有一些其他的资源包：cross-dev 2. 编写代码(演示用)编写一些用来演示的html、css、js文件，存放在src中。详细看https://github.com/Vinson-sheep/Webpack-MPA-example。 3.webpack配置关于webpack.config.js的配置，我建议大家去看文章头部所推荐的文章，相信看完之后你们一定能够对webpack.config.js的基本写法有一定认识。在此我只解释源码中功能实现的关键语句： css/js文件的热更新webpack能够通过入口文件，如src/js/entry/index1_entry.js，对其他的文件的依赖来进行打包。如果项目中除去express而使用webpack插件webpack-dev-server，修改入口文件所依赖的文件直接能够在localhost:8080得到实时反应，而不需要手动刷新浏览器窗口。 值得一提的是，使用了extract-text-webpack-plugin进行打包的css/less文件，不会被镶嵌在js文件中，而是独立打包输出成一个css文件，这是这个插件的功能。通过这种方式打包的css文件，所依赖的css/less不能够热更新。为了解决这个问题，需要引入css-hot-loader。webpack配置文件需要相应修改：123456789101112// 不使用css-hot-loadertest: /\\.(css|less)$/,use: ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: ['css-loader', 'less-loader']&#125;)// 使用css-hot-loadertest: /\\.(css|less)$/,use: ['css-hot-loader'].concat(ExtractTextPlugin.extract(&#123; fallback: 'style-loader', use: ['css-loader', 'less-loader']&#125;)) html的热更新和模块化html的热更新：由于webpack的热更新需要有对文件的依赖，所以html文件需要被入口文件所引用：1234// index2_entry.jsif (process.env.NODE_ENV !== 'production') &#123; require('../../template/index2.html');&#125; 同时引入html-loader12345678// webpack.config.jstest: /\\.html$/,use: &#123; loader: \"html-loader\", options: &#123; attrs: [':src'] &#125;&#125; html的模块化：css文件能够通过import url(xxx.css)引入css文件，实现模块化。那么html呢？大家都知道，html中并不能直接引用html文件，所以html自身是不能分模块的。这里有一种简单的方法，那就是js镶嵌。 index1_entry入口文件中有一段代码：12345(function()&#123; var tpl = require('../../template/components/template.html'); var app = document.getElementById('tpl'); app.innerHTML = tpl;&#125;)(); 这一段代码的作用是通过闭包方式实现对html模板内容的获取，并放入到主html文件的指定内容中。代码简单易懂，不做解释。 对于某些人来说，这种方法是十分丑陋而不优雅。但是通过闭包的方式，既没有污染全局变量，又能够简单实现html模块化，而且template.html的修改也支持热更新，不亦乐乎？ express的热更新配置express和webpack结合，需要有两个中间件：webpack-dev-middleware和webpack-hot-middleware。 webpack-dev-middleware能够实时监控依赖的文件并重新打包，但是打包的文件并不会存入磁盘，而是保存在内存里，这一点很重要。你会发现npm start后并没有生成文件，但是localhost:3000依然能够读取相应文件，这是因为文件被储存在内存中。 webpack-hot-middleware能够让你的浏览器自动更新。一般修改源css文件，浏览器能够在不刷新页面的情况下改变样式，如果失败，则刷新页面。 关于这两个中间件的详细内容，我推荐一下文章： webpack-hot-middleware 插件的使用 手动读取内存文件获取静态文件能够优先读取内存中的数据，但是node自带的fs.readFile并不能够，当然sendFile也不行。因为文件的读取有两个操作：先在本地磁盘访问文件，再从文件中获取数据。访问文件是必须操作，如果文件不存在于磁盘，则程序报错。既然绕不开读取磁盘的操作，那我们应该用什么方法读取内存文件呢？ webpack提供webpackCompiled.outputFileSystem方法。 app.js完整的代码应该是这样的：1234567891011121314151617181920212223242526272829303132333435363738if (process.env.NODE_ENV !== 'production') &#123; // development config var webpack = require('webpack'); var webpackDevMiddleware = require('webpack-dev-middleware'); var webpackHotMiddleware = require('webpack-hot-middleware'); // 获取webpack配置文件 var webpackConfig = require('./webpack.config.js'); // 调用配置文件内容 var webpackCompiled = webpack(webpackConfig); // 此处devMiddleware的定义非常重要 // 它类似于一个中间件，修饰了webpackCompiled // 只有通过这步的定义才能够使用webpackCompiled.outputFileSystem.readFile函数 // 详细可以看路由文件 var devMiddleware = webpackDevMiddleware(webpackCompiled, &#123; publicPath: webpackConfig.output.publicPath, quiet: true //向控制台显示任何内容 &#125;); // 热更新配置 var hotMiddleware = webpackHotMiddleware(webpackCompiled,&#123; log: false, heartbeat: 2000 &#125;); app.use(devMiddleware); app.use(hotMiddleware); var filename = path.join(__dirname, '../views', 'index1.html'); require('./routes/index')(app); webpackCompiled.outputFileSystem.readFile(filename, function(err, result) &#123; if (err) &#123; // something error return next(err); &#125; res.set('content-type', 'text/html'); res.send(result); res.end(); &#125;);&#125; 但是这一堆代码放在app.js一个文件中不太方便，考虑着把一部分代码放在路由文件。然而这里是个大坑！！！ 如果在路由文件page1_route.js中简单写入：123456789101112var webpack = require('webpack');var webpackConfig = require('../webpack.config.js');var webpackCompiled = webpack(webpackConfig);webpackCompiled.outputFileSystem.readFile(filename, function(err, result) &#123; if (err) &#123; // something error return next(err); &#125; res.set('content-type', 'text/html'); res.send(result); res.end();&#125;); 执行npm start，会报错outputFileSystem.readFile is not a function.。通过增删代码多番折腾之后，发现以下代码能够对webpackCompiled进行修饰。1234var devMiddleware = webpackDevMiddleware(webpackCompiled, &#123; publicPath: webpackConfig.output.publicPath, quiet: true //向控制台显示任何内容&#125;); 如果不添加上面代码，console.log(webpackCompiled)的结果是不一样的，后者会多了一些东西。见鬼了。。。。 那么我们添加以上代码之后再npm start。依然报错！ 怎么回事呢？尝试输出在app.js和page1_route.js分别输出filename，表现一致。这表示文件访问的路径没有问题，但是函数依然不能访问当相应内存中的文件。 同样是很艰辛的试验，只得出了可能的原因是：webpack.config.js配置与执行这段代码所在的文件之间的相对路径问题。 在这里有一张不优雅而且有副作用的做法：123456789101112// app.jsglobal.webpackCompiled = webpackCompiled;// page1_route.jsglobal.webpackCompiled.outputFileSystem.readFile(filename, function(err, result) &#123; if (err) &#123; // something error return next(err); &#125; res.set('content-type', 'text/html'); res.send(result); res.end();&#125;); 以上代码将app.js的webpackCompiled绑定在全局变量global的属性中，这时候在其他文件就能够直接读取global.webpackCompiled获取这个对象。再调用这个对象的outputFileSystem方法读取内存文件，就能够在浏览器中呈现内存文件了。 这样做的副作用是：污染了全局global。如果你不放心，那将global.webpackCompiled的属性值webpackCompiled改为更加复杂的名称，避免被其他人访问或者更改。 4. supervisor的配置在编写app.js入口文件时，我们会怎么做呢？先编写一段代码，然后打开终端，输入npm start，看看有没有错误，再关掉。为了能够解放对终端的操作，supervisor实现对文件修改的监控和自动重启服务的功能。 全局安装supervisor1$ npm install supervisor -g 打开package.json，添加以下脚本：123\"scripts\": &#123; \"start\": \"cross-env NODE_ENV=dev supervisor -w routes,app.js ./bin/www\",&#125; cross-env NODE_ENV=dev是设置环境变量，与node中process.env.NODE_ENV值保持一致。这里是指设置环境变量为开发环境，process.env.NODE_ENV的值相应变成dev。 -w是监控文件或文件夹，如果有变动则重启服务。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"原创","slug":"原创","permalink":"/tags/原创/"},{"name":"express","slug":"express","permalink":"/tags/express/"},{"name":"webpack","slug":"webpack","permalink":"/tags/webpack/"}]},{"title":"webstorm支持nodejs","slug":"webstorm支持nodejs","date":"2018-01-17T11:46:36.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2018/01/17/webstorm支持nodejs/","link":"","permalink":"/2018/01/17/webstorm支持nodejs/","excerpt":"又到了写node的季节……","text":"又到了写node的季节…… 1.配置支持nodejs配置nodejs支持，博主下载的2017.02的最新版本，下载后如果你自己已经有安装node了，那么ide会像myeclipse一样自动找到node的位置并添加配置，不需要你手动配置。如果你没有成功，那么到File-&gt;Setting-&gt;输入Node.js（选中点进去）-&gt;Node imterpreter（选择node的安装路径即可）-&gt;确定 2.设置自动补全首先需要下载core code，File-&gt;Setting-&gt;输入Node.js（选中点进去）-&gt;第二行有个enable（旁白是说源码是否下载应用）-&gt;确定 然后File-&gt;Setting-&gt;Language&amp;Frameworks-&gt;JavaScript-&gt;Libraries-&gt;勾选Nodejs Core-&gt;确定 传送门： webstorm配置支持nodejs并自动补全","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"nodejs","slug":"nodejs","permalink":"/tags/nodejs/"}]},{"title":"BlobURL的使用详解","slug":"BlobURL的使用详解","date":"2018-01-16T11:35:52.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2018/01/16/BlobURL的使用详解/","link":"","permalink":"/2018/01/16/BlobURL的使用详解/","excerpt":"Blob是二进制大对象，在前端数据交换中占有重要地位。可能大家会对Blob很熟悉，但是BlobURL就相对陌生。其实BlobURL十分强大，其中一个应用就是在线预览图片。","text":"Blob是二进制大对象，在前端数据交换中占有重要地位。可能大家会对Blob很熟悉，但是BlobURL就相对陌生。其实BlobURL十分强大，其中一个应用就是在线预览图片。 原创文章 BlobURL的应用讨论BlobURL的应用，我们需要做些小实践。比如下列代码：1234567891011// HTML&lt;input type='file' /&gt;\\&lt;img src='' /&gt;// jsvar fileIpt = document.getElementsByTagName(\"input\")[0];var img = document.getElementsByTagName(\"img\")[0];fileIpt.onchange = function(e) &#123; var URL = e.target.files[0]; console.log(URL); img.src = URL;&#125; 以上代码通过上传文件，获取文件地址并赋值给img，img在页面呈现图片。然而，浏览器（chrome为例）的控制台输出的是C:\\fakepath\\xxx.gif，显然不是本地真实路径。这是浏览器出于安全性考虑的结果。所以无法预览图片。 所以，问题就是我们很难获取一个本地路径并预览图片，而BlobURL提供了解决方案。首先看看《javascript权威指南》对于这方面的描述： Blob URL和创建它们的脚本拥有同样的源。这使得它们比file://URL更加灵活，由于file://URL是非同源的，因此要在Web应用中使得它们相对比较麻烦。 因此我们Blob URL能够正确反映本地路径。 使用blob URL我们改写以上例子：12345678910111213141516// 出于兼容性考虑，编写getBlobURLvar getBlobURL = (window.URL &amp;&amp; URL.createObjectURL.bind(URL)) || (window.webkitURL &amp;&amp; webkitURL.createObjectURL.bind(webkitURL)) || window.createObjectURL;// revokeBlobURL可以取消blobURL的使用var revokeBlobURL = (window.URL &amp;&amp; URL.revokeObjectURL.bind(URL)) || (window.webkitURL &amp;&amp; webkitURL.revokeObjectURL.bind(webkitURL)) || window.revokeObjectURL;var fileIpt = document.getElementsByTagName(\"input\")[0];var img = document.getElementsByTagName(\"img\")[0];fileIpt.onchange = function(e) &#123; var URL = webkitURL.createObjectURL(e.target.files[0]); console.log(URL); img.src = URL;&#125; 尝试上传一张图片，客户端能够对图片正确渲染。查看控制台，输出blob:xxx。预览成功！ 有人会说，把图片上传之后再预览也是可以实现在线预览图片的。缺点很明显，非常麻烦，并且占用内存和服务端流量。 传送门： IE8上传文件时javascript取文件的本地路径的问题C:\\fakepath\\","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"/tags/HTML5/"},{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"原创","slug":"原创","permalink":"/tags/原创/"}]},{"title":"FileSaver的使用","slug":"FileSaver的使用","date":"2018-01-15T13:13:30.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2018/01/15/FileSaver的使用/","link":"","permalink":"/2018/01/15/FileSaver的使用/","excerpt":"FileSaver是实用的库，它可以使用js实现文件的下载，依赖于Blob。如果browser没有相关实现，可以使用Blob.js实现跨浏览器兼容。","text":"FileSaver是实用的库，它可以使用js实现文件的下载，依赖于Blob。如果browser没有相关实现，可以使用Blob.js实现跨浏览器兼容。 github上的文档是英文的，如果看着头痛，看我这篇即可 FileSaver依赖于Blob.js，因为大部分brower对Blob的大小有限制，所以超大文本流的存储是不适用的。不过浏览器至少给Blob 500Mb的空间，对于一般的文本或图片流已经足够了。 如果有对存储巨大的需求，可以使用StreamSaver.js。然而StreamSaver并不是这么火，看stars就知道了。 FileSaver对canvas的支持，依赖于canvas-toBlob.js，在使用FileSaver的同时推荐结合canvas-toBlob.js使用。 语法1234567891011121314// Saving textvar blob = new Blob([\"Hello, world!\"], &#123;type: \"text/plain;charset=utf-8\"&#125;);saveAs(blob, \"hello world.txt\");// Saving a canvasvar canvas = document.getElementById(\"my-canvas\"), ctx = canvas.getContext(\"2d\");// draw to canvas...canvas.toBlob(function(blob) &#123; saveAs(blob, \"pretty image.png\");&#125;);// Saving Filevar file = new File([\"Hello, world!\"], \"hello world.txt\", &#123;type: \"text/plain;charset=utf-8\"&#125;);saveAs(file); 浏览器的表现由于我使用的是deepin，没有IE浏览器，所以就测试了部分浏览器。 多文件下载的情况下，Firefox会询问你是要直接打开还是直接下载。chrome和opera都会直接下载至默认文件夹。chrome出于安全性考虑，会询问你是否允许多文件下载。 Firefox、chrome、opera都不能改变下载路径。 传送门： FileSaver官方文档","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"/tags/HTML5/"}]},{"title":"HTML5之FileAPI详解","slug":"HTML5之FileAPI详解","date":"2018-01-15T11:47:44.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2018/01/15/HTML5之FileAPI详解/","link":"","permalink":"/2018/01/15/HTML5之FileAPI详解/","excerpt":"学习前端毫无疑问会遇到文件上传的情况，因此学习是非常必要的。事实上各大浏览器旧版本是不支持FileAPI，使用时要面向用户。","text":"学习前端毫无疑问会遇到文件上传的情况，因此学习是非常必要的。事实上各大浏览器旧版本是不支持FileAPI，使用时要面向用户。 关于FileAPI，IE只支持版本11 FileReader接口的方法1234readAsBinaryString file 将文件读取为二进制编码readAsText file,[encoding] 将文件读取为文本readAsDataURL file 将文件读取为DataURLabort (none) 终端读取操作 FileReader接口的事件123456onabort 中断onerror 出错onloadstart 开始onprogress 正在读取onload 成功读取onloadend 读取完成，无论成功失败 File的几种可读属性12345name：文件名，该属性只读。size：文件大小，单位为字节，该属性只读。type：文件的 MIME 类型，如果分辨不出类型，则为空字符串，该属性只读。lastModified：文件的上次修改时间，格式为时间戳。lastModifiedDate：文件的上次修改时间，格式为 Date 对象实例。 实例123456789101112function readAsText()&#123; var file = document.getElementById(\"file\").files[0]; var reader = new FileReader(); //将文件以文本形式读入页面 reader.readAsText(file); reader.onload=function(f)&#123; var result=document.getElementById(\"result\"); //显示文件 //读取的数据都会存储在this.result中 result.innerHTML=this.result; &#125;&#125; 传送门： h5中的fileAPI的使用方法 HTML5 File API — 让前端操作文件变的可能","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"/tags/HTML5/"}]},{"title":"express实现跨域请求","slug":"express实现跨域请求","date":"2017-12-10T14:49:11.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/12/10/express实现跨域请求/","link":"","permalink":"/2017/12/10/express实现跨域请求/","excerpt":"有时候需要写一些开放的api，就会涉及到跨域请求。","text":"有时候需要写一些开放的api，就会涉及到跨域请求。 比如需要跨域请求的api路径为/task/api，那么你在express路由文件中的代码应该是这样的12345678route.all('/task/api', function(req, res, next) &#123; // 设置跨域访问 res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS'); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header('Access-Control-Allow-Headers', 'Content-Type'); // pass&#125;); 此时可以测试你的api了。","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"/tags/nodejs/"},{"name":"express","slug":"express","permalink":"/tags/express/"}]},{"title":"javascript各种长宽属性一览","slug":"javascript各种长宽属性一览","date":"2017-12-02T16:53:33.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/12/03/javascript各种长宽属性一览/","link":"","permalink":"/2017/12/03/javascript各种长宽属性一览/","excerpt":"每次看到什么xxxHeight、xxxWidth，简直让人抓狂。相似的属性还非常的多，所以干脆做个指南，方便查阅好了。","text":"每次看到什么xxxHeight、xxxWidth，简直让人抓狂。相似的属性还非常的多，所以干脆做个指南，方便查阅好了。 element属性123456obj.clientWidth //获取元素的宽度obj.clientHeight //元素的高度obj.offsetLeft //元素相对于父元素的leftobj.offsetTop //元素相对于父元素的topobj.offsetWidth //元素的宽度obj.offsetHeight //元素的高度 区别：12345clientWidth = width + paddingclientHeight = height + paddingoffsetWidth = width + padding + borderoffsetHeight = width + padding + borderoffset比client多了border的宽度 鼠标属性123456PageX // 鼠标相对document的左边距离clientX // 鼠标相对window的左边距离screenX // 鼠标相对屏幕的左边距离offsetX // IE特有，鼠标相对于触发事件元素的左边距离layerX // firefox特有，鼠标相比较于当前坐标系的位置 浏览器属性123456scrollHeight // 滑动条内可滑动的内容document.body.scrollTop // 视窗上面隐藏了部分的高度。document.documentElement.scrollTop // 同上，但是chrome不承认window.pageYOffset // 同上window.innerHeight // 返回浏览器窗口高度 传送门: JS实现无限分页加载——原理图解 height、clientHeight、scrollHeight、offsetHeight区别 Chrome不认documentElement.scrollTop pageX,clientX,offsetX,layerX的区别","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"vue2.0中:key的解析","slug":"vue2-0中-key的解析","date":"2017-12-01T12:20:39.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/12/01/vue2-0中-key的解析/","link":"","permalink":"/2017/12/01/vue2-0中-key的解析/","excerpt":"可能不止我一个，在看vue文档的时候，面对着v-for循环那一版块中的:key而头晕目眩。因为无论加还是不加:key，渲染出来的结果都是相同的，平常联系很难看出差别。参考了一些比较靠谱的文章，才弄懂了:key的用法。本质上，:key是用来提升渲染效率的。","text":"可能不止我一个，在看vue文档的时候，面对着v-for循环那一版块中的:key而头晕目眩。因为无论加还是不加:key，渲染出来的结果都是相同的，平常联系很难看出差别。参考了一些比较靠谱的文章，才弄懂了:key的用法。本质上，:key是用来提升渲染效率的。 文档大部分引用文末文章内容 其实不只是vue，react中执行列表渲染时也要求给每个组件添加key这个属性。 引用一下vue官方文档对:key的解释： key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。————vue中文文档 对于这一段话，大家可能不是很懂。 要解释key的作用，不得不先介绍一下虚拟的DOM的Diff算法了。 我们知道，vue和react都实现了一套虚拟DOM，使我们可以不直接操作DOM元素，只操作数据便可以重新渲染页面。而隐藏在背后的原理便是其搞笑的Diff算法。 vue和react的虚拟DOM的Diff算法大致相同，而核心是基于两个简单假设： 两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。 同一层级的一组节点，他们可以通过唯一的id进行区分。 基于以上两点假设，使得，使得虚拟DOM的Diff算法从复杂度O(n^3)降到O(n)。 这里我们借用中的一张图来简单说明一下： 当页面的数据发生改变时，Diff算法只会比较同一层级的节点： 如果节点的类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。 如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。 当某一层有很多相同的节点，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。 比如一下这个情况： 我们希望在B和C之间加一个F，Diff算法默认执行起来是这样的： 即把C更新成F，D更新成C，E更新成D，最后插入E，是不是很没有效率？ 所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确地识别此节点，找到正确的位置区插入新的节点。 所以一句话，key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们， 否则vue只会替换其内部属性而不会触发过渡效果。 传送门： vue.js中文文档——:keyVue2.0 v-for 中 :key 到底有什么用？","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"vuejs","slug":"vuejs","permalink":"/tags/vuejs/"}]},{"title":"vue调试器vue-devtools安装","slug":"vue调试器vue-devtools安装","date":"2017-12-01T11:17:11.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/12/01/vue调试器vue-devtools安装/","link":"","permalink":"/2017/12/01/vue调试器vue-devtools安装/","excerpt":"在github上逛了一下，偶然拾获神器一枚——vue-devtools。其实是chrome浏览器插件，使用这个插件，能很方便地进行vue的开发。","text":"在github上逛了一下，偶然拾获神器一枚——vue-devtools。其实是chrome浏览器插件，使用这个插件，能很方便地进行vue的开发。 chrome商店直接安装vue-devtools可以从chrome商店直接下载安装，非常简单，这里就不过多介绍了。 不过要注意的一点就是，需要翻墙才能下载。 我们学校网络自带翻墙，哈哈，就直接用这种方式装了。 手动安装一、克隆github项目到本地：1git clone https://github.com/vuejs/vue-devtools.git 二、安装项目所需要的npm包：1cnpm install 三、编译项目文件：1npm run build 四、添加至chrome浏览器12345游览器输入地址“chrome://extensions/”进入扩展程序页面，点击“加载已解压的扩展程序...”按钮，选择vue-devtools&gt;shells下的chrome文件夹。/***如果看不见“加载已解压的扩展程序...”按钮，则需要勾选“开发者模式”。*/ 到此添加完成，效果图如下： vue-devtools如何使用当我们添加完vue-devtools扩展程序之后，我们在调试vue应用的时候，chrome开发者工具中会看一个vue的一栏，点击之后就可以看见当前页面vue对象的一些信息。vue-devtools使用起来还是比较简单的，上手非常的容易，这里就细讲其使用说明了。 生产环境下的vue配置如果不对vue进行配置，那么做出来的项目会被vue-devtools读取，这样可能会暴露安全问题。 一般情况下，调试好的vue项目会在js文档的最上层添加：12Vue.config.devtools=false;Vue.config.productionTip=false; //阻止vue启动时生成生产消息 这样就禁用了vue-devtools功能。 传送门： Vue调试神器vue-devtools安装","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"vuejs","slug":"vuejs","permalink":"/tags/vuejs/"}]},{"title":"bower简单部署","slug":"bower简单部署","date":"2017-12-01T10:47:59.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/12/01/bower简单部署/","link":"","permalink":"/2017/12/01/bower简单部署/","excerpt":"有时候会看见一些比较优秀的js库使用bower命令下载，这里记录以下bower在项目中的部署，以便日后使用。","text":"有时候会看见一些比较优秀的js库使用bower命令下载，这里记录以下bower在项目中的部署，以便日后使用。 什么是bowerBower是一个客户端技术的软件包管理器，它可用于搜索、安装和卸载如JavaScript、HTML、CSS之类的网络资源。 项目部署安装node.js和git12$ sudo apt-get install nodejs$ sudo apt-get install git 全局安装bower1$ npm install -g bower 使用help查看帮助1$ bower -help 在项目目录下新建文件.bowerrc:123$ touch .bowerrc// 查看文件目录$ ls -a 打开.bowerrc修改代码包目录位置1$ gedit .bowerrc 假如项目文件名为myapp，自定义的代码包目录为myapp/js/lib，则添加内容如：123&#123; \"directory\" : \"js/lib\"&#125; 之后使用bower命令下载的所有代码包都会存放在这个位置。 在项目目录中初始化:1$ bower init 之后会让你输入基本信息，然后一直回车或者空格：123456789101112131415161718192021&#123; \"name\": \"bb_boot\", \"version\": \"0.0.1\", \"authors\": [ \"savokiss &lt;jaynaruto@qq.com&gt;\" ], \"moduleType\": [ \"amd\" ], \"license\": \"MIT\", \"ignore\": [ \"**/.*\", \"node_modules\", \"bower_components\", \"js/lib\", \"test\", \"tests\" ], \"dependencies\": &#123; &#125;&#125; 这时候发现，根目录下多了一个bower.json文件，用来存放各种配置。 这样，bower在项目中已经部署完成了。 日常使用包的安装比如我要装一个jquery，输入以下命令：1bower install jquery --save 这时候jquery的最新版已经被远程下载到js/lib文件夹里。 其中--save的参数是保存配置道你的bower.json，你会发现bower.json文件已经多了一行：123\"dependencies\": &#123; \"jquery\": \"~2.1.4\"&#125; 包的信息比如我们想查找jquery有哪些版本，输入一下命令：1$ bower info jquery 这时候会输出一堆版本号。 包的更新有时候我们会需要安装低版本的jquery，那么怎么办呢？ 打开bower.json，修改jquery的版本号：123\"dependencies\": &#123; \"jquery\": \"~1.11.3\"&#125; 然后执行如下命令：1$ bower update bower会为你切换版本号。 包的查找比如我想装个bootstrap，但是记不住名字，那么直接在命令行中输入：1$ bower search bootstrap bower会列出包含bootstrap的可用包。 包的卸载很简单1bower uninstall jquery 传送门： bower简明入门教程","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"bower","slug":"bower","permalink":"/tags/bower/"}]},{"title":"生产环境下部署babel","slug":"生产环境下部署babel","date":"2017-11-28T12:34:50.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/11/28/生产环境下部署babel/","link":"","permalink":"/2017/11/28/生产环境下部署babel/","excerpt":"ES6在v8引擎中运行良好,但是在浏览器中则需要利用babel编译为ES5再运行.虽然能够利用babel.min.js直接书写前端代码,但是出于性能考虑,我们都应该使用babel转换.","text":"ES6在v8引擎中运行良好,但是在浏览器中则需要利用babel编译为ES5再运行.虽然能够利用babel.min.js直接书写前端代码,但是出于性能考虑,我们都应该使用babel转换. Babel转码器简介Babel是一个广泛使用的ES6转码器,可以将ES6代码转为ES5代码,从而在现有的浏览器环境下执行.1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); 配置文件.babelrc使用babel的第一步,是新建一个.babelrc到项目的根目录,然后配置这个文件。1234567891011121314151617# 新建.babelrc文件$ touch .babelrc# 查看文件目录$ ls -a# 最新转码规则$ npm install --save-dev babel-preset-latest# react 转码规则$ npm install --save-dev babel-preset-react# 不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 修改.babelrc12345678&#123; \"presets\": [ \"latest\", \"react\", \"stage-2\" ], \"plugins\": []&#125; 命令行转码babel-cli１. 全局安装1$ npm install --global babel-cli 日常使用1234567891011121314151617# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s ２. 局部安装1$ npm install --save-dev babel-cli 此时添加一个脚本，修改package.json123456789&#123; // ... \"devDependencies\": &#123; \"babel-cli\": \"^6.0.0\" &#125;, \"scripts\": &#123; \"build\": \"babel src -d lib\" &#125;,&#125; 以后就只需要执行以下命令即可1$ npm run build 传送门: ECMAScript 6 入门-阮一峰","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"babel","slug":"babel","permalink":"/tags/babel/"},{"name":"ES6","slug":"ES6","permalink":"/tags/ES6/"}]},{"title":"css3手动重置radio样式","slug":"css3手动重置radio样式","date":"2017-11-18T17:26:40.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/11/19/css3手动重置radio样式/","link":"","permalink":"/2017/11/19/css3手动重置radio样式/","excerpt":"最近看了有关重置input按钮样式的文章，了解了这方面的原理。稍微理清了一下思路，重置样式的方法大概有两种，第一种是使用纯css实现，第二种是使用js切换class实现的。个人觉得，纯css实现会更加优秀。在此写一个demo，附带解释。","text":"最近看了有关重置input按钮样式的文章，了解了这方面的原理。稍微理清了一下思路，重置样式的方法大概有两种，第一种是使用纯css实现，第二种是使用js切换class实现的。个人觉得，纯css实现会更加优秀。在此写一个demo，附带解释。 更新于2017.11.09 成品展示 实现思路： 在input后面放一个label，使用for关联input按钮 将input的opacity调为0，并固定位置 将label设置为absolute，将label覆盖在input上 设置input::checked时，label的样式 如此重置radio样式，checkbox也如此 demo源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// html&lt;form&gt; &lt;div class=\"botton-group\"&gt; &lt;div&gt; &lt;input id=\"item-1\" type=\"radio\" name=\"gender\" value=\"male\" /&gt; &lt;label class=\"blank\" for=\"item-1\"&gt;&lt;/label&gt; &lt;label class=\"message\" for=\"item-1\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"botton-group\"&gt; &lt;div&gt; &lt;input id=\"item-2\" type=\"radio\" name=\"gender\" value=\"female\" /&gt; &lt;label class=\"blank\" for=\"item-2\"&gt;&lt;/label&gt; &lt;label class=\"message\" for=\"item-2\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;// css.botton-group &#123; display: inline-block; padding: 20px;&#125;.botton-group&gt;div &#123; display: inline-block; position: relative;&#125;.botton-group input[type=\"radio\"] &#123; width: 20px; height: 20px; margin: 0; padding: 0; opacity: 0;&#125;.botton-group input[type=\"radio\"] + .blank &#123; position: absolute; top: 0; bottom: 0; left: 0; width: 20px; height: 20px; display: block; border: 1px solid #ff7d7b;&#125;.botton-group input[type=\"radio\"]:checked + .blank &#123; background-color: #ff7d7b; border: 1px solid #ff7d7b;&#125;.botton-group input[type=\"radio\"]:checked + .blank::after &#123; position: absolute; content: \"\"; width: 5px; height: 10px; top: 3px; left: 6px; border: 2px solid #ffffff; border-top: none; border-left: none; transform: rotate(45deg);&#125;.botton-group .message &#123; vertical-align: text-bottom;&#125; 为了不让label失去它原有的功能，这里设置了两个label。这样的设置会让界面更友好。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"原创","slug":"原创","permalink":"/tags/原创/"},{"name":"html","slug":"html","permalink":"/tags/html/"},{"name":"css","slug":"css","permalink":"/tags/css/"}]},{"title":"使用CSS3::selection伪元素改变文本选中颜色","slug":"使用CSS3-selection伪元素改变文本选中颜色","date":"2017-11-17T15:51:48.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/11/17/使用CSS3-selection伪元素改变文本选中颜色/","link":"","permalink":"/2017/11/17/使用CSS3-selection伪元素改变文本选中颜色/","excerpt":"改变文本选中的颜色…好像不是特别有用。不过作为一个颜色控，是很有必要了解::selection这个伪元素。","text":"改变文本选中的颜色…好像不是特别有用。不过作为一个颜色控，是很有必要了解::selection这个伪元素。 本文内容摘录自鑫生活 目前Firefox、Safari、Chrome以及Opera浏览器都支持文本选择属性，如果浏览器不支持该属性，会直接忽略它，所以不会产生任何不良的影响。 改变默认选中颜色首先，简单点的例子，我们可以设置整个页面文本选中的基本样式，如下：1234567891011121314::selection &#123; background:#d3d3d3; color:#555;&#125;::-moz-selection &#123; background:#d3d3d3; color:#555;&#125;::-webkit-selection &#123; background:#d3d3d3; color:#555;&#125; 当然，我们可以使用CSS选择器指定特定标签内容文字选中后的样式状态，例如下面所展示的栗色选中状态：1234567891011121314.maroon::selection &#123; background:maroon; color:#fff;&#125;.maroon::-moz-selection &#123; background:maroon; color:#fff;&#125;.maroon::-webkit-selection &#123; background:maroon; color:#fff;&#125; 实例页面：CSS3改变文本选中默认样式demo 传送门： 使用CSS3 ::selection伪元素改变文本选中颜色","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}]},{"title":"<pre>标签的使用","slug":"pre-标签的使用","date":"2017-11-17T15:06:20.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/11/17/pre-标签的使用/","link":"","permalink":"/2017/11/17/pre-标签的使用/","excerpt":"做做笔记。碰见了一个网站，显示代码的时候自带语法高亮，这很新鲜。它的代码被pre标签包裹，原本以为pre标签下的所有的内容会以文本原来的样式输出，特意查了查发现它依然支持html标签。","text":"做做笔记。碰见了一个网站，显示代码的时候自带语法高亮，这很新鲜。它的代码被pre标签包裹，原本以为pre标签下的所有的内容会以文本原来的样式输出，特意查了查发现它依然支持html标签。 先来个菜鸟教程的栗子：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Bootstrap 实例 - 代码&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"http://cdn.static.runoob.com/libs/bootstrap/3.3.7/css/bootstrap.min.css\"&gt; &lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; 作为内联元素被包围。&lt;/p&gt;&lt;p&gt;如果需要把代码显示为一个独立的块元素，请使用 &amp;lt;pre&amp;gt; 标签：&lt;/p&gt;&lt;pre&gt;&amp;lt;article&amp;gt; &amp;lt;h1&amp;gt;Article Heading&amp;lt;/h1&amp;gt;&amp;lt;/article&amp;gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt; 显示结果为1234567&lt;header&gt; 作为内联元素被包围。如果需要把代码显示为一个独立的块元素，请使用 &lt;pre&gt; 标签：&lt;article&gt; &lt;h1&gt;Article Heading&lt;/h1&gt;&lt;/article&gt; 分析： 显然，这里为了避免&lt;&gt;直接被当成html标签而渲染，例子使用了unicode变体。 事实上&lt;pre&gt;标签是可以内嵌html标签的（关于这点请自行测试）。 总之，&lt;pre&gt;支持能够内嵌html标签为语法高亮提供了实现基础。当然，如果你想让&lt;pre&gt;内输出原生的html标记，那么麻烦在输出前手动转码。 传送门： Bootstrap 代码","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"meta中name属性详解","slug":"meta中name属性详解","date":"2017-11-16T17:36:42.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/11/17/meta中name属性详解/","link":"","permalink":"/2017/11/17/meta中name属性详解/","excerpt":"几乎所有网站都会看到meta中有一个name属性，并通过content赋值。","text":"几乎所有网站都会看到meta中有一个name属性，并通过content赋值。 一、放在哪里？首先我们说一下meta，mata是放在在head区的一个辅助性标签 提供了有关页面的信息，对于进入搜索引擎的索引有帮助，几乎所有的网页里面都能看到它的存在。 二、有什么作用？meta元素可提供有关页面的信息，比如针对搜索引擎和更新频度的内容提要和关键词，或者是定义用户浏览器上的cookie；它可以用于鉴别作者，设定页面格式，还可以设置页面 使其可以根据你定义的时间间隔刷新自己,以及设置RASC内容等级，等等。 用好它对于SEO优化很关键的，可以给你的网站带来意想不到的效果。 三、meta标签的组成。meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 http-equiv属性主要是用来给浏览器识别网页内容，如Content-Type和Content-Language ，它们告诉浏览器网页使用了哪种语言和字符集，这里先且略过。主要说一下name属性的 作用，name是描述网页的，对应于Content（网页内容），以便于搜索引擎机器人查找、分类网站（目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类）。 四、参数解析name常用的选项（固定好的）有keywords(关键字) ，description(网站内容描述)，author(作者)，robots(机器人向导)等等。还可以指定其他任意值，看球 1、Keywords(关键字)说明：keywords是用来告诉搜索引擎你的网站的关键字是什么，提高搜索引擎的搜索质量,提高网站的排名。关键字用英文逗号隔开，包括标点符号不要超过250个单词。将最重要的关键词放在最前面，让相关的关键词相邻。 例子：1＜meta name =\"keywords\" content=\"服务器,VPS主机,厦门云主机租用,服务器租用托管，厦门服务器租用托管\"＞ 2、description(网站内容描述)说明：description用来告诉搜索引擎你的网站主要内容，缩小关键字的判断范围。比如你用百度或GOOGLE等搜索引擎搜索某个关键字的结果下都有一下段描述，这个就是description的内容（注：百度也有可能抓取的是网站内容的关键字作为描述）如果description没有内容，也会一定地影响网站的收录。 例子：1＜meta name =\"description\" content=\"厦门凌众科技是十年老牌IDC提供商(lingzhong.net.cn)\"＞ 3、author(作者)说明：标注网页的作者或制作人，制作公司等，可以是名字，域名或是E-mail等等。 4、robots(机器人向导)说明：Robots用来告诉搜索引擎哪些页面需要索引，哪些页面不需要索引。参数有all、none、index、noindex等等。 all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询；(和 “noindex, no follow” 起相同作用) index：文件将被检索；（让robot/spider登录） follow：页面上的链接可以被查询； noindex：文件将不被检索，但页面上的链接可以被查询；(不让robot/spider登录) nofollow：文件将不被检索，页面上的链接可以被查询。(不让robot/spider顺着此页的连接往下探找) 还有一些我们比较不常用到的： 5、Copyright (版权)6、Generator (编辑器)7、revisit-after (重访)就不一一解释了。 传送门： 标签的讲解","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"meta中X-UA-Compatible字段","slug":"meta中X-UA-Compatible字段","date":"2017-11-16T17:36:19.000Z","updated":"2018-04-10T03:45:06.000Z","comments":true,"path":"2017/11/17/meta中X-UA-Compatible字段/","link":"","permalink":"/2017/11/17/meta中X-UA-Compatible字段/","excerpt":"X-UA-Compatible字段其实是http-equiv属性的一个值，上一篇文章并没有把这个字段列出来，证明这个属性不常见。","text":"X-UA-Compatible字段其实是http-equiv属性的一个值，上一篇文章并没有把这个字段列出来，证明这个属性不常见。 有时候会在网站源码上header看到这么一条：1&lt; meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge,chrome=1\" /&gt; 这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式（比如人见人烦的IE6），以此来解决部分兼容问题，例如模拟IE7的具体方式如下：1&lt; meta http-equiv = \"X-UA-Compatible\" content = \"IE=EmulateIE7\" /&gt; 但令我好奇的是，此处这个标记后面竟然出现了chrome这样的值，难道IE也可以模拟chrome了？迅速搜索了一下，才明白原来不是微软增强了IE，而是谷歌做了个外挂：Google Chrome Frame（谷歌内嵌浏览器框架GCF）。这个插件可以让用户的IE浏览器外不变，但用户在浏览网页时，实际上使用的是Google Chrome浏览器内核，而且支持IE6、7、8等多个版本的IE浏览器，谷歌这个墙角挖的真给力！ 而上文提到的那个meta标记，则是在是安装了GCF后，用来指定页面使用chrome内核来渲染。 GCF下载地址: http://code.google.com/intl/zh-CN/chrome/chromeframe/ 安装完成后,如果你想对某个页面使用GCF进行渲染，只需要在该页面的地址前加上 gcf： 即可，例如： gcf:http://cooleep.com 但是如果想要在开发时指定页面默认首先使用GCF进行渲染，如果未安装GCF再使用IE内核进行渲染，该如何进行呢？ 就是使用这个标记。 传送门： 玉米前端的博客","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"meta中http-equiv属性详解","slug":"meta中http-equiv属性详解","date":"2017-11-16T16:10:27.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/11/17/meta中http-equiv属性详解/","link":"","permalink":"/2017/11/17/meta中http-equiv属性详解/","excerpt":"最近在研究大网站如何优雅地使用bootstrap，翻开源码一看，各种meta足以让我头晕眼花。趁这个机会，攻克这个知识点吧。","text":"最近在研究大网站如何优雅地使用bootstrap，翻开源码一看，各种meta足以让我头晕眼花。趁这个机会，攻克这个知识点吧。 这里讲的东西，其实相当一部分我还是不太理解的，还是做个笔记吧 http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 meat标签的http-equiv属性语法格式是：＜meta http-equiv=”参数” content=”参数变量值”＞ ；其中http-equiv属性主要有以下几种参数： 1. Expires(期限)说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 用法：1＜meta http-equiv=\"expires\" content=\"Wed, 20 Jun 2007 22:33:00 GMT\"＞ 2. Pragma(cache模式)说明：是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出 用法：1＜meta http-equiv=\"Pragma\" content=\"no-cache\"＞ 3. Refresh(刷新)说明：自动刷新并指向新页面。 用法：1＜meta http-equiv=\"Refresh\" content=\"2；URL=http://www.net.cn/\"＞ 注意：其中的2是指停留2秒钟后自动刷新到URL网址。 4. Set-Cookie(cookie设定)说明：如果网页过期，那么存盘的cookie将被删除。 用法：1＜meta http-equiv=\"Set-Cookie\" content=\"cookievalue=xxx;expires=Wednesday, 20-Jun-2007 22:33:00 GMT； path=/\"＞ 注意：必须使用GMT的时间格式。 5. Window-target(显示窗口的设定)说明：强制页面在当前窗口以独立页面显示。 用法：1&lt;meta http-equiv=\"Window-target\" content=\"_top\"&gt; 注意：用来防止别人在框架里调用自己的页面。 6. content-Type(显示字符集的设定)说明：设定页面使用的字符集。 用法：1＜meta http-equiv=\"content-Type\" content=\"text/html; charset=gb2312\"＞ 7. Pics-label(网页等级评定)说明：在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的。 用法：1&lt;meta http-equiv=\"Pics-label\" contect=\"\"&gt; 8. Page_Enter、Page_Exit设定进入页面时的特殊效果1&lt;meta http-equiv=\"Page-Enter\" contect=\"revealTrans(duration=1.0,transtion= 12)\"&gt; 设定离开页面时的特殊效果1&lt;meta http-equiv=\"Page-Exit\" contect=\"revealTrans(duration=1.0,transtion= 12)\"&gt; Duration的值为网页动态过渡的时间，单位为秒。Transition是过渡方式，它的值为0到23，分别对应24种过渡方式。如下表： 0 盒状收缩 1 盒状放射2 圆形收缩 3 圆形放射4 由下往上 5 由上往下6 从左至右 7 从右至左8 垂直百叶窗 9 水平百叶窗10 水平格状百叶窗 11垂直格状百叶窗12 随意溶解 13从左右两端向中间展开14从中间向左右两端展开 15从上下两端向中间展开16从中间向上下两端展开 17 从右上角向左下角展开18 从右下角向左上角展开 19 从左上角向右下角展开20 从左下角向右上角展开 21 水平线状展开22 垂直线状展开 23 随机产生一种过渡方式 9. 清除缓存（再访问这个网站要重新下载！）1&lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt; 10. 设定网页的到期时间1&lt;meta http-equiv=\"expires\" content=\"0\"&gt; 11. 关键字,给搜索引擎用的1&lt;meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\"&gt; 12. 页面描述1&lt;meta http-equiv=\"description\" content=\"This is my page\"&gt; 传送门： Meta http-equiv属性详解(转)","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"Ubuntu修改文件权限","slug":"Ubuntu修改文件权限","date":"2017-11-14T15:46:06.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/11/14/Ubuntu修改文件权限/","link":"","permalink":"/2017/11/14/Ubuntu修改文件权限/","excerpt":"做笔记","text":"做笔记 1chmod -R 777 myapp/","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"}]},{"title":"Ubuntu下解压tar.xz方法","slug":"Ubuntu下解压tar-xz方法","date":"2017-11-11T17:52:18.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/11/12/Ubuntu下解压tar-xz方法/","link":"","permalink":"/2017/11/12/Ubuntu下解压tar-xz方法/","excerpt":"在安装某些东西的时候，遇到了tar.xz文件。","text":"在安装某些东西的时候，遇到了tar.xz文件。 这种压缩包是两层压缩，外面是xz压缩方式，里层是tar压缩方式：12$ xz -d ***.tar.xz$ tar -xvf ***.tar 传送门： Ubuntu 下解压tar.xz方法","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"}]},{"title":"如何获取input中checked真实值","slug":"如何获取input中checked真实值","date":"2017-11-11T17:25:39.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/11/12/如何获取input中checked真实值/","link":"","permalink":"/2017/11/12/如何获取input中checked真实值/","excerpt":"在做一个自动获取表单数据的函数时，我发现radio/checkbox被点击后checked没有刷新。","text":"在做一个自动获取表单数据的函数时，我发现radio/checkbox被点击后checked没有刷新。 我的意思是它们在chrome控制台的html代码中并没有显式显示checked属性，实际上checked属性是一直存在的，关于这一点可以查看表单元素的属性，发现checked被点击后value一直在变化（true/false)。如果我一开始给input指定checked，那么我使用attr(&quot;checked&quot;)能够返回checked，如果我一开始不指定checked，那么会返回undefined。 这很不科学对吧？ 我们的预期是当我们点击radio/checkbox时候，checked属性会变化，但实际上attr()获取的都不是真实值。 解决方案——使用prop()代替。 12345// 获得checked真实值$(\"#radio\").prop(\"checked\"); ==&gt; true/false// 设置真实值$(\"#radio\").prop(\"checked\", \"true\"); 提示： 如需检索HTML属性，请使用attr()方法代替 如需移除属性，请使用removeProp()方法。 传输门： 菜鸟教程——jQuery prop() 方法 jquery attr方法获取input的checked属性问题","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"/tags/JQuery/"},{"name":"表单","slug":"表单","permalink":"/tags/表单/"}]},{"title":"JQuery以JSON方式提交到服务端","slug":"JQuery以JSON方式提交到服务端","date":"2017-11-11T17:04:54.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/11/12/JQuery以JSON方式提交到服务端/","link":"","permalink":"/2017/11/12/JQuery以JSON方式提交到服务端/","excerpt":"最近的项目需要给服务端提交JSON，JSON本来应该是很简单的，但是我还是折腾了好一段时间。博主我后端使用的是nodejs。","text":"最近的项目需要给服务端提交JSON，JSON本来应该是很简单的，但是我还是折腾了好一段时间。博主我后端使用的是nodejs。 前端一般来说我比较喜欢用$.ajax来提交数据：123456789101112131415$.ajax(&#123; type: \"POST\", url: \"your url\", contentType: \"application/json; charset=utf-8\", data: JSON.stringify(data), dataType: \"json\", success: function (result) &#123; if (message &gt; 0) &#123; alert(\"请求已提交！我们会尽快与您取得联系\"); &#125; &#125;, error: function (result) &#123; alert(\"提交数据失败！\"); &#125; &#125;); 值得注意的是，前端代码即使声明了dataType:&quot;json&quot;，也需要将数据通过JSON.stringify()转换为json字符串再进行传输。JQuery不会你的对象转换为JSON格式，data传输始终都是一串有规律的字符串，数据类型的声明只是附加的内容，用来告诉服务端这是JSON数据。 后端我这次的项目使用的是nodejs的express框架。 比如我写一个路由文件router.js1234567891011var express = require(\"express\");var router = express.Router;router.post(\"/\", function(req, res, next) &#123; // 获取数据 var data = req.body; // 获取对象数据 var value = data[\"key\"]; // 返回数据 res.send(value);&#125;); 我们来分析一下： 后台使用req.body直接获取前端提交的内容，那应该是一串JSON字符串，但是nodejs直接就可以访问里面的属性了。这证明前端的dataType声明是有效的，后台根据声明自动将JSON转换为一个可访问js对象。 如果在这个过程中，前端没有使用JSON.stringify()或者后端使用了JSON.parse()，服务器都会返回500。 传输门： JQuery以JSON方式提交数据到服务端","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"/tags/JQuery/"},{"name":"JSON","slug":"JSON","permalink":"/tags/JSON/"}]},{"title":"js直接获取对象属性个数的方法","slug":"js直接获取对象属性个数的方法","date":"2017-11-11T16:59:21.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/11/12/js直接获取对象属性个数的方法/","link":"","permalink":"/2017/11/12/js直接获取对象属性个数的方法/","excerpt":"也许我们遍历对象属性的时候，可以使用for in循环，但很多时候我们需要直接得到对象属性的个数。这里的对象属性个数是指对象的私有属性，而不包括对象的继承属性。","text":"也许我们遍历对象属性的时候，可以使用for in循环，但很多时候我们需要直接得到对象属性的个数。这里的对象属性个数是指对象的私有属性，而不包括对象的继承属性。 直接上代码1Object.getOwnPropertyNames(a).length 传输门： JS 有没什么属性是直接获取对象属性个数的？","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"我永远喜欢vue保姆","slug":"我永远喜欢vue保姆","date":"2017-11-07T05:54:43.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/11/07/我永远喜欢vue保姆/","link":"","permalink":"/2017/11/07/我永远喜欢vue保姆/","excerpt":"曾经由我导师推荐，我看过一次vue文档。但是一直没有用。现在我需要给组织搞网页，前后用了许多ui框架，偏偏缺少一个熟悉的js框架。这篇文章用来复习vuejs的基本用法。","text":"曾经由我导师推荐，我看过一次vue文档。但是一直没有用。现在我需要给组织搞网页，前后用了许多ui框架，偏偏缺少一个熟悉的js框架。这篇文章用来复习vuejs的基本用法。 ng是妈，react是老婆，vue是保姆 这篇文章为我自己做一个文档字典，方便我自己查阅。如需学习vue请查看vue文档。 兼容性Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。Vue.js 支持所有兼容 ECMAScript 5 的浏览器。 声明式渲染{}123&lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app',s data: &#123; message: 'Hello Vue!' &#125;&#125;) 响应式属性v-bind12345&lt;div id=\"app-2\"&gt; &lt;span v-bind:title=\"message\"&gt; 鼠标悬停几秒钟查看此处动态绑定的提示信息！ &lt;/span&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: '#app-2', data: &#123; message: '页面加载于 ' + new Date().toLocaleString() &#125;&#125;) 条件v-if123&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;) 循环v-for1234567&lt;div id=\"app-4\"&gt; &lt;ol&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue' &#125;, &#123; text: '整个牛项目' &#125; ] &#125;&#125;) 事件v-on1234&lt;div id=\"app-5\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"reverseMessage\"&gt;逆转消息&lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: 'Hello Vue.js!' &#125;, methods: &#123; reverseMessage: function () &#123; this.message = this.message.split('').reverse().join('') &#125; &#125;&#125;) 表单v-model1234&lt;div id=\"app-6\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue' &#125;, &#123; text: '整个牛项目' &#125; ] &#125;&#125;) 组件系统1234567891011121314&lt;div id=\"app-7\"&gt; &lt;ol&gt; &lt;!-- 现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的。 我们也需要为每个组件提供一个“key”，晚些时候我们会做个解释。 --&gt; &lt;todo-item v-for=\"item in groceryList\" v-bind:todo=\"item\" v-bind:key=\"item.id\"&gt; &lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 1234567891011121314Vue.component('todo-item', &#123; props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)var app7 = new Vue(&#123; el: '#app-7', data: &#123; groceryList: [ &#123; id: 0, text: '蔬菜' &#125;, &#123; id: 1, text: '奶酪' &#125;, &#123; id: 2, text: '随便其他什么人吃的东西' &#125; ] &#125;&#125;) 传送门： vue中文文档","categories":[{"name":"网站建设","slug":"网站建设","permalink":"/categories/网站建设/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"vuejs","slug":"vuejs","permalink":"/tags/vuejs/"}]},{"title":"express中sendFile的路径问题","slug":"express中sendFile的路径问题","date":"2017-11-04T16:50:53.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/11/05/express中sendFile的路径问题/","link":"","permalink":"/2017/11/05/express中sendFile的路径问题/","excerpt":"在部署项目后台的时候，想直接输出html文件，于是在app.js旁边开了个templates文件夹，想直接通过sendFile输出里面的文件。然而折腾了许久，发现参数用的是绝对路径。","text":"在部署项目后台的时候，想直接输出html文件，于是在app.js旁边开了个templates文件夹，想直接通过sendFile输出里面的文件。然而折腾了许久，发现参数用的是绝对路径。 我这里使用的是express框架，路由文件是通过routes文件夹引用的，我这里的项目路径为1234567myapp----bin |--node_modules |--public |--routes |--static |--templates |--views 我把html文件放在templates文件夹里，通过routes文件夹里的js文件引用html文件。 比如我有一个home.js1res.sendFile(/templates/home.html); 这样的代码不可行，因为需要绝对路径，所以1res.sendFile(path.join(__dirname, '../templates', 'home.html'));","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"/tags/nodejs/"},{"name":"express","slug":"express","permalink":"/tags/express/"}]},{"title":"jquery总汇","slug":"jquery总汇","date":"2017-11-03T03:18:44.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/11/03/jquery总汇/","link":"","permalink":"/2017/11/03/jquery总汇/","excerpt":"jquery是实用的js库。为了整理jquery的知识，我亲自汇总了jquery的各种优点，就当复习吧。","text":"jquery是实用的js库。为了整理jquery的知识，我亲自汇总了jquery的各种优点，就当复习吧。 文档就绪事件12345$(document).ready(function()&#123; // 开始写 jQuery 代码...&#125;); 简介写法12345$(function()&#123; // 开始写 jQuery 代码...&#125;); jquery的功能概括 html 的元素选取选择器 html的元素操作获取内容和属性设置内容和属性添加元素删除元素 html dom遍历和修改遍历祖先后代同胞过滤 js特效和动画效果隐藏和显示淡入淡出滑动动画停止动画回调函数 css操作获取并设置 CSS 类 html事件操作事件 ajax异步请求方式AJAX load() 方法get() 和 post() 方法 其他尺寸 如图 杂项方法 方法 描述 data() 向被选元素附加数据，或者从被选元素获取数据 index() 从匹配元素中搜索给定元素 removeData() 移除之前存放的数据","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"}]},{"title":"HTML5拖放Drag和Drop","slug":"HTML5拖放Drag和Drop","date":"2017-11-02T13:53:48.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/11/02/HTML5拖放Drag和Drop/","link":"","permalink":"/2017/11/02/HTML5拖放Drag和Drop/","excerpt":"最近要跑项目，需要做mobile的拖放。虽然HTML5自带的拖放是不能够在手机上使用，也就是点了没有反应。但既然遇到了，顺便就学了吧。","text":"最近要跑项目，需要做mobile的拖放。虽然HTML5自带的拖放是不能够在手机上使用，也就是点了没有反应。但既然遇到了，顺便就学了吧。 实例12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style type=\"text/css\"&gt;#div1 &#123;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&#125;&lt;/style&gt;&lt;script&gt;function allowDrop(ev)&#123; ev.preventDefault();&#125;function drag(ev)&#123; ev.dataTransfer.setData(\"Text\",ev.target.id);&#125;function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;拖动 RUNOOB.COM 图片到矩形框中:&lt;/p&gt;&lt;div id=\"div1\" ondrop=\"drop(event)\" ondragover=\"allowDrop(event)\"&gt;&lt;/div&gt;&lt;br&gt;&lt;img id=\"drag1\" src=\"/images/logo.png\" draggable=\"true\" ondragstart=\"drag(event)\" width=\"336\" height=\"69\"&gt;&lt;/body&gt;&lt;/html&gt; 分析设置元素为可拖放1&lt;img draggable=\"true\"&gt; 拖动什么然后，规定当元素被拖动时，会发生什么。 在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。 dataTransfer.setData() 方法设置被拖数据的数据类型和值：1234function drag(ev)&#123; ev.dataTransfer.setData(\"Text\",ev.target.id);&#125; 在这个例子中，数据类型是 “Text”，值是可拖动元素的 id (“drag1”)。 放到何处ondragover 事件规定在何处放置被拖动的数据。 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用 ondragover 事件的 event.preventDefault() 方法：1event.preventDefault() 进行放置当放置被拖数据时，会发生 drop 事件。 在上面的例子中，ondrop 属性调用了一个函数，drop(event)：123456function drop(ev)&#123; ev.preventDefault(); var data=ev.dataTransfer.getData(\"Text\"); ev.target.appendChild(document.getElementById(data));&#125; 代码解释： 调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开） 通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。 被拖数据是被拖元素的 id (“drag1”) 把被拖元素追加到放置元素（目标元素）中 总结HTML5为了实现拖放而提供了4个新的API：一个属性和三个事件。 利用这四个API可以实现PC的拖放。而且五大浏览器兼容性良好。 可惜现在做的项目都是属于移动端的，就当做拓展知识好了。 HTML5 拖放（Drag 和 Drop）","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"/tags/HTML5/"}]},{"title":"nodejs/nginx部署","slug":"nodejs-nginx部署","date":"2017-10-31T15:00:06.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/31/nodejs-nginx部署/","link":"","permalink":"/2017/10/31/nodejs-nginx部署/","excerpt":"最近想把旧的项目迁移到nodejs的框架下，特地写一篇博客记录一下。","text":"最近想把旧的项目迁移到nodejs的框架下，特地写一篇博客记录一下。 安装nodejs旧版本安装1234// 更新库sudo apt-get update// 安装sudo apt-get install nodejs 输入node -v查看node版本。 实际上使用apt-get来安装nodejs不会下载最新的node版本，笔者在写文章的时候，deepinapt-get默认安装6.11.5。如果想手动安装最新版本，可移步这里 新版本安装手动安装不是不行，而是会有很多坑。实际上apt-get安装才是最省事的。 首先需要安装依赖包python-software-properties1sudo apt-get install python-software-properties 网站deb.nodesource.com维护了nodejs的各版本安装包的PPA，我们可以从该网站上下载执行导入。1curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash - 如果提示没有安装curl，需要先安装curl。 安装nodejs和npm1sudo apt-get install nodejs 安装完成之后我们查看一下nodejs和npm的版本。1234$ node -vv8.5.0$ npm -vv5.3.0 参考资料——Ubuntu环境下安装nodejs和npm 使用淘宝镜像淘宝镜像1npm install -g cnpm --registry=https://registry.npm.taobao.org 之后所有npm命令使用cnpm代替。 express安装目录生成器1cnpm install express-generator -g 使用-h列出可用命令1express -h 在恰当的目录下，创建名为myapp的应用1express myapp 安装所有的依赖包12cd myappcnpm install 启动这个应用（MacOS 或 Linux 平台）：1DEBUG=myapp npm start Windows 平台使用如下命令：1set DEBUG=myapp &amp; npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。 pm2守护进程就算express已经部署好了，总不能一直开着终端不关吧。 如果我想app.js一直进行，那该怎么办呢？所以需要pm2 全局安装pm21npm install pm2 -g 启动进程1sudo pm2 start bin/www -i 0 这时候使用pm2 list可以查看是否启动了pm2。 如果发生错误，则pm2 log查看错误日志。 Express 4.x API 中文手册 nginx安装与配置直接在终端输入：1sudo apt-get install nginx 安装完成后可以打开localhost查看默认页面。 先停止nginx服务：1sudo service nginx stop 修改nginx配置文件:1sudo gedit /etc/nginx/sites-available/default 将里面的内容替换为12345678910server &#123; listen 80; server_name a.com; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:3000; &#125;&#125; 重新启动服务：1sudo service nginx start 传送门： pm2 cluster 遇到问题","categories":[{"name":"网站建设","slug":"网站建设","permalink":"/categories/网站建设/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"/tags/nodejs/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"deepin","slug":"deepin","permalink":"/tags/deepin/"},{"name":"nginx","slug":"nginx","permalink":"/tags/nginx/"}]},{"title":"deepin中mysql的配置","slug":"deepin中mysql的配置","date":"2017-10-30T17:39:18.000Z","updated":"2018-04-10T03:45:06.000Z","comments":true,"path":"2017/10/31/deepin中mysql的配置/","link":"","permalink":"/2017/10/31/deepin中mysql的配置/","excerpt":"在deepin按照ubuntu14的方法配置mysql，发现不可行。在网上搜索了一下，发现deepin配置mysql跟ubuntu14略有差异。","text":"在deepin按照ubuntu14的方法配置mysql，发现不可行。在网上搜索了一下，发现deepin配置mysql跟ubuntu14略有差异。 安装mysql123456sudo apt-get install mysql-serversudo apt-get install mysql-client# 下面是一个驱动，选择性安装sudo apt-get install libmysqlclient-dev# 用下面语句检查是否安装成功sudo netstat -tap | grep mysql deepin安装mysql非常方便，直接可以为root设置密码，省去了很多麻烦。 默认编码键入root密码进入mysql交互模式，输入一下命令查看编码1SHOW VARIABLES LIKE 'character%'; 键入quit;退出交互模式。 修改配置文件在终端输入sudo gedit /etc/mysql/my.cnf，在打开文档下修改文件。1234567891011[mysqld]character_set_server=utf8[mysql]default-character-set= utf8[client]default-character-set = utf8 标签下没有的添加，有的修改 传送门： deepin下mysql相关","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"/tags/mysql/"},{"name":"deepin","slug":"deepin","permalink":"/tags/deepin/"}]},{"title":"Ubuntu下使用mentohust","slug":"Ubuntu下使用mentohust","date":"2017-10-30T16:00:06.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/10/31/Ubuntu下使用mentohust/","link":"","permalink":"/2017/10/31/Ubuntu下使用mentohust/","excerpt":"说来校园网的linux版本锐捷真的坑，完全装不上，wifi又不行。最后经过朋友推荐还是用了mentohust。又发现一枚神器。","text":"说来校园网的linux版本锐捷真的坑，完全装不上，wifi又不行。最后经过朋友推荐还是用了mentohust。又发现一枚神器。 文章末尾的文章其实已经讲得很清楚了，我负责修改。 下载安装包mentohust_0.3.4-1_amd64 解压解压安装包1tar -x mentohust_0.3.4-1_amd64.zip 之后获得一个deb包。 双击deb包即可。 之后会产生新的目录。 进入目录mentohust_0.3.4-1_amd64/usr/bin。 双击mentohust文件。 安装终端里首先会有一堆文字。123......人到华中大，有甜亦有辣。............ 紧接着会列举出一堆网卡。123** 网卡[1]:** 网卡[2]:...... 判断你网卡是属于哪一个数字，有一个方法：先退出终端，再把网卡拔掉，再双击文件进入终端看看少了那一个编号。那个编号就是你需要的网卡了。 输入你的用户名=&gt;输入密码=&gt;1锐捷私有=&gt;认证后=&gt;回车=&gt;认证成功 传送门：Ubuntu下使用MentoHUST代替锐捷认证上网","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"}]},{"title":"Ubuntu下安装hexo","slug":"Ubuntu下安装hexo","date":"2017-10-30T15:40:25.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/30/Ubuntu下安装hexo/","link":"","permalink":"/2017/10/30/Ubuntu下安装hexo/","excerpt":"这几天我将win10的开发工具搬到deepin来，想把deepin作为主系统来用。顺便装了hexo，来写blog。在deepin下安装hexo大同小异。","text":"这几天我将win10的开发工具搬到deepin来，想把deepin作为主系统来用。顺便装了hexo，来写blog。在deepin下安装hexo大同小异。 安装node.js1234// 更新库sudo apt-get update// 安装nodejssudo apt-get install nodejs 安装git实际上deepin已经安装了git，但是这里还是要列一下命令：1sudo apt-get install git 安装hexo1sudo npm install -g hexo -g表示全局安装。 npm命令在国内可能被墙，所以使用淘宝镜像后再执行上面命令：1npm install -g cnpm --registry=https://registry.npm.taobao.org 之后所以的npm都需要用cnpm代替。 初始化文件夹在一个适当的地方1234mkdir blogcd blog// 初始化hexo init 这里有一段较长的时间等待。 安装github工具1cnpm install hexo-deployer-git --save 配置文件这里不详细介绍了，所有的配置都跟win10的一样。 详细可以翻我以前的文章。 发布到github1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 传送门:ubuntu下使用hexo搭建博客小白教你在Ubuntu上用Hexo搭建博客托管到github","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"},{"name":"deepin","slug":"deepin","permalink":"/tags/deepin/"},{"name":"hexo","slug":"hexo","permalink":"/tags/hexo/"}]},{"title":"windows中python读取路径的使用","slug":"windows中python读取路径的使用","date":"2017-10-26T15:40:14.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/26/windows中python读取路径的使用/","link":"","permalink":"/2017/10/26/windows中python读取路径的使用/","excerpt":"由于我是主攻前端的，一般的页面开发会在windons系统上。然而有不得不写后端的时候，比如前端需要api进行调试。我实际学习的时候，我发现python读取文件在Linux和windows的行为不一样。","text":"由于我是主攻前端的，一般的页面开发会在windons系统上。然而有不得不写后端的时候，比如前端需要api进行调试。我实际学习的时候，我发现python读取文件在Linux和windows的行为不一样。 首先，”/“左倾斜是正斜杠,”\\”右倾斜是反斜杠,可以记为：除号是正斜杠一般来说对于目录分隔符，Unix和Web用正斜杠/，Windows用反斜杠，但是现在Windows 目录中的斜杠们python读文件需要输入的目录参数，列出以下例子：1234path = r\"C:\\Windows\\temp\\readme.txt\"path1 = r\"c:\\windows\\temp\\readme.txt\"path2 = \"c:\\\\windows\\\\temp\\\\readme.txt\"path3 = \"c:/windows/temp/readme.txt\" 打开文件函数open()中的参数可以是path也可以是path1、path2、path3。 path：”\\”为字符串中的特殊字符，加上r后变为原始字符串，则不会对字符串中的”\\t”、”\\r”进行字符串转义 path1：大小写不影响windows定位到文件 path3：用正斜杠做目录分隔符也可以转到对应目录，并且在python中path3的方式也省去了反斜杠\\转义的烦恼 正则表达式中的斜杠们正则表达式匹配反斜杠”\\”，为什么是”\\\\“或是 r”\\“呢？ 因为在正则表达式中\\为特殊符号，为了取消它在正则表达式中的特殊意义需要加一个\\就变成了\\，但是问题又来了，\\也是字符串中的特殊字符，所以又要分别对两个\\取消其特殊意义，即为\\\\。Python中有一个原始字符串操作符，用于那些字符串中出现特殊字符，在原始字符串中，没有转义字符和不能打印的字符。这样就可以取消了\\在字符串中的转义功能，即r”\\“。 传送门： python 对反斜杠的处理问题","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"python3","slug":"python3","permalink":"/tags/python3/"}]},{"title":"flask中file.save小坑","slug":"flask中file-save小坑","date":"2017-10-26T15:20:04.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/10/26/flask中file-save小坑/","link":"","permalink":"/2017/10/26/flask中file-save小坑/","excerpt":"最近挖了文件上传的坑，刚开始就遇到了小坑，花了我很多时间去专研这个问题。","text":"最近挖了文件上传的坑，刚开始就遇到了小坑，花了我很多时间去专研这个问题。 flask文档上面有关上传文件的实例，我copy下来，放在本地运行。1234567891011121314151617181920212223242526272829303132import osfrom flask import Flask, request, redirect, url_forfrom werkzeug import secure_filenameUPLOAD_FOLDER = '/path/to/the/uploads'ALLOWED_EXTENSIONS = set(['txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'])app = Flask(__name__)app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDERdef allowed_file(filename): return '.' in filename and \\ filename.rsplit('.', 1)[1] in ALLOWED_EXTENSIONS@app.route('/', methods=['GET', 'POST'])def upload_file(): if request.method == 'POST': file = request.files['file'] if file and allowed_file(file.filename): filename = secure_filename(file.filename) file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename)) return redirect(url_for('uploaded_file', filename=filename)) return ''' &lt;!doctype html&gt; &lt;title&gt;Upload new File&lt;/title&gt; &lt;h1&gt;Upload new File&lt;/h1&gt; &lt;form action=\"\" method=post enctype=multipart/form-data&gt; &lt;p&gt;&lt;input type=file name=file&gt; &lt;input type=submit value=Upload&gt; &lt;/form&gt; ''' 结果出现no such file or directory之类的文字，python是很明确地说明是save.file函数保存文件路径出了问题。 实际上这个问题网上很多帖子，然而答案很模糊。实际问题在于就是file.save只接受绝对路径。这个不管是Linux还是windows都是一样的。 传送门：记录一个Flask文件上传的小坑","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"flask","slug":"flask","permalink":"/tags/flask/"}]},{"title":"四种常见的POST提交数据方式","slug":"四种常见的POST提交数据方式","date":"2017-10-26T11:13:59.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/26/四种常见的POST提交数据方式/","link":"","permalink":"/2017/10/26/四种常见的POST提交数据方式/","excerpt":"最近看了一篇文章，相当有启发性，它解决了我对http请求中数据传输格式的困惑。在未来的表单页面制作，通过设置表单enctype属性能够实现更多的功能。上面也提及到json的前端设置，我觉得很有必要做做记录。","text":"最近看了一篇文章，相当有启发性，它解决了我对http请求中数据传输格式的困惑。在未来的表单页面制作，通过设置表单enctype属性能够实现更多的功能。上面也提及到json的前端设置，我觉得很有必要做做记录。 title说有四种常见的POST提交数据方式，其实有五种，最后一种不常见而已 这里说到的POST方式，都可以作为数据的描述，使用ajax提交给服务器。 application/x-www-form-urlencoded这应该是最常见的POST提交数据方式了。 浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 multipart/form-data这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值。直接来看一个请求示例：12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"text\"title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=\"file\"; filename=\"chrome.png\"Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段原生 form 表单也只支持这两种方式。但是随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。 application/jsonapplication/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。1234POST http://www.example.com HTTP/1.1Content-Type: application/json;charset=utf-8&#123;\"title\":\"test\",\"sub\":[1,2,3]&#125; text/xml123456789101112POST http://www.example.com HTTP/1.1Content-Type: text/xml&lt;!--?xml version=\"1.0\"?--&gt;&lt;methodcall&gt; &lt;methodname&gt;examples.getStateName&lt;/methodname&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/params&gt;&lt;/methodcall&gt; 我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。 text/plain在菜鸟教程的描述是： 将空格转换为 “+” 符号，但不编码特殊字符。 其实实际开发中用得非常少，而且资料也不多，在这里不介绍了。 传送门： application/json 四种常见的 POST 提交数据方式","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"表单","slug":"表单","permalink":"/tags/表单/"},{"name":"html","slug":"html","permalink":"/tags/html/"}]},{"title":"python3 datetime与字符串的转换","slug":"python3-datetime与字符串的转换","date":"2017-10-25T14:58:06.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/10/25/python3-datetime与字符串的转换/","link":"","permalink":"/2017/10/25/python3-datetime与字符串的转换/","excerpt":"写后台脚本的时候遇到了，mysql输出给pymysql的数据类型为datetime，而json不能直接将datetime对象转化为string，所以需要通过显式转换将datetime转换为string。","text":"写后台脚本的时候遇到了，mysql输出给pymysql的数据类型为datetime，而json不能直接将datetime对象转化为string，所以需要通过显式转换将datetime转换为string。 datetime =&gt; string12345import datetimedate=datetime.datetime.now()str=date.strftime(\"%Y-%m-%d %H:%M:%S\")str # =&gt; '2017-10-25 23:04:32' string =&gt; datetime1234import timestr = '2012-08-29 19:45:57'date = time.strptime(str, \"%Y-%m-%d %H:%M:%S\") 在这里有一点甚是奇怪在本地win10上调试，mysql输出的是datetime对象，但是在Ubuntu14上，mysql的datetime输出的东西可以被json化。关于这个差异，博主在写这篇文章的时候，也没能解决。如果有人看到这篇文字，知道原因，可以发邮件给我。 email: 775014077@qq.com 传送门： python time 和datetime类型转换，字符串型变量转成日期型变量 python datetime与字符串互转","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"python3","slug":"python3","permalink":"/tags/python3/"}]},{"title":"Ubuntu14.05彻底卸载mysql","slug":"Ubuntu14-05彻底卸载mysql","date":"2017-10-25T14:31:20.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/25/Ubuntu14-05彻底卸载mysql/","link":"","permalink":"/2017/10/25/Ubuntu14-05彻底卸载mysql/","excerpt":"我弄mysql的时候把mysql服务停了，发现有些依赖mysql的功能在Mysql服务重启之后就出了点问题。折腾了许久，愤怒之下决定删mysql再重装，可是我发现mysql卸载一点都不容易。特地写下blog,方便以后使用。","text":"我弄mysql的时候把mysql服务停了，发现有些依赖mysql的功能在Mysql服务重启之后就出了点问题。折腾了许久，愤怒之下决定删mysql再重装，可是我发现mysql卸载一点都不容易。特地写下blog,方便以后使用。 参考了许多文章，只有这一篇可行。（略有改动） mysql5.7 Ubuntu14 停止mysql服务1sudo /etc/init.d/mysql stop 删除mysql的数据文件1sudo rm /var/lib/mysql/ -R 删除mysql的配置文件1sudo rm /etc/mysql/ -R 自动卸载mysql（包括server和client）12sudo apt-get autoremove mysql* --purgesudo apt-get remove apparmor 检查是否卸载干净1dpkg -l | grep mysql # 若没有返回，说明已完成卸载 接下来安装就是件简单的事情啦1sudo apt-get install mysql-server mysql-client 这样默认安装的是mysql 5.5的版本，后续尝试安装mysql5.7，稍后补充5.7的安装。 传送门： mysql-ubuntu14.04彻底卸载mysql","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"mysql","slug":"mysql","permalink":"/tags/mysql/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"}]},{"title":"Ubuntu14mysq5.7不支持中文问题","slug":"Ubuntu14mysq5-7不支持中文问题","date":"2017-10-25T12:48:51.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/10/25/Ubuntu14mysq5-7不支持中文问题/","link":"","permalink":"/2017/10/25/Ubuntu14mysq5-7不支持中文问题/","excerpt":"不得不说，用mysql坑很多，首先就是编码问题。按照网上搜到的答案来处理，很多次我都不能restart mysql了。最后发现是版本问题，在这里我得做文章记录一下。","text":"不得不说，用mysql坑很多，首先就是编码问题。按照网上搜到的答案来处理，很多次我都不能restart mysql了。最后发现是版本问题，在这里我得做文章记录一下。 mysql本身是不支持中文的，这个我在win10搭建的服务器也碰到过。想要mysql支持中文，就需要更改它的设置。 请看完这篇文章再动手 mysql5.7 Ubuntu14.05 首先停下mysql服务：1sudo /etc/init.d/mysql stop 然后用gedit打开mysql配置文件1sudo gedit /etc/mysql/my.cnf [client]下添加：1default-character-set=utf8 [mysqld]下添加：1default-character-set=utf8 保存退出 重启mysql服务1sudo service mysql restart 然而…1Job failed to start 问题在哪呢？ 可能是版本的问题，查5.5以后的版本对字符编码方式修改的办法，发现[mysqld]修改方法变了： [mysqld]下添加的应该为：123character-set-server=utf8collation-server=utf8_general_ci 保存退出1sudo service mysql restart 成功 查看字符集1234567891011121314mysql&gt; show variables like '%char%';+--------------------------+----------------------------+| Variable_name | Value |+--------------------------+----------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | /usr/share/mysql/charsets/ |+--------------------------+----------------------------+8 rows in set (0.00 sec) 传送们： 参考资料1——Ubuntu15下mysql5.6.25解决不支持中文的办法 参考资料2——修改mysql字符编码出现Job failed to start解决办法 参考资料3——Ubuntu MySQL插入中文出错","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"/tags/mysql/"}]},{"title":"CSS3中user-select的使用","slug":"CSS3中user-select的使用","date":"2017-10-22T07:25:33.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/22/CSS3中user-select的使用/","link":"","permalink":"/2017/10/22/CSS3中user-select的使用/","excerpt":"","text":"语法：user-select：none | text | all | element12345默认值：text适用于：除替换元素外的所有元素继承性：无动画性：否计算值：指定值 取值：12345678none：文本不能被选择text：可以选择文本all：当所有内容作为一个整体时可以被选择。如果双击或者在上下文上点击子元素，那么被选择的部分将是以该子元素向上回溯的最高祖先元素。element：可以选择文本，但选择范围受元素边界的约束 说明：设置或检索是否允许用户选中文本。 IE6-9不支持该属性，但支持使用标签属性 onselectstart=”return false;” 来达到 user-select:none 的效果；Safari和Chrome也支持该标签属性； 直到Opera12.5仍然不支持该属性，但和IE6-9一样，也支持使用私有的标签属性 unselectable=”on” 来达到 user-select:none 的效果；unselectable 的另一个值是 off； 除Chrome和Safari外，在其它浏览器中，如果将文本设置为 -ms-user-select:none;，则用户将无法在该文本块中开始选择文本。不过，如果用户在页面的其他区域开始选择文本，则用户仍然可以继续选择将文本设置为 -ms-user-select:none; 的区域文本； 对应的脚本特性为userSelect。 实例：123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;user-select_CSS参考手册_web前端开发参考手册系列&lt;/title&gt;&lt;meta name=\"author\" content=\"Joy Du(飘零雾雨), dooyoe@gmail.com, www.doyoe.com\" /&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt;&lt;style&gt;.test&#123;padding:10px;-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none;background:#eee;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"test\" onselectstart=\"return false;\" unselectable=\"on\"&gt;选择我试试，你会发现怎么也选择不到我，哈哈哈哈&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 传说门user-select","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"jquery插件blindify详解","slug":"jquery插件blindify详解","date":"2017-10-22T05:58:19.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/10/22/jquery插件blindify详解/","link":"","permalink":"/2017/10/22/jquery插件blindify详解/","excerpt":"百叶窗插件，因为使用的是jquery，所以兼容大部分浏览器，ie兼容9+。","text":"百叶窗插件，因为使用的是jquery，所以兼容大部分浏览器，ie兼容9+。 简介 Blindify 是一个基于 jQuery 的百叶窗幻灯片插件，它能够非常方便的制作一个漂亮的百叶窗效果，你还可以设置百叶窗的片数、间隔、宽度、高度以及各种动画效果的时间和百叶窗的方向——水平或垂直。 兼容jQuery 兼容兼容 1.4+。 浏览器兼容 使用方法1、 引入文件123&lt;link rel=\"stylesheet\" href=\"css/blindify.min.css\"&gt;&lt;script src=\"js/jquery-1.8.3.min.js\"&gt;&lt;/script&gt;&lt;script src=\"js/jquery.blindify.min.js\"&gt;&lt;/script&gt; 2、 HTML12345678&lt;div id=\"blindify\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/photo_1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/photo_2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/photo_3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/photo_4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 或者带有链接：12345678&lt;div id=\"blindify\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"http://www.dowebok.com/\"&gt;&lt;img src=\"images/photo_1.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.dowebok.com/\"&gt;&lt;img src=\"images/photo_2.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.dowebok.com/\"&gt;&lt;img src=\"images/photo_3.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://www.dowebok.com/\"&gt;&lt;img src=\"images/photo_4.jpg\" alt=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 3、JavaScript123$(function()&#123; $('#blindify').blindify();&#125;); 配置 属性/方法 类型 默认值 说明 numberOfBlinds 整数 20 百叶窗叶片个数 slideVisibleTime 整数 2000 每个幻灯片的停留时间，不包括动画时间，以毫秒为单位 color 字符串 #000000 幻灯片背景颜色（十六进制颜色） margin 整数 2 百叶窗之间的距离，以像素（px）为单位。注意：其实是每个百叶窗的边框，所以如果想设置距离为10px，只需设置一半5px width 整数 960 容器的宽度，应与图片的宽度一样，以像素为单位 height 整数 600 容器的高度，应与图片的宽度一样，以像素为单位 gap 整数 100 百叶窗与容器边缘的距离范围，以像素为单位 animationSpeed 整数 100 幻灯片动画过度时间 delayBetweenSlides 整数 500 每个幻灯片切换之间的间隔，以毫秒为单位 hasLinks 布尔值 false 是否有链接 orientation 字符串 vertical 百叶窗的方向，可选水平（horizontal）或垂直（vertical），默认为垂直 startClosed 布尔值 false 百叶窗开始时是否关闭 firstOpenDelay 整数 500 startClosed 为 true 时，百叶窗延迟打开时间，单位为毫秒","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"/tags/jquery/"},{"name":"jquery插件","slug":"jquery插件","permalink":"/tags/jquery插件/"}]},{"title":"css更改表单控件光标颜色","slug":"css更改表单控件光标颜色","date":"2017-10-21T16:35:50.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/10/22/css更改表单控件光标颜色/","link":"","permalink":"/2017/10/22/css更改表单控件光标颜色/","excerpt":"看到一个比较新颖的文章，记录一下。","text":"看到一个比较新颖的文章，记录一下。 一般表单控件光标的颜色跟color属性是一致的。 如果想仅仅改变光标颜色，需要特殊的CSS设置。 一直以来要实现这样的效果都是依靠模拟来实现。主要借助于CSS的-webkit-text-fill-color让文本变成镂空的，即把其设置为transparent，记住了，不是直接将color的值设置为transparent。除此之外，还需要借助text-shadow`的威力。直接上代码吧：12345.form-control &#123; color: red !important; text-shadow: 0px 0px 0px #495057; -webkit-text-fill-color: transparent;&#125; 到今天为止，我们不需要这么蛋疼了。CSS提供了一个属性caret-color，可以直接让我们控制input和textarea控件的光标颜色，甚至是可编辑的HTML元素，像这样的&lt;div contenteditable&gt;。如此一来，只需要在样式中添加：123456input,textarea,[contenteditable] &#123; color: #495057; /* 文本颜色 */ caret-color: red; /* 光标颜色 */&#125; caret-color较三行代码兼容性差些。 传送门：如何改变表单控件光标颜色","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"CSS3弹性盒子Flex Box","slug":"CSS3弹性盒子Flex-Box","date":"2017-10-20T16:52:35.000Z","updated":"2018-04-10T03:45:06.000Z","comments":true,"path":"2017/10/21/CSS3弹性盒子Flex-Box/","link":"","permalink":"/2017/10/21/CSS3弹性盒子Flex-Box/","excerpt":"CSS3中flexBox其实也是一个大的领域，下面我为flexBox做简单的归纳。","text":"CSS3中flexBox其实也是一个大的领域，下面我为flexBox做简单的归纳。 CSS3 弹性盒子(Flex Box)","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"CSS3收集","slug":"CSS3收集","date":"2017-10-20T16:41:41.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/10/21/CSS3收集/","link":"","permalink":"/2017/10/21/CSS3收集/","excerpt":"收集了一些比较好、有价值的CSS组件源码，供学习使用。","text":"收集了一些比较好、有价值的CSS组件源码，供学习使用。 按钮 鼠标移动到按钮上后添加箭头标记 波纹效果 按压效果 图片 响应式卡片 图片模态框 幻灯片 制作简单的响应式幻灯片 Blindify – jQuery百叶窗幻灯片插件","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"讨论CSS伪元素的父元素","slug":"讨论CSS伪元素的父元素","date":"2017-10-20T15:33:52.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/10/20/讨论CSS伪元素的父元素/","link":"","permalink":"/2017/10/20/讨论CSS伪元素的父元素/","excerpt":"为什么要讨论css中伪元素的父元素呢？因为很多时候需要用到position属性，而position属性效果跟父元素直接挂钩。这篇文章就是讨论CSS中伪元素的父元素到底是谁？","text":"为什么要讨论css中伪元素的父元素呢？因为很多时候需要用到position属性，而position属性效果跟父元素直接挂钩。这篇文章就是讨论CSS中伪元素的父元素到底是谁？ 什么是伪元素？参考菜鸟教程列出所有的伪元素 :link :visited :active :focus :first-letter :first-line :first-child :before :after lang(language) 测试1以:first-letter写一段html和css：1234567891011// html&lt;p id=\"test\"&gt;假猪套天下第一&lt;/p&gt;// css&lt;style&gt;#test &#123; font-size: 15px; &#125;#test:first-letter &#123; font-size: 20px;&#125;&lt;/style&gt; 在浏览器中测试以上代码： 测试结果 很明显，#test:first-letter覆盖了#test的CSS样式。 所以#test:first-letter是#test的子元素。 神马？证明还不够充分？再来！ 测试2拿菜鸟教程的一个例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;style&gt;.button &#123; display: inline-block; border-radius: 4px; background-color: #f4511e; border: none; color: #FFFFFF; text-align: center; font-size: 28px; padding: 20px; width: 200px; transition: all 0.5s; cursor: pointer; margin: 5px;&#125;.button span &#123; cursor: pointer; display: inline-block; position: relative; transition: 0.5s;&#125;.button span:after &#123; content: '»'; position: absolute; opacity: 0; top: 0; right: -20px; transition: 0.5s;&#125;.button:hover span &#123; padding-right: 25px;&#125;.button:hover span:after &#123; opacity: 1; right: 0;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;按钮动画&lt;/h2&gt;&lt;button class=\"button\" style=\"vertical-align:middle\"&gt;&lt;span&gt;Hover&lt;/span&gt;&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 仔细观察123.button span:after &#123; position: absolute;&#125; 和123.button span &#123; position: relative;&#125; 就relative和absolute的前后关系，可以直接表明span是span:after的父元素。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"},{"name":"原创","slug":"原创","permalink":"/tags/原创/"}]},{"title":"CSS3新元素使用列表","slug":"CSS3新元素使用列表","date":"2017-10-19T16:01:12.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/10/20/CSS3新元素使用列表/","link":"","permalink":"/2017/10/20/CSS3新元素使用列表/","excerpt":"最近想做一些UI组件，稍微复习一下CSS3的内容。","text":"最近想做一些UI组件，稍微复习一下CSS3的内容。 边框border-radiusbox-shadow1box-shadow: 10px 10px 5px #888888; border-image123-webkit-border-image: url(border.png) 30 round; /* Safari 3.1-5 */-o-border-image: url(border.png) 30 round; /* Opera 11-12.1 */border-image: url(border.png) 30 round; 圆角border-radius 背景background-imagebackground-sizebackground-origin12background-size:100% 100%;background-origin:content-box; background-clip1background-clip: content-box; 渐变（Gradients）传送门 文本效果text-shadow1text-shadow: 5px 5px 5px #FF0000; box-shadow1box-shadow: 10px 10px grey; text-overflow1text-overflow:ellipsis; word-wrap1word-wrap:break-word; word-break12word-break:keep-all;word-break:break-all; @font-face 规则123456@font-face&#123; font-family: myFirstFont; src: url(sansation_bold.woff); font-weight:bold;&#125; 2D 转换translate()123transform: translate(50px,100px);-ms-transform: translate(50px,100px); /* IE 9 */-webkit-transform: translate(50px,100px); /* Safari and Chrome */ rotate()123transform: rotate(30deg);-ms-transform: rotate(30deg); /* IE 9 */-webkit-transform: rotate(30deg); /* Safari and Chrome */ scale()123-ms-transform:scale(2,3); /* IE 9 */-webkit-transform: scale(2,3); /* Safari */transform: scale(2,3); /* 标准语法 */ skew()123transform: skew(30deg,20deg);-ms-transform: skew(30deg,20deg); /* IE 9 */-webkit-transform: skew(30deg,20deg); /* Safari and Chrome */ matrix()123transform:matrix(0.866,0.5,-0.5,0.866,0,0);-ms-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* IE 9 */-webkit-transform:matrix(0.866,0.5,-0.5,0.866,0,0); /* Safari and Chrome */ 3D方法rotateX()12transform: rotateX(120deg);-webkit-transform: rotateX(120deg); /* Safari 与 Chrome */ rotateY() 过渡12transition: width 2s, height 2s, transform 2s;-webkit-transition: width 2s, height 2s, -webkit-transform 2s; 所有属性123456789transition-property: width;transition-duration: 1s;transition-timing-function: linear;transition-delay: 2s;/* Safari */-webkit-transition-property:width;-webkit-transition-duration:1s;-webkit-transition-timing-function:linear;-webkit-transition-delay:2s; @keyframes 规则动画123456789101112131415161718192021222324252627282930313233343536// 应用div&#123; animation: myfirst 5s linear 2s infinite alternate; /* Safari 与 Chrome: */ -webkit-animation: myfirst 5s linear 2s infinite alternate;&#125;// 简写@keyframes myfirst&#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125;@-webkit-keyframes myfirst /* Safari 与 Chrome */&#123; from &#123;background: red;&#125; to &#123;background: yellow;&#125;&#125;// 详细@keyframes myfirst&#123; 0% &#123;background: red; left:0px; top:0px;&#125; 25% &#123;background: yellow; left:200px; top:0px;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0px; top:200px;&#125; 100% &#123;background: red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari 与 Chrome */&#123; 0% &#123;background: red; left:0px; top:0px;&#125; 25% &#123;background: yellow; left:200px; top:0px;&#125; 50% &#123;background: blue; left:200px; top:200px;&#125; 75% &#123;background: green; left:0px; top:200px;&#125; 100% &#123;background: red; left:0px; top:0px;&#125;&#125; 多列column-count column-gap column-rule-style column-rule-width column-rule-color column-rule column-span column-width 用户界面resize1resize:both; box-sizing12box-sizing:border-box;-moz-box-sizing:border-box; /* Firefox */ outline-offset1outline-offset:10px; 弹性盒子(Flex Box)传送门 媒体查询12345@media screen and (min-width: 480px) &#123; body &#123; background-color: lightgreen; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS3","slug":"CSS3","permalink":"/tags/CSS3/"}]},{"title":"JS原生on和addEventListener优缺点","slug":"JS原生on和addEventListener优缺点","date":"2017-10-19T15:29:51.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/19/JS原生on和addEventListener优缺点/","link":"","permalink":"/2017/10/19/JS原生on和addEventListener优缺点/","excerpt":"一直以来编程的时候对on和addEventListener的选择摇摆不定，这里稍微理清下知识点，解决实际开发中语句选择问题。","text":"一直以来编程的时候对on和addEventListener的选择摇摆不定，这里稍微理清下知识点，解决实际开发中语句选择问题。 转载 为什么需要addEventListener？ 先来看一个片段： html代码1&lt;div id=\"box\"&gt;vinson-sheep&lt;/div&gt; 用on的代码1234567891011window.onload = function()&#123; var box = document.getElementById(\"box\"); box.onclick = function()&#123; console.log(\"我是box1\"); &#125; box.onclick = function()&#123; box.style.fontSize = \"18px\"; console.log(\"我是box2\"); &#125;&#125; 运行结果：“我是box2” 看到了吧，第二个onclick把第一个onclick给覆盖了，虽然大部分情况我们用on就可以完成我们想要的结果，但是有时我们又需要执行多个相同的事件，很明显如果用on完成不了我们想要的，那不用猜，你们肯定知道了，对！addEventListener可以多次绑定同一个事件并且不会覆盖上一个事件。 用addEventListener的代码1234567891011window.onload = function()&#123; var box = document.getElementById(\"box\"); box.addEventListener(\"click\",function()&#123; console.log(\"我是box1\"); &#125;) box.addEventListener(\"click\",function()&#123; console.log(\"我是box2\"); &#125;)&#125; 运行结果：我是box1 我是box2 addEventListenert方法第一个参数填写事件名，注意不需要写on，第二个参数可以是一个函数，第三个参数是指在冒泡阶段还是捕获阶段处理事件处理程序,如果为true代表捕获阶段处理,如果是false代表冒泡阶段处理，第三个参数可以省略，大多数情况也不需要用到第三个参数,不写第三个参数默认false 第三个参数的使用 有时候的情况是这样的:12345&lt;body&gt; &lt;div id=\"box\"&gt; &lt;div id=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 如果我给box加click事件，如果我直接单击box没有什么问题，但是如果我单击的是child元素，那么它是怎么样执行的？（执行顺序）12345678910box.addEventListener(\"click\",function()&#123; console.log(\"box\");&#125;)child.addEventListener(\"click\",function()&#123; console.log(\"child\");&#125;) 执行的结果： child box 也就是说，默认情况事件是按照事件冒泡的执行顺序进行的。 如果第三个参数写的是true，则按照事件捕获的执行顺序进行的。 事件冒泡执行过程： 从最具体的的元素（你单击的那个元素）开始向上开始冒泡，拿我们上面的案例讲它的顺序是：child-&gt;box 事件捕获执行过程： 从最不具体的元素（最外面的那个盒子）开始向里面冒泡，拿我们上面的案例讲它的顺序是：box-&gt;child 以上这篇全面了解addEventListener和on的区别就是小编分享给大家的全部内容了，希望能给大家一个参考，也希望大家多多支持脚本之家。 参考文章——全面了解addEventListener和on的区别","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"}]},{"title":"Javascript中defer和async","slug":"Javascript中defer和async","date":"2017-10-15T16:29:54.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/16/Javascript中defer和async/","link":"","permalink":"/2017/10/16/Javascript中defer和async/","excerpt":"说实话defer和async属性是很少时候会用上。这篇文章就是讲述它如何如何难被用上。","text":"说实话defer和async属性是很少时候会用上。这篇文章就是讲述它如何如何难被用上。 知识点文档解析在web中指的是html文档被下载后由浏览器引擎解析为DOM节点树的过程。 阻塞在web是指html文档解析受阻。当一个http请求被响应，首先下载html文件，再解析html文件。也就是说，html文件是肯定会被下载的，但是解析可能会受阻。 这里引用犀牛书的一段话： 当HTML解析器遇到&lt;script&gt;元素时，它默认必须先执行脚本，然后再恢复文档的解析和渲染。这对于内联脚本没什么问题（这里大概是指不需要下载直接执行），但如果脚本源代码是一个由src属性指定的外部文件，这意味着脚本后面的文档部分在下载和执行脚本之前，都不会出现在浏览器中。 作者在这里的表述很模糊，所谓“不会出现在浏览器中”，是指文档的文本内容已经载入，但是未被浏览器引擎解析为DOM树，而DOM树的生成是受Javascript代码执行的影响的，Javascript代码会“阻塞”页面UI的渲染。 脚本的执行只在默认情况下是同步和阻塞的。 defer和async12&lt;script defer src=\"deferred.js\"&gt;&lt;/script&gt;&lt;script async src=\"async.js\"&gt;&lt;/script&gt; defer和async属性都像在告诉浏览器链接进来的脚本不会使用document.write()，也不会生成文档内容，因此浏览器可以在下载脚本时候继续解析和渲染文档。 defer属性使得浏览器延迟脚本的执行，直到文档的载入和解析完成，并可以操作。 async属性使得浏览器可以尽快地执行脚本，而不用在下载脚本时阻塞文档解析。 如果&lt;script&gt;标签同时有两个属性，同时支持两者的浏览器会遵从async属性并忽略defer属性。 分析无论是defer和async属性，只有在脚本下载过程中可能阻塞文档解析的过程中才能够发挥作用，意味着&lt;script&gt;元素需要出现在文档一般元素之前（非html和body元素）。 在html和Javascript代码分离的哲学思想下，我们大多会把&lt;script&gt;元素放在文档底部，html和body元素之前。这时候defer和async属性就不能发挥作用了，因为js是同步解析的，当解析到&lt;script&gt;时，整个DOM树几乎已经解析完毕，并且渲染完成。 总的来讲，这两个元素用得不多，当&lt;script&gt;放在head时可能会用上。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"html+css+js前端学习网站推荐","slug":"html-css-js前端学习网站推荐","date":"2017-10-14T14:52:17.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/14/html-css-js前端学习网站推荐/","link":"","permalink":"/2017/10/14/html-css-js前端学习网站推荐/","excerpt":"推荐一些前端学习网站。","text":"推荐一些前端学习网站。 自学前端快一年了，就在这和大伙儿稍做分享吧。 HTML&amp;CSS学习网站： W3schoolhttp://www.w3school.com.cn/index.html 这个不用多介绍 30天学习HTML&amp;CSShttp://webdesign.tutsplus.com/courses/30-days-to-learn-html-css 有视频，但是英文水平需要高 前端人的俱乐部http://f2er.club/ 感觉还不错，虽然我不经常上 编码规范http://zoomzhao.github.io/code-guide/ 编码规范很重要 在你有了一定的HTML&amp;CSS基础后，我再介绍以下网站： CSS3动画http://webdesign.tutsplus.com/tutorials/creating-a-collection-of-css3-animated-pre-loaders--cms-21978 csdn博客http://m.blog.csdn.net/Column/Index?Channel=web&amp;Type=New w3chttp://www.w3cplus.com/ 空智-博客园http://www.cnblogs.com/tugenhua0707/ 智能社的视频教程http://www.zhinengshe.com/video.html dowebokhttp://www.dowebok.com/ 主要是jQuery githubhttps://github.com/ 这个不用说 codepenhttp://codepen.io/ 我超喜欢的一个网站 到了这里，你也许想动手建个属于自己的网页，你又想问有哪些漂亮的网页？ reeoohttp://reeoo.com/ 超多漂亮的网页 httpsterhttp://httpster.net/ 你或许还想要些psd文件： http://www.uipixels.com/page/2/ http://www.bestpsdfreebies.com/ 作者：小老师链接：https://www.zhihu.com/question/46939006/answer/103731361来源：知乎","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"学习指导","slug":"学习指导","permalink":"/tags/学习指导/"}]},{"title":"js中RegExp引用方法详解","slug":"js中RegExp引用方法详解","date":"2017-10-14T10:43:13.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/14/js中RegExp引用方法详解/","link":"","permalink":"/2017/10/14/js中RegExp引用方法详解/","excerpt":"归纳总结一些能够引用RegExp的方法，包括正则表达式对象的属性。","text":"归纳总结一些能够引用RegExp的方法，包括正则表达式对象的属性。 String方法 search() replace() match() split() RegExp对象属性 source global ingoreCase multiline lastIndex RegExp对象方法 exec() test() 详解lastIndexlastIndex是一个可读/可写的整数。在全局模式下使用exec()或者test()，会调用lastIndex属性，如果它找到一个匹配结果，那么它就立即设置lastIndex为当前匹配字串的结束位置。 exec()和test()其实这两个函数行为是一致的，在全局模式g下能够引用RegExp对象的lastIndex属性。我们可以看下面的例子：12345678910// 定一个字符串var s = \"123\";// 声明一个正则表达式var pattern = /\\d/g;// 匹配的是1，返回truepattern.test(s);// 匹配的是2，返回\"2\"pattern.exec(s)// lastIndex经过两次递增后为2pattern.lastIndex; // =&gt; 2 值得注意的是，全局模式下使用test()或者exec()时，如果没有匹配到任何内容，则返回null，同时lastIndex会自动刷新为0。当然lastIndex是可以显示更改的。 exec()和match()这两个函数在没有匹配项的时候会返回null，否则一律返回数组，即使只有一个匹配项。 exec()不能够一次得到所有匹配项。如果需要获取字符串所有的匹配项，需要在全局模式g下使用循环，这时候函数会自动调用lastIndex属性。当函数返回为null，证明已经遍历了整个字符串。 match()能够一次得到一个由所有匹配项得到的数组。分组()只要不影响正则表达式的逻辑，不会对输出结果个数造成影响。1234// 无分组\"abcabc\".match(/abc/g); // =&gt; [\"abc\", \"abc\"]// 分组\"abcabc\".match(/(abc)/g); // =&gt; [\"abc\", \"abc\"] 综合地说，exec()适合获取分组，match()适合一次获取所有的匹配项。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"RegExp","slug":"RegExp","permalink":"/tags/RegExp/"}]},{"title":"js正则表达式的多行模式和单行模式","slug":"js正则表达式的多行模式和单行模式","date":"2017-10-14T07:05:42.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/14/js正则表达式的多行模式和单行模式/","link":"","permalink":"/2017/10/14/js正则表达式的多行模式和单行模式/","excerpt":"参考了一些文章，对js正则表达式的多行模式和单行模式有了更深的了解。","text":"参考了一些文章，对js正则表达式的多行模式和单行模式有了更深的了解。 引言其实底部的文章已经把多行模式和单行模式的关系讲述得很透彻了，但是它是针对php和Expresso，在js环境下的正则表现会有差异。多行模式在犀牛书的描述其实也是相当简洁明了的： 修饰符“m”用以在多行模式中执行匹配，在这种模式下，如果检索的字符串包含多行，那么^和$锚字符除了匹配整个字符串的开始和结尾之外，还能匹配每行的开始和结尾。 书上这么说，但到底是怎么一种情况呢？ 文本保存的方式首先我们来思考一个问题，当我们在win上的txt文本上敲一个回车然后保存，那文件对回车的保存是如何实现的？ 比如我在这输入点东西 知识点：\\r为回车符，\\n为换行符。 在windows中，我们平常说的换行，实质上是先回车，后换行。 所以上图的文本等价于1abcde\\r\\n2abc\\r\\n3eeeee\\r\\n。 我们可以基于上面的讨论，在js中模拟多行文本。 测试真实的测试是需要调用本地或者网络文件，读取里面的内容再进行多行匹配。 为了便于测试，我们使用1abcde\\r\\n2abc\\r\\n3eeeee\\r\\n进行测试。 下面的测试代码：1234567891011&lt;script type=\"text/javascript\"&gt; var pattern = /^(\\d\\w+)$/mg; var item = \"1abcde\\r\\n2abc\\r\\n3eeeeee\"; var item1 = \"1abcde\\n2abc\\n3eeeeee\"; var item2 = \"1abcde\\r2abc\\r3eeeeee\"; console.log(item.match(pattern)); console.log(item1.match(pattern)); console.log(item2.match(pattern));&lt;/script&gt; 输出结果：[&quot;1abcde&quot;, &quot;2abc&quot;, &quot;3eeeeee&quot;] 分析： 如果你阅读了尾部的文章，你会发现输出结果差异非常大，后面会讨论这个问题。在这个例子中，我们分别测试了混合使用\\r\\n与单独使用\\r和\\n的情况，结果输出均为[&quot;1abcde&quot;, &quot;2abc&quot;, &quot;3eeeeee&quot;]。这表明，js多行模式下，\\n和\\r表现是相同的，^和$这两个锚元素都可以定位\\n和\\r前后。 对 . 符号的影响我们将上面的代码修改一下：123456789&lt;script type=\"text/javascript\"&gt; var pattern = /^.$/gm; var item = \"a\"; var item1 = \"\\n\"; var item2 = \"\\r\"; console.log(item.match(pattern)); console.log(item1.match(pattern)); console.log(item2.match(pattern));&lt;/script&gt; 输出结果：[&quot;a&quot;]、null、null。 那是不是表明多行模式下.不能匹配\\n\\r呢？别急，我们将代码再改改：1var pattern = /^.$/g; 输出结果：[&quot;a&quot;]、null、null。 结果令人有点惊讶，单双行模式下.的表现是一致的。如果查看尾部文章，可以发现测试结果与尾部文章的差异甚大。 为什么要做这个测试？因为参考文章提及到这个问题 结论 多行模式会影响^和$的匹配，而且对\\n和\\r的表现是一样的。 正则表达式中的.符号是不能够匹配\\n和\\r，无论是单行还是多行模式下。 php和Expresso对正则的实现与js的差异非常大，要理解语言的特殊性。 传送门： 正则表达式的多行模式与单行模式","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"原创","slug":"原创","permalink":"/tags/原创/"},{"name":"RegExp","slug":"RegExp","permalink":"/tags/RegExp/"}]},{"title":"markdown语法复习","slug":"markdown语法复习","date":"2017-10-13T21:04:23.000Z","updated":"2018-04-10T03:45:06.000Z","comments":true,"path":"2017/10/14/markdown语法复习/","link":"","permalink":"/2017/10/14/markdown语法复习/","excerpt":"最近写文章的时候老需要用markdown写表格的情况，一想到markdown表格需要很多|和-我就头疼了。写篇文章复习下。","text":"最近写文章的时候老需要用markdown写表格的情况，一想到markdown表格需要很多|和-我就头疼了。写篇文章复习下。 标题123# 一级标题## 二级标题### 三级标题 列表12345678910111.2.3.- a- b- c* a* b* c 引用1&gt; aaa 图片与链接123![]()&#123;ImgCap&#125;&#123;/ImgCap&#125;[]() 粗体与斜体12**strong***italic* 表格12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | :不同位置代表不同的对齐方式。 参考文章:Markdown——入门指南","categories":[{"name":"工具","slug":"工具","permalink":"/categories/工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"/tags/markdown/"}]},{"title":"JS正则表达式RegExp语法","slug":"JS正则表达式RegExp语法","date":"2017-10-13T19:49:35.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/14/JS正则表达式RegExp语法/","link":"","permalink":"/2017/10/14/JS正则表达式RegExp语法/","excerpt":"JS的正则表达式实际上是一套精密的选择器。实际上各种语言的正则表达式都十分相似，但当正则放在JS实现上就有细微的差异，这些差异会在文章中略微谈到。","text":"JS的正则表达式实际上是一套精密的选择器。实际上各种语言的正则表达式都十分相似，但当正则放在JS实现上就有细微的差异，这些差异会在文章中略微谈到。 文章大部分摘录自犀牛书 javascript中正则表达式使用RegExp对象表示，可以使用RegExp()构造函数来创建RegExp对象，不过RegExp对象更多是通过一种特殊的直接量语法来创建。1var pattern = /s$/; 语法直接量字符 字符 匹配 字母和数字字符 自身 \\o NUL字符（\\u0000） \\t 制表符（\\u0009） \\n 换行符（\\u000A） \\v 垂直制表符（\\u000B） \\f 换页符（\\u000C） \\r 回车符（\\u000D） \\xnn 由十六进制数nn指定的拉丁字符，例如，\\x0A等价于\\n \\cX 控制字符^X，例如，\\cJ等价于换行符\\n 在正则表达式中，许多标点符号具有特殊含义，它们是： ^ $ . * ? = ! : \\ / ( ) [ ] { } 表格中经常使用的应该是\\n,\\r。 字符类[]将直接量字符串单独放进方括号内就组成了字符类。 注意，有些字符类转义字符只能匹配ASCII字符，还没扩展到可以处理Unicode字符，但可以通过十六进制表示方法来显式定义Unicode字符类。 字符 匹配 […] 方括号内任意字符 [^…] 不在方括号内的任意字符 . 除换行符和其他Unicode行终止符之外的任意字符 \\w 任何ASCII字符组成的单词，等价于[a-zA-Z0-9] \\W 等价于[^a-zA-Z0-9] \\s 任何Unicode空白符 \\S 任何非Unicode空白符的字符，注意\\w和\\S不同 \\d 任何ASCII数字，等价于[0-9] \\D 除了ASCII数字之外的任何字符，等价于[^0-9] [\\b] 退格直接量(特例) 重复{} 字符 匹配 {n,m} 匹配前一项至少n次，但不能超过m次 {n,} 匹配前一项n次或者更多次 {n} 匹配前一项n次 ? {0,1} + {1,} * {0,} 非贪婪的重复上表列出的匹配重复字符是尽可能地多匹配，而且允许后续的正则表达式继续匹配。因此，我们称之为“贪婪的”匹配。我们同样可以使用正则表达式进行非贪婪匹配。只须在等匹配的字符后跟随一个问号即可：“??”、“+?”、“*?”或者“{1,5}?”。比如，正则表达式/a+/可以匹配一个或多个连续的字幕a。当使用“aaa”作为匹配时，正则表达式会匹配它的三个字符。但是/a+?/也可以匹配一个或多个连续字母a，但它尽可能少地匹配。我们同样将“aaa”作为匹配字符串，但后一个模式只能匹配一个a。 选择|、分组()和引用$选择|字符“|”用于分隔供选择的字符。例如，/ab|cd|ef/可以匹配字符串“ab”，也可以匹配字符串“cd,还可以匹配字符串“ef”。 分组()正则表达式中的圆括号有多种作用。 第一个作用是单独的项组合成子表达式，以便可以像处理一个独立的单元那样用“|”、“*”、“+”或者“?”等来对单元内的项进行处理。 圆括号的另一个作用是在完整的模式中定义子模式。 最后一个作用是允许在同一正则表达式的后部引用前面的子表达式。 关于最后一个作用：1/(['\"])[^'\"]*\\1/ \\1是对([&#39;&quot;])的引用。 值得注意的是，对正则表达式中前一个子表达式的引用，并不是指对子表达式模式的引用，而指的是与那个模式相匹配的文本的引用。所以，假如([&#39;&quot;])匹配到&quot;，则\\1指代的是&quot;，而不能是&#39;。 字符 含义 一竖 选择符 (…) 分组 (?:…) 只组合，把项组合到一个单元，但不记忆与改组相匹配的字符 引用$像\\b这样的元素不匹配某个可见的字符，它们指定匹配发生的合法位置。有时我们称这些元素为正则表达式的锚，因为它们将模式定位在搜索字符串的特定位置上。**最常用的锚元素是^，它用来匹配字符串的开始，锚元素$用以匹配字符串的结束。 字符 含义 ^ 匹配开头，在多行检索中，匹配一行的开头 $ 匹配字符串的结尾，在多行检索中，匹配一行的结尾 \\b 匹配边界 \\B 匹配非边界 (?=p) 零宽正向先行断言 (?!p) 零宽负向先行断言 具体看犀牛书p260~261 特别需要注意的是，js是不支持(?!p)。 \\b指代位于字符\\w和\\W之间的位置。 修饰符1/\\bjava\\b/i 修饰符“i”用以说明模式匹配是不区分大小写的。修饰符“g”说明模式匹配应该是全局的，也就是说，应该找出被检索字符串中所有的匹配。修饰符“m”用以在多行模式中执行匹配，在这种模式下，如果待检索的字符串包含多行，那么^和$锚字符除了匹配整个字符串的开头和结尾之外，还能匹配每行的开始和结尾。 关于多行模式，我会在下一篇文章中详解。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"RegExp","slug":"RegExp","permalink":"/tags/RegExp/"}]},{"title":"ES3和ES5中RegExp实例创建差异","slug":"ES3和ES5中RegExp实例创建差异","date":"2017-10-13T13:56:51.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/10/13/ES3和ES5中RegExp实例创建差异/","link":"","permalink":"/2017/10/13/ES3和ES5中RegExp实例创建差异/","excerpt":"犀牛书中揭示了不同ES标准下RegExp实例创建的差异，虽然这种差异是很难被应用在实际开发中的。不过了解一下也无妨。","text":"犀牛书中揭示了不同ES标准下RegExp实例创建的差异，虽然这种差异是很难被应用在实际开发中的。不过了解一下也无妨。 12// 正则表达式直接量var pattern = /s$/ 正则表达式直接量,ECMAScript 3规范规定，一个正则表达式直接量会在执行到它的时候转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript 5规范则做了相反的规定，同一段代码所代表的正则表达式直接量的每次运算都返回新对象。IE一直都是按照ECMAScript 5规范实现的，多数最新版本的浏览器也开始遵循ECMAScript 5，尽管目前该标准并未全面广泛推行。 要知道犀牛书已经很旧了，实际上主流的浏览器几乎都遵循ES 5，有的甚至全面实现ES 6。 犀牛书的作者在这里揭示了一种非常容易忽略的情况，比如，这段代码在Firefox 3.6和Firefox 4+中运行结果不一致：1234567891011function getRE() &#123; var re = /[a-z]/; re.foo = \"bar\"; return re;&#125;var reg = getRE(), re2 = getRE();console.log(reg == re2); // 在Firefox .6中返回true，在Firefox 4+中返回falsereg.foo = \"bar\";console.log(re2.foo); // 在Firefox 3.6中返回\"baz\"，在Firefox 4+返回\"bar\" 原因可以在ECMAScript 5规范第24页和第247页找到，也就是说在ECMAScript 3规范中，用正则表达式创建的RegExp对象会共享同一个实例，而在ECMAScript 5中则是两个独立的实例。而最新的Firefox 4、Chrome和Safari 5都遵循ECMAScript 5标准，以至于IE6~IE8都没有很好地遵循ECMAScript 3标准，不过在这个问题上反而处理对了。很明显ECMAScript 5的规范更符合开发者的期望。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"RegExp","slug":"RegExp","permalink":"/tags/RegExp/"},{"name":"ES标准","slug":"ES标准","permalink":"/tags/ES标准/"}]},{"title":"JS实现无限分页加载——原理图解(转)","slug":"JS实现无限分页加载——原理图解-转","date":"2017-10-13T03:45:54.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/13/JS实现无限分页加载——原理图解-转/","link":"","permalink":"/2017/10/13/JS实现无限分页加载——原理图解-转/","excerpt":"由于网页的执行都是单线程的，在JS执行的过程中，页面会呈现阻塞状态。因此，如果JS处理的数据量过大，过程复杂，可能会造成页面的卡顿。传统的数据展现都以分页的形式，但是分页的效果并不好，需要用户手动点击下一页，才能看到更多的内容。有很多网站使用 无限分页 的模式，即网页视窗到达内容底部就自动加载下一部分的内容…本篇就无限分页的实现模型，讲述其中奥妙。","text":"由于网页的执行都是单线程的，在JS执行的过程中，页面会呈现阻塞状态。因此，如果JS处理的数据量过大，过程复杂，可能会造成页面的卡顿。传统的数据展现都以分页的形式，但是分页的效果并不好，需要用户手动点击下一页，才能看到更多的内容。有很多网站使用 无限分页 的模式，即网页视窗到达内容底部就自动加载下一部分的内容…本篇就无限分页的实现模型，讲述其中奥妙。 原理图实现无限分页的过程大致如下： 视窗滚动到底部 触发加载，添加到现有内容的后面。 因此，可能会出现两种情况： 当页面的内容很少，没有出现滚动条。 当页面的内容很多，出现了滚动条。 针对这两种情况，需要理解几个概念： scrollHeight即真实内容的高度； clientHeight比较好理解，是视窗的高度，就是我们在浏览器中所能看到内容的高度； scrollTop是视窗上面隐藏掉的部分 实现的思路1. 如果真实的内容比视窗高度小，则一直加载到超过视窗2. 如果超过了视窗，则判断下面隐藏的部分的距离是否小于一定的值，如果是，则触发加载。（即滚动到了底部） 代码样例代码部分没有太多的内容，需要注意的是：1. 使用fixed定位加载框2. 使用setTimeout定时触发判断方法，频率可以自定义3. 通过 真实内容高度 - 视窗高度 - 上面隐藏的高度 &lt; 20，作为加载的触发条件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;无限翻页测试&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;script src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; #spinner&#123; position: fixed; top: 20px; left: 40%; display: block; color: red; font-weight: 900; background-color: rgba(80, 80, 90, 0.22); padding-top: 20px; padding-bottom: 20px; padding-left: 100px; padding-right: 100px; border-radius: 15px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"sample\"&gt; &lt;/div&gt; &lt;div id=\"spinner\"&gt; 正在加载 &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var index = 0; function lowEnough()&#123; var pageHeight = Math.max(document.body.scrollHeight,document.body.offsetHeight); var viewportHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight || 0; var scrollHeight = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0; // console.log(pageHeight); // console.log(viewportHeight); // console.log(scrollHeight); return pageHeight - viewportHeight - scrollHeight &lt; 20; &#125; function doSomething()&#123; var htmlStr = \"\"; for(var i=0;i&lt;10;i++)&#123; htmlStr += \"这是第\"+index+\"次加载&lt;br&gt;\"; &#125; $('#sample').append(htmlStr); index++; pollScroll();//继续循环 $('#spinner').hide(); &#125; function checkScroll()&#123; if(!lowEnough()) return pollScroll(); $('#spinner').show(); setTimeout(doSomething,900); &#125; function pollScroll()&#123; setTimeout(checkScroll,1000); &#125; checkScroll(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 个人总结 触发加载的条件始终是：真实内容高度 - 视窗高度 - 上面隐藏的高度 &lt; 20，只要把握好scrollHeight、scrollTop等属性就可以手动从写代码。 index加载内容变化的关键，如果需要让服务器返回数据，诸如评论内容等，将index提交给服务器，作为一组数据的索引。如果所有内容加载完毕，则将index设置为特定值，这样使用js就能够不再触发加载。 例子中使用了setTimeout,个人觉得使用setInterval会更好懂一些。但是它使用setTimeout也是很精妙，通过函数对这setTimeout互相调用，达到setInterval相同的效果。 本文精华所在是pageHeight、viewportHeight、scrollHeight的定义，尽管我觉得它命名上很不符合语义，但是代码还是相当严密。 document.documentElement.scrollTop在chrome是永远返回0的。 传送门： JS实现无限分页加载——原理图解","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"转载","slug":"转载","permalink":"/tags/转载/"},{"name":"前端组件开发","slug":"前端组件开发","permalink":"/tags/前端组件开发/"}]},{"title":"Javascript浏览器中的各种xxxHeight属性详解","slug":"Javascript浏览器中的各种xxxHeight属性详解","date":"2017-10-12T15:48:16.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/12/Javascript浏览器中的各种xxxHeight属性详解/","link":"","permalink":"/2017/10/12/Javascript浏览器中的各种xxxHeight属性详解/","excerpt":"曾经一度被浏览器中的各种高度弄得头晕眼花，今天特意查询了这方面的内容，终于搞懂了，决定写篇文章纪念一下scrollHeight、clientHeight、offsetHeigh、scrollTop、window.innerHeight、window.pageYOffset。","text":"曾经一度被浏览器中的各种高度弄得头晕眼花，今天特意查询了这方面的内容，终于搞懂了，决定写篇文章纪念一下scrollHeight、clientHeight、offsetHeigh、scrollTop、window.innerHeight、window.pageYOffset。 博主原创 文章提要： 滑动条的高度或宽度为17px 这里讨论的xxxHeight返回的都是数值 文章是以chrome测试作为结果，其他浏览器的说明是通过其他文章的描述总结得出。 通用属性1. scrollHeightscrollHeight表示的是滑动条内可滑动的内容。 如果内容没有超出元素高度，那么scrollHeight表示的是元素的height加上padding，不包括bording。 如果内容超出了元素高度但没有设置滑动条，那么scrollHeight表示的是元素height加上元素的上padding（scrollWidth为左padding），不包括下padding和bording。 如果内容超出了元素高度并且设置有滑动条，那么scrollHeight表示的是滑动条可滑动的高度，不包括滑动条自身的高度（17px）。 我们来测试一下：1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;style type=\"text/css\"&gt; #test &#123; width: 50px; border: 5px solid green; background-color: black; color: red; padding: 10px; overflow: scroll; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"test\"&gt; &lt;span&gt;clientHeight:可见区域的宽度,不包括boder的宽度,如果区域内带有滚动条,还应该减去横向滚动条不可用的高度,正常的是17px &lt;/span&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var test = document.getElementById(\"test\"); console.log(\"scroll=\" + test.scrollHeight+ \";client=\" + test.clientHeight + \";offset=\" + test.offsetHeight)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下面是测试结果： chrome测试结果 console输出结果 分析： 这里的例子是利用一些巧妙的方法，使保证内容全部显示的同时保持滑动条的存在。从图中我们可以看到，元素总导高度为551px，那么scrollHeight的数值到底是怎么算出来的呢？首先是上下border一共10px，再加上滑动条高度的17px一共27px，于是551-27=524。 最后引用其他博主的文字： scrollHeight:这个属性就比较麻烦了,因为它们在火狐跟IE下简直差太多了..在火狐下还很好理解,它其实就是滚动条可滚动的部分还要加上boder的高度还要加上横向滚动条不可用的高度,与clientHeight比起来,多个border的高度跟横向滚动条不可用的高度. 在IE中 scrollHeight确是指这个对象它所包含的对象的高度加上boder的高度和marging,如果它里面没有包含对象或者这个对象的高度值未设置,那么它的值将为15 2. clientHeight这个属性等于元素内容高度height加上padding。 这个元素没什么好说的，各种浏览器下表现一样。 3. offsetHeight这个属性表示元素内容高度height加上padding再加上border，但不包括margin。 4. scrollTop这个属性表示视窗上面隐藏了部分的高度。 常用的语句是：document.body.scrollTop和document.documentElement.scrollTop 值得注意的一点是，chrome不承认document.documentElement.scrollTop，或者说，它永远返回数值0。 浏览器对象属性1. window.innerHeight返回浏览器窗口高度。 2. window.pageYOffset数值和document.body.scrollTop一致，表示视窗上面隐藏了部分的高度。 参考文章： JS实现无限分页加载——原理图解 height、clientHeight、scrollHeight、offsetHeight区别 Chrome不认documentElement.scrollTop","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"原创","slug":"原创","permalink":"/tags/原创/"},{"name":"js客户端对象","slug":"js客户端对象","permalink":"/tags/js客户端对象/"}]},{"title":"Javascript类型的判断","slug":"Javascript类型的判断","date":"2017-10-08T14:26:53.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/08/Javascript类型的判断/","link":"","permalink":"/2017/10/08/Javascript类型的判断/","excerpt":"js对象的类型和类的判断，会让你头晕眼花的，起码我是这样。这篇文章通过原生和非原生的函数，将各种数据的类型和类检测出来，其中涉及到“鸭式辩型”的概念。","text":"js对象的类型和类的判断，会让你头晕眼花的，起码我是这样。这篇文章通过原生和非原生的函数，将各种数据的类型和类检测出来，其中涉及到“鸭式辩型”的概念。 博主原创 typeof()我们首先来看一下实例：1234567891011121314151617typeof undefined // =&gt; \"undefined\"typeof true // =&gt; \"boolean\"typeof NaN // =&gt; \"number\"typeof \"abc\" // =&gt; \"string\"typeof(function()&#123;&#125;) // =&gt; \"function\"typeof null // =&gt; \"object\"typeof &#123;&#125; // =&gt; \"object\"typeof [] // =&gt; \"object\"typeof(new Date) // =&gt; \"object\"typeof(/./） // =&gt; \"object\"typeof window // =&gt; \"object\"// 自定义对象function f(name) &#123; this.name=name; &#125;var fo = new f(\"vinson\");typeof fo; // =&gt; \"object\" 从上面实例可以看到，使用js原生的运算符typeof，能分辨大部分的基本数据类型，但不能分辨类，即class。对于涉及原型链上的类，它一律返回”object”。 更重要的是，面对大部分内置对象（除了function），它依然返回object。比如在JS中，Array类是继承于Object的，所以Array原型的原型链中最终指向于Object。显然，这与我们的预期不符。 但是函数function却能返回，这不是很过分吗？ 基于上面的分析，我们编写了下一个更缜密的函数classof()，检查类属性。 注意，类型type和类class是不同的概念。 资料参考《Javascript权威指南》p87~88 classof()对象的类属性（class attribute）是一个字符串，用以表示对象的类型信息。ECMAScript 3和ECMAScript 5都未提供设置这个属性的方法，并且只有一种间接的方法可以查询它。默认的toString()方法（继承自Object.prototype）返回了如下这种格式的字符串：1[object class] 因此，要想获得对象的类，可以调用对象的toString()方法，然后提取已返回字符串的第8个到倒数第二个位置之间的字符。不过让人感到棘手的是，很多对象继承的toString()方法重写了，为了能调用正确的toString()版本，必须简介地调用Function.call()方法。下面是classof的实现：123456// classof()函数function classof(o) &#123; if (o === null) return \"Null\"; if (o === undefined) return \"Undefined\"; return Object.prototype.toString.call(o).slice(8,-1);&#125; 下面是这个函数的实例：1234567891011classof(null) // =&gt; \"Null\"classof(1) // =&gt; \"Number\"classof(\"\") // =&gt; \"String\"classof(false) // =&gt; \"Boolean\"classof(&#123;&#125;) // =&gt; \"Object\"classof([]) // =&gt; \"Array\"classof(/./) // =&gt; \"Regexp\"classof(new Date()) // =&gt; \"Date\"classof(window) // =&gt; \"Window\"（这是客户端宿主对象）function f() &#123;&#125;; // 定义一个自定义构造函数classof(new f()); // =&gt; \"Object\" 通过classof()函数，我们能够分辨出除了继承对象之外的所有基本类型和内置对象。 对比typeof()函数可以发现，classof()返回的字符串都是以大写开头的。 资料参考《Javascript权威指南》p139~140 type()自定义的对象都不能通过上面的两个方法分辨出来，我们需要一种更精细的方法来检测对象的类。这里的类指的是构造函数的名称。 我们可以通过通过constructor属性获取函数对象，再将函数对象转换为字符串，从中获取构造函数的名称，即类名称。下面是完整的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 以字符串的形式返回o的类型 * - 如果o是null，返回\"null\";如果o是NaN，返回\"nan\" * - 如果typeof所返回的值不是\"object\"，则返回这个值 * - (注意，有一些Javascript的实现将正则表达式识别为函数) * - 如果o的类不是\"Object\"，则返回这个值 * - 如果o包含构造函数并且这个构造函数具有名称，则返回这个名称 * - 否则，一律返回\"Object\" **/function type(o) &#123; var t,c,n; // type,class,name //处理null值的特殊情况 if (o === null) return \"null\"; // 另外一种特殊情况:NaN和它自身不相等 if (o !== o) return \"nan\"; //如果typeof的值不是\"object\"，则返回这个值 if((t = typeof o) !== \"Object\") return c; //返回对象的类名，除非值为\"Object\" //这种方式可以识别出大多的内置对象 if((c = classof(o)) !== \"Object\") return c; //如果对象构造函数的名字存在的话，则返回它 if(o.constructor &amp;&amp; typeof o.constructor === \"function\" &amp;&amp; (n = o.construcor.getName())) return n; //其他的类型都无法判别，一律返回\"Object\" return \"Object\";&#125;//返回对象的类function classof(o) &#123; return Object.prototype.toString.call(o).slice(8,-1);&#125;;//返回函数的名字（可能是空字符串），不是函数的话就返回nullFunction.prototype.getName = function () &#123; if (\"name\" in this) return this.name; return this.name = this.toString().match(/function\\s*([^(]*)\\(/)[1];&#125;; 这种使用构造函数来识别对象的类的做法和使用constructor属性一样有一个问题：**并不是所有的对象都具有constructor属性。此外，并不是所有的函数都有名字。如果使用不带名字的函数定义表达式定义一个构造函数，getName()方法则会返回空字符串：1234//这个构造函数没有名字var Complex = function(x,y) &#123; this.r = x;this.i = y; &#125;//这个构造函数有名字var Range = function Range(f,t) &#123; this.from = f;this.to = t;&#125; 《Javascript权威指南》p213~214 鸭式辩型上文所描述的检测对象的类的各种技术多少都会有些问题，至少在客户端Javascript中是如此。解决办法就是规避这些问题：不要关注“对象的类是什么”，而是关注“对象能做什么”。这种思考问题的方式在Python和Ruby中非常普遍，成为“鸭式辩型”。 像鸭子一样走路、游泳并且嘎嘎叫的鸟就是鸭子。 实例…略 《Javascript权威指南》p215~216","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"原创","slug":"原创","permalink":"/tags/原创/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"},{"name":"Javascript","slug":"Javascript","permalink":"/tags/Javascript/"}]},{"title":"github制作项目DOME方法","slug":"github制作项目DOME方法","date":"2017-10-08T13:49:50.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/08/github制作项目DOME方法/","link":"","permalink":"/2017/10/08/github制作项目DOME方法/","excerpt":"很多时候我们在github上提交了html文件却苦于不能有个实体DEMO。这里的方法很简单，github是内置这种功能的，只需要将网址调整一下即可。","text":"很多时候我们在github上提交了html文件却苦于不能有个实体DEMO。这里的方法很简单，github是内置这种功能的，只需要将网址调整一下即可。 加入我当时有一个IFE作业，github路径为1https://github.com/Vinson-sheep/IFE2017/blob/master/JS/1/js1.html 那DEMO的网址就是1https://htmlpreview.github.io/?https://github.com/Vinson-sheep/IFE2017/blob/master/JS/1/js1.html","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"}]},{"title":"Javascript中call和apply","slug":"Javascript中call和apply","date":"2017-10-07T09:01:51.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/10/07/Javascript中call和apply/","link":"","permalink":"/2017/10/07/Javascript中call和apply/","excerpt":"我们可以将call()和apply()看作是某个对象的方法，通过调用方法的形式来间接调用函数。","text":"我们可以将call()和apply()看作是某个对象的方法，通过调用方法的形式来间接调用函数。 call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用。要想以对象o的方法来调用函数f()，可以这样使用call()和apply()。12f.call(o);f.apply(o); 在ECMAScript 5 的严格模式中，call()和apply()的第一个实参都会变为this的值，哪怕传入的实参是原始值甚至是null或者undefined。在ECMAScript 3和非严格模式中，传入的null和undefined都会被全局对象代替，而其他原始值则会被相应的包装类型所代替。 call()对于call()来说，第一个调用上下文实参之后的所有实参就是传入待调用函数的值。1f.call(o,1,2); apply()apply()方法和call()类似，但传入实参的形式和call()有所不同，它的实参都放入一个数组当中：1f.apply(o,[1,2]);","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js函数","slug":"js函数","permalink":"/tags/js函数/"}]},{"title":"Javascript闭包","slug":"Javascript闭包","date":"2017-10-07T05:32:02.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/07/Javascript闭包/","link":"","permalink":"/2017/10/07/Javascript闭包/","excerpt":"函数对象可以通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域呢，这种特性在计算机科学文献中称为“闭包”。","text":"函数对象可以通过作用域链互相关联起来，函数体内部的变量都可以保存在函数作用域呢，这种特性在计算机科学文献中称为“闭包”。 “闭包”，这个术语非常古来，是指函数变量可以被隐藏于作用域链之内，因此看起来是函数将变量“包裹”了起来。 犀牛书p182~188 作用域链规则来看下这段代码：1234567var scope = \"global\"; // 全局变量function checkscope() &#123; var scope = \"local scope\"; // 局部变量 function f() &#123; return scope; &#125; //在作用域中返回这个值 return f();&#125;checkscope(); // =&gt; \"local scope\" 上面得出local scope应该毫无悬念。 现在我们对这段代码做小改动。1234567var scope = \"global scope\"; // 全局变量function checkscope() &#123; var scope = \"local scope\"; // 局部变量 function f() &#123; return scope; &#125; return f;&#125;checkscope()() // 返回值是什么？ checkscope函数会返回一个内嵌函数，而执行这个引用了局部变量的内嵌函数，返回的是什么呢？不管在何时何地执行函数f()，f()和checkscope()函数的绑定依然有效。因此最后一行代码会返回local scope，而不是global scope。简而言之，闭包的这个特效强大得让人大吃一惊：它们可以捕捉到局部变量（和参数），并一直保存下来，看来像这里变量绑定到了在其中定义它们的外部函数。 私有变量像counter一样的私有变量不是只能用在一个单独的闭包内，在同一个内部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域链，看一下这段代码：12345678910111213function counter() &#123; var n = 0; return &#123; count: function() &#123;return n++;&#125;, reset: function() &#123;n=0;&#125; &#125;;&#125;var c = counter(), d = counter(); // 创建两个计数器c.count() // =&gt; 0d.count() // =&gt; 0 : 它们互不干扰c.reset() // reset()和count()方法共享状态c.count() // =&gt; 0d.count() // =&gt; 1: 而没有重置d 循环陷阱先看下面代码：123456789// 这个函数返回一个总是返回v的函数function constfunc(v) &#123;return function() &#123;return v;&#125;;&#125;// 创建一个数组用来储存常数函数var funcs = [];for (var i=0; i&lt;10; i++) funcs[i] = constfunc(i);// 在第5个位置的元素所表示的函数返回值为5funcs[5]() // =&gt; 5 这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：啊就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：12345678910// 返回一个函数组成的数组，它们的返回值是0~9function constfuncs() &#123; var funcs = []; for (var i = 0; i&lt;10; i++) funcs[i] = function() &#123; return i; &#125;; return funcs;&#125;var funcs = constfuncs();func[5]() // 返回值是什么？ 上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量i。当constfuncs()返回时，变量i的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域链都是“活动的”。 注意this是Javascript的关键字，不是变量每个函数调用都包含一个this值，如果闭包在外部函数里是无法访问this的，除非外部函数将this转存为一个变量：1var self = this; // 将this保存至一个变量中，以便嵌套的函数能够访问它 arguments并不是关键字arguments并不是一个关键字，但在调用每个函数时都会自动声明它，由于闭包具有自己所绑定的arguments，因此闭包无法直接访问外部函数的参数数组，除非外部函数将参数数组保存到另一个变量中：1var outerArguments = argumens; // 保存起来以便嵌套的函数能够使用它","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js闭包","slug":"js闭包","permalink":"/tags/js闭包/"}]},{"title":"Javascript作为命名空间的函数","slug":"Javascript作为命名空间的函数","date":"2017-10-06T16:45:32.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/10/07/Javascript作为命名空间的函数/","link":"","permalink":"/2017/10/07/Javascript作为命名空间的函数/","excerpt":"在函数中声明的变量在整个函数体内都是可见的（包括嵌套的函数中），在函数的外部都是不可见的。我们常常简单地定义一个函数用作临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。","text":"在函数中声明的变量在整个函数体内都是可见的（包括嵌套的函数中），在函数的外部都是不可见的。我们常常简单地定义一个函数用作临时的命名空间，在这个命名空间内定义的变量都不会污染到全局命名空间。 我记得《Javascript高级程序设计》中也提及到这方面的内容，但是我觉得《Javascript权威指南》对这方面描述得更为清晰。 比如，假设你写了一段Javascript模块代码，这段代码将要用在不同的Javascript程序中。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样的问题就来了，当模块代码放在不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么就会和代码冲突。解决方法当然是将代码放入一个函数内，然后调用这个函数：123456function mymodule() &#123; // 模块代码 // 这个代码所使用的所有变量都是局部变量 // 而不是污染全局命名空间&#125;mymodule(); // 别忘了还要调用这个函数 这样做还是太麻烦了，我们可以直接定义一个匿名函数，并在单个表达式中调用它：123(function() &#123; // 模块代码&#125;()); // 结束函数定义并立即调用它 相比于第一种方案，我更倾向于第二种方案。第二种方案起码避免一个函数名称冲突的可能。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js函数","slug":"js函数","permalink":"/tags/js函数/"}]},{"title":"Javascript自定义函数属性","slug":"Javascript自定义函数属性","date":"2017-10-06T16:45:14.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/07/Javascript自定义函数属性/","link":"","permalink":"/2017/10/07/Javascript自定义函数属性/","excerpt":"Javascript中函数不是一个原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。","text":"Javascript中函数不是一个原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。 这是个新大陆，利用好的话可以简化很多代码。当然这不是什么高端函数，这个大陆只是一种思维。 比如，假设你想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个函数。而函数不能两次返回同一个值，为了做到这一点，函数必须能够跟踪它每次返回的值，而且这些值的信息需要在不同的函数调过程中持久化。可以将这些信息存放在一个全局变量中，但这并不是必须的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中，下面这个例子就实现了这样一个函数，每次调用函数都会返回一个唯一的整数：12345678910// 初始化函数对象的计数属性// 由于函数声明提前了，因此这里是可以函数声明// 之前给它的成员赋值的uniqueInteger.counter = 0;// 每次调用这个函数都会返回一个不同的整数// 它使用一个属性来记住下一次将要返回的值function uniqueInteger() &#123; return uniqueInteger.counter+; // 先返回计数器的值，然后计数器自增1&#125; 来看另一个例子，下面这个函数factorial()使用了自身的属性（将自身当作数组来对待）来缓存上一次的计算结果：123456789// 计算阶乘，并将结果缓存至函数的属性中function factorial(n) &#123; if (isFinite(n) &amp;&amp; n&gt;0 &amp;&amp; n==Math.round(n)) &#123; if (!(n in factorial)) factorial[n] = n*factorial(n-1); return factorial[n]; &#125; else return NaN; // 如果输入有误&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js函数","slug":"js函数","permalink":"/tags/js函数/"}]},{"title":"Javascript数组方法列表","slug":"Javascript数组方法列表","date":"2017-10-05T17:26:25.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/10/06/Javascript数组方法列表/","link":"","permalink":"/2017/10/06/Javascript数组方法列表/","excerpt":"ECMAScript 3在Array.prototype中定义了一些很有用的操作数组的函数，ECMAScript 5新新增了一些新的数组遍历方法。","text":"ECMAScript 3在Array.prototype中定义了一些很有用的操作数组的函数，ECMAScript 5新新增了一些新的数组遍历方法。 ECMAScript 3 a.join()合并数组元素转换为字符串 a.reverse()反转数组 a.sort()排列数组元素 a.concat()合并多个数组 a.slice()截取数组元素并返回新数组 a.splice()数组操作万能方法 push()和pop()插入/删除最后一个元素 unshift和shift()插入/删除最后一个元素 toString()和toLocaleString()Array.sort()Array.sort()方法将数组中的元素排序并返回排序后的数组。当不带参数调用sort()时，数组元素以字母表顺序排序： 如果数组包含undefined元素，它们会被排列到数组的尾部。 为了按照其他方式而非字母表顺序进行组排序，必须给sort()方法传递一个比较函数。 假设第一个参数应该在前，比较函数应该返回一个小于0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数组。并且，假设两个值相等，函数应该返回0.123456var a = [33, 4 ,1111, 222];a.sort(); // 字母表顺序：1111,222,33,4a.sort(function(a,b) &#123; // 数值顺序： 4，33，222，1111 return a-b;&#125;);a.sort(function(a,b) &#123; return b-a&#125;); //数值大小相反的顺序 Array.concat()Array.concat()方法创建并返回一个新数组，它的元素包括调用concat()的原始数组的元素和concat()的每个参数。123456var a = [1,2,3];a.concat(4,5); // [1,2,3,4,5]a.concat([4,5]); // [1,2,3,4,5]a.concat([4,5],[6,7]); // [1,2,3,4,5,6,7]a.concat(4,[5,[6,7]]); // [1,2,3,4,5,[6,7]]a // [1,2,3]:a没有改变 Array.slice()12345var a = [1,2,3,4,5];a.slice(0,3); // [1,2,3]a.slice(3); // [4,5]a.sliec(1.-1); // [2,3,4]a.slice(-3,-2); // [3] Array.splice()不同于slice()和concat()，splice()会修改调用的数组。 如果省略第二个参数，从起始点开始到数组结尾的所有元素都将被删除。12345678var a =[1,2,3,4,5,6,7,8];a.splice(4); // 返回[5,6,7,8];a是[1,2,3,4]a.splice(1,2); // 返回[2,3];a是[1,4]a.splice(1,1); // 返回[4];a是[1]var a = [1,2,3,4,5];a.splice(2,0,'a','b'); // 返回[];a是[1,2,'a','b',3,4,5]a.splice(2,2,[1,2],3); // 返回['a','b'];a是[1,2,[1,2],3,3,4,5] ECMAScript 5ECMAScript 5中的数组方法都不会修改它们调用的原始数组。当然，传递给这些方法的函数是可以修改这些数组的。 forEach()从头到尾遍历数组。 map()将每个元素传递给函数，并返回一个数组 filter()过滤函数，返回一个被过滤的数组 every()和some()用来判断数组属性的方法 reduce()和reduceRight()迭代函数 indexOf()和lastIndexOf()搜索函数 Array.forEach()这个函数可以修改原始数组。123456789var data = [1,2,3,4,5]; // 要求和的数组// 计算数组元素的和值var sum = 0; // 初始化为0data.forEach(function(value) &#123; sum += value; &#125;); // 将每个值累加在sum上sum; // =&gt; 15//每个数组元素自加1data.forEach(function(v,i,a) &#123;a[i]=v+1&#125;);data // =&gt; [2,3,4,5,6] 这个方法的遍历如需终止，需要将方法放在try块中。（犀牛书p156） Array.map()12a = [1,2,3];b = a.map(function(x) &#123;return x*x; &#125;); // b是[1,4,9] Array.filter()函数的返回值如果是true或者是能转换为true值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中。例如：123a = [5,4,3,2,1];smallvalues = a.filter(function(x) &#123;return x&lt;3&#125;); // [2,1]everyother = a.filter(function(x,i) &#123;return i&amp;2==0&#125;); // [5,3,1] Array.every()和Array.some()every()和some()方法是数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回true或false。123a = [1,2,3,4,5];a.every(function(x) &#123; return x &lt; 10; &#125;); // true:所有的值&lt;10a.every(function(x) &#123; return x * 2 === 0;&#125;); // fasle:不是所有的值都是偶数 123a = [1,2,3,4,5];a.some(function(x) &#123;return x%2===0;&#125;); // truea.some(isNaN); // false reduce()和reduceRight()reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值。12var a=[1,2,3,4,5];var sum = a.reduce(function(x,y) &#123;return x+y &#125;, 0); 这里的x可以看作是迭代的值，y是元素，第二个参数0是x的初始值。 reduceRight()工作原理和reduce()一样，不同的是它按照数组索引从高到低处理数组，而不是从低到高。 indexOf()和lastIndexOf()indexOf()和lastIndexOf()搜索整个数组中具有给定值的元素，返回找到的第一个元素的索引或者如果没有找到就返回-1。indexOf()从头到尾搜索，而’lastIndexOf()’则反向搜索。1234a = [0,1,2,1,0];a.indexOf(1); // =&gt; 1: a[1]是1a.lastIndexOf(1); // =&gt; 3: a[3]是1a.indexOf(3); // =&gt; -1: 没有值为3的元素 indexOf()和lastIndexOf()可以提供第二个参数，指定从那个索引开始搜索。利用第二个参数可以搜索全部的值的索引。1pos = a.indexOf(x, pos);","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js数组","slug":"js数组","permalink":"/tags/js数组/"}]},{"title":"Javascript对象（七）——对象的三个属性","slug":"Javascript对象（七）——对象的三个属性","date":"2017-10-05T15:45:21.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/10/05/Javascript对象（七）——对象的三个属性/","link":"","permalink":"/2017/10/05/Javascript对象（七）——对象的三个属性/","excerpt":"对象的三个属性：原型属性、类属性、可扩展性。","text":"对象的三个属性：原型属性、类属性、可扩展性。 原型属性获取原型对象：1Object.prototype 查询原型：1Object.getPrototypeOf() 查询构造函数：1o.constructor 检测是否是某对象原型：1234var p = &#123;x:1&#125;;var o = Object.create(p);p.isPrototypeOf(o); =&gt; trueObject.prototype.isPrototypeOf(o); =&gt; true 类属性对象的类属性（class attribute）是一个字符串，用以表示对象的类型信息。ECMAScript 3和ECMAScript 5都未提供设置这个属性的方法，并和自由一种间接的方法可以查询它。默认的toString()方法返回了如下这种格式的字符串：1[object class] 因此可以编写classOf函数：12345function classof(o) &#123; if (o===null) return \"Null\"; if (o===undefined) return \"Undefined\"; return Object.prototype.toString.call(o).slice(8,-1);&#125; 由于很多对象的toString()方法重写了，所以利用call()调用最原始的toString()函数。 下面是这个函数执行的例子：1234567891011classof(null) // =&gt; \"Null\"classof(1) // =&gt; \"Number\"classof(\"\") // =&gt; \"String\"classof(false) // =&gt; \"Boolean\"classof(&#123;&#125;) // =&gt; \"Object\"classof([]) // =&gt; \"Array\"classof(/./) // =&gt; \"RegExp\"classof(new Date()) // =&gt; \"Date\"classof(window) // =&gt; \"Window\"(这是客户端宿主对象)function f() &#123;&#125;; // 定义一个自定义构造函数classof(new f()) // =&gt; \"Object\" 可扩展性对象的扩展性用以表示是否可以给对象添加新属性。所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展性是由Javascript引擎定义的。 Object.preventExtensions()通过将对象传入Object.preventExtensions()，将对象转换为不可扩展的。 注意，一旦将对象转换为不可扩展的，就无法将其转换回可扩展的了。 同样需要注意的是，preventExtensions()只影响到对象本身的可扩展性。如果给一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属性。 判断函数Object.isExtensions() Object.seal()Object.seal()和Object.preventExtensions()类似，除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置的。 判断函数Object.isSealed() Object.freeze()Object.freeze()将更严格地锁定对象——“冻结”（frozen）。除了对象设置为不可扩展的和将其属性设置为不可配置之外，还可以将它自由的所有数据属性设置为只读。 判断函数Object.isFrozen()","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（六）——对象的特性","slug":"Javascript对象（六）——对象的特性","date":"2017-10-05T13:10:28.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/10/05/Javascript对象（六）——对象的特性/","link":"","permalink":"/2017/10/05/Javascript对象（六）——对象的特性/","excerpt":"对象的属性除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。在ECMAScript 3中无法设置这些特效。而ECMAScript 5中查询和设置这些属性特性的API。这些API对于库开发者来说非常重要。","text":"对象的属性除了包含名字和值之外，属性还包含一些标识它们可写、可枚举和可配置的特性。在ECMAScript 3中无法设置这些特效。而ECMAScript 5中查询和设置这些属性特性的API。这些API对于库开发者来说非常重要。 数据属性的4个特性 值(value) 可写性(writable) 可枚举性(enumerable) 可配置性(configurable) 存取器属性的4个特性 读取(get) 写入(set) 可枚举性 可配置性 Object.getOwnPropertyDescriptor()通过调用Object.getOwnPropertyDescriptor()可以获得某个对象特定属性的属性描述符：12345678910// 返回 &#123;value: 1,writable: true,enumerable: true,configurable: true&#125;Object.getOwnPropertyDescriptor(&#123;x:1&#125;, \"x\");// 查询上下文中定义的random对象的octet属性（这里没有random对象）// 返回 &#123; get: /*func*/, set:undefined, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(random, \"octet\");// 对于继承属性和不存在的属性，返回undefinedObject.getOwnPropertyDescriptor(&#123;&#125;, \"x\"); // undefined,没有这个属性Object.getOwnPropertyDescriptor(&#123;&#125;, \"toString\"); // undefined,继承属性 从函数名字就可以看出，Object.getOwnPropertyDescriptor()只能得到自有属性的描述符。 Object.defineProperty()要想设置属性的特性，或者想让新建属性具有某种特效，则需要调用Object.defineProperty()，传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象：12345678910111213141516171819202122232425var o = &#123;&#125;; // 创建一个空对象// 添加一个不可枚举的属性x，并赋值为1Object.defineProperty(o, \"x\", &#123; value: 1, writable: true, enumerable: false, configurable: true&#125;);// 属性是存在的，但不可枚举o.x; // =&gt; 1Object.keys(o) // =&gt; []// 现在对属性x做修改，让它变为只读Object.defineProperty(o, \"x\", &#123;writable: false &#125;);// 试图更改这个属性的值o.x = 2; // 操作失败但不报错，而在严格模式中抛出类型错误异常o.x // =&gt; 1// 属性依然是可配置的，因此可以通过这种方式对它进行修改：Object.defineProperty(o, \"x\", &#123;value: 2&#125;);o.x // =&gt; 2//现在将x从数据属性修改为存取器属性Object.defineProperty(o, \"x\", &#123; get: function() &#123;return 0; &#125;&#125;);o.x // =&gt; 0 传入Object.defineProperty()属性描述符对象不必包含所有4个特效。对于新创建的属性来说，默认的特性值是false或undefined。注意，这个方法要么修改已有属性要么新建自有属性，但不能修改继承属性。 Object.defineProperties()如果要同时修改或创建多个属性，则需要使用Object.defineProperties()。123456789var p = Object.defineProperties(&#123;&#125;,&#123; x: &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;, y: &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;, r: &#123; get: function() &#123;return Math.sqrt(this.x*this.x + this.y*this.y) &#125;, enumerable: true, configurable: true &#125;&#125;); 这段代码从一个空对象开始，然后给它添加两个数据属性和一个只读存取器属性。最终Object.defineProperties()返回修改后的对象（和Object.defineProperty一样）。 配置规则 如果对象是不可扩展，则可以编辑已有的自有属性，但不能给它添加新属性。 如果属性是不可配置的，则不能修改它的可配置性和可枚举性。 如果存取器属性是不可配置的，则不能修改其getter和setter方法，也不能将它转换为数据属性。 如果数据属性是不可配置的，则不能将它转换为存取器属性。 如果数据属性是不可配置的，则不能将它的可写性从false修改为true，但可以从true修改为false。 如果数据属性是不可配置且不可泄的，则不能修改它的值。然而可配置但不可写属性的值是可以修改的（实际上是先将它标记为可写的，然后修改它的值，最后转换为不可写的）。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（五）——存取器属性","slug":"Javascript对象（五）——存取器属性","date":"2017-10-05T11:34:06.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/05/Javascript对象（五）——存取器属性/","link":"","permalink":"/2017/10/05/Javascript对象（五）——存取器属性/","excerpt":"由getter和setter定义的属性称作“存取器属性”（accessor property），它不用于“数据属性”（data property），数据属性只有一个简单的值。","text":"由getter和setter定义的属性称作“存取器属性”（accessor property），它不用于“数据属性”（data property），数据属性只有一个简单的值。 在ECMAScript 5（包括除了IE之外的最新主流浏览器的ECMAScript 3的实现）中,属性值可以用一个或两个方法替代，这两个方法就是getter和setter。 和数据属性不同，存取器属性不具有可写性。如果属性同时具有getter和setter方法，那么它是一个读/写属性。如果它只有getter方法，那么它是一个只读属性。如果它只有setter方法，那么它是一个只写属性（数据属性中有一些例外），读取只写属性总是返回undefined。 定义存取器属性最简单的方法是使用对象直接量语法的一种扩展写法：12345678var o = &#123; // 普通的数据属性 data_prop: value, // 存取器属性都是成对定义的函数 get accessor_prop() &#123; /*这里是函数体 */&#125;,set accessor_prop(value) &#123; /*这里是函数体*/&#125;&#125; 注意：存取器属性定义为一个或两个和属性同名的函数，这个函数定义没有使用function关键字，而是使用get和（或）set。注意，这里没有使用冒号将属性名和函数体分隔开，但在函数提的结束和下一个方法或数据属性之间有逗号分隔。 在ECMAScript 5中，可以通过Object.getOwnPropertyDescriptor()和Object.defineProperty()来修改getter和setter方法。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（四）——检测属性","slug":"Javascript对象（四）——检测属性","date":"2017-10-05T10:22:26.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/10/05/Javascript对象（四）——检测属性/","link":"","permalink":"/2017/10/05/Javascript对象（四）——检测属性/","excerpt":"in运算符、hasOwnProperty()方法和propertyIsEnumerable()方法。顺便介绍另外两个偏门的枚举属性的方法：Object.keys()和Object.getOwnPropertyNames()。","text":"in运算符、hasOwnProperty()方法和propertyIsEnumerable()方法。顺便介绍另外两个偏门的枚举属性的方法：Object.keys()和Object.getOwnPropertyNames()。 in运算符in运算符的左侧是属性名（字符串），右侧是对象。如果对象的自由属性或继承属性中包含这个属性则返回true。1234var o = &#123; x:1 &#125;;\"x\" in o; // true: \"x\"是o的属性\"y\" in o; // false: \"y\"不是o的属性\"toString\" in o; // true: o继承toString属性 出来使用in运算符之外，另一种更简便的方法是使用“!==”判断一个属性是否是undefined：1234var o = &#123; x: 1 &#125;; o.x !== undefined; // trueo.y !== undefined; // falseo.toString !== undefined; // true 然而有一种场景只能使用in运算符而不能使用上述属性访问的方式。in可以区分不存在的属性和存在但值为undefined的属性。例如下面的代码：1234567var o = &#123; x: undefined &#125;; //属性被显式赋值为undefinedo.x !== undefined; // falseo.y !== undefined; // false\"x\" in o; // true\"y\" in o; // falsedelete o.x; // 删除了属性x\"x\" in o; // false hasOwnProperty()方法对象的hasOwnProperty()方法是用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回false:1234var o = &#123; x: 1 &#125;;o.hasOwnProperty(\"x\"); // true: o有一个自有属性xo.hasOwnProperty(\"y\"); // false: o中不存在属性yo.hasOwnProperty(\"toString\"); // false: toString是继承属性 propertyIsEnumerable()方法propertyIsEnumerable()是hasOwnProperty()的增强版，只有检测到是自有属性且这个属性的可枚举性为true时它才返回true。12345var o = inherit(&#123; y:2 &#125;);o.x = 1;o.propertyIsEnumerable(\"x\"); // true: o有一个可枚举的自有属性xo.propertyIsEnumerable(\"y\"); // false: y是继承过来的Object.prototype.propertyIsEnumerable(\"toString\"); // false: 不可枚举 开个玩笑看下面代码：12Object.prototype.hasOwnProperty(\"has.OwnProperty\"); // =&gt; trueObject.prototype.hasOwnProperty(\"propertyIsEnumerable\"); // =&gt; true Object.keys()ECMAScript 5定义了两个用以枚举属性名称的函数。 第一个是Object.keys(),这个函数返回一个数组，这个数组由对象中可枚举的自由属性的名称组成。 Object.getOwnPropertyNames()这个函数返回对象的所有自有属性的名称，而不仅仅是可枚举的属性。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（三）——删除属性delete","slug":"Javascript对象（三）——删除属性delete","date":"2017-10-05T09:52:08.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/10/05/Javascript对象（三）——删除属性delete/","link":"","permalink":"/2017/10/05/Javascript对象（三）——删除属性delete/","excerpt":"delete的机制，要注意的地方。","text":"delete的机制，要注意的地方。 delete用法delete运算符可以删除对象的属性。它的操作数应该是一个可以访问表达式。12delete book.author; // book不再有属性authordelete book[\"main title\"]; // book也不再有属性\"main title\" 只是断开联系然而令人意外的是，**delete只是断开属性和宿主对象的联系，并不会去操作属性中的属性。 来看下面例子：12345a = &#123;p:&#123;x:1&#125;&#125;; // 创建一个词典b = a.p; // 将b指针指向pdelete a.p; // 删除a中的对象pb.x; // =&gt; 1:表面p依然存在 从上面的例子可以看到，由于已经删除的属性引用依然存在，因此在Javascript的某些实现中，可能因为这种不严谨的代码而造成内存泄漏。所以在销毁对象的时候，要遍历属性中的属性，依次删除（关于如何遍历删除，我也不是很理解）。 只能操作自由属性delete运算符只能删除自由属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象）。 严格模式限制在严格模式中，delete后跟随一个非法的操作数（比如x），则会报一个语法错误，因此必须显式指定对象及其属性：12delete x; // 在严格模式下报语法错误delete this.x; // 正常工作","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（二）——三种创建方法","slug":"Javascript对象（二）——三种创建方法","date":"2017-10-04T17:03:45.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/05/Javascript对象（二）——三种创建方法/","link":"","permalink":"/2017/10/05/Javascript对象（二）——三种创建方法/","excerpt":"对象直接量、new创建对象、还有Object.create()方法创建对象。","text":"对象直接量、new创建对象、还有Object.create()方法创建对象。 对象直接量创建对象最简单的方式就是Javascript代码中使用对象直接量。1var empty = &#123;&#125;; 通过new创建对象1var o = new Object(); // 创建一个空对象，和&#123;&#125;一样 Object.create()这个方法恐怕在开发JS库的时候才会用上。 ECMAScript 5定义了一个名为Object.create()的方法，它创建一个新对象，其中第一个参数是这个对象的原型。Objcet.create()提供第二个可选参数，用以对对象的属性进行进一步描述。1var o1 = Object.create(&#123;x:1, y:2&#125;); //o1继承了属性x和y 可以通过传入参数null来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如toString()，也就是说，它将不能和“+”运算符一起正常工作：1var o2 = Object.create(null); // o2不继承任何属性和方法 如果想要创建一个普通的空对象（比如通过{}或new Object()创建的对象），需要传入Object.prototype：1var o3 = Object.create(Object.prototype); // o3和&#123;&#125;和new Object()一样","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript对象（一）——基本术语","slug":"Javascript对象（一）——基本术语","date":"2017-10-04T17:03:03.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/05/Javascript对象（一）——基本术语/","link":"","permalink":"/2017/10/05/Javascript对象（一）——基本术语/","excerpt":"对象基本知识，方便看文章时候的理解。","text":"对象基本知识，方便看文章时候的理解。 我们可以把对象看成是从字符串到值的映射。这种基本数据结构还有很多种叫法，有些我们已然非常熟悉，比如“散射（hash）”、“散列表（hashtable）”、“字典（dictionary）”、“关联数组（associative）”。 然而对象不仅仅是字符串到值的映射，除了可以保持自有的属性，Javascript对象还可以从一个成为原型的对象继承属性。对象的方法通常是继承的属性。这种“原型式继承（prototypal inheritance）”是Javascript的核心特征。 属性特性 可写（writable attribute），表明是否可以设置该属性的值。 可枚举（enumerable attribute），表明是否可以通过for/in循环返回该属性。 可配置（configurable attribute），表明是否可以删除或修改该属性。 在ECMAScript 5之前，通过代码给对象创建的所有属性都是可写的、可枚举的和可配置的。 对象特性 对象的原型（prototype）指向另一个对象，本对象的属性继承自它的原型对象。 对象的类（class）是一个标识对象类型的字符串。 对象的扩展标记（extensible flag）指明（在ECMAScript 5中）是否可以向该对象添加新属性。 三类JS对象+两类属性 内置对象（native object）是由ECMAScript规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象。 宿主对象（host object）是由Javascript解析器所嵌入的宿主环境（比如Web浏览器）定义的。客户端Javascript中表示网页结构的HTMLElement对象均是宿主对象。既然宿主环境定义的方法可以当成普通的Javascript函数对象，那么宿主对象也可以当成内置对象。 自定义对象（user-defined object）是由运行中的Javascript代码创建的对象。 自有属性（own property）是直接在对象中定义的属性。 继承属性（inherited property）是在对象的原型对象中定义的属性。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"js对象","slug":"js对象","permalink":"/tags/js对象/"}]},{"title":"Javascript严格模式","slug":"Javascript严格模式","date":"2017-10-04T16:15:12.000Z","updated":"2018-04-10T03:45:06.000Z","comments":true,"path":"2017/10/05/Javascript严格模式/","link":"","permalink":"/2017/10/05/Javascript严格模式/","excerpt":"严格模式修复了JS中的重要缺陷，并提供健壮的差错功能和增强的安全机制。但由于一般不会特别去声明是strict模式，用得比较少，在这里只是做个简介，如果有需要的话，再在本文扩充。","text":"严格模式修复了JS中的重要缺陷，并提供健壮的差错功能和增强的安全机制。但由于一般不会特别去声明是strict模式，用得比较少，在这里只是做个简介，如果有需要的话，再在本文扩充。 “use strict”是ECMAScript 5引入的一条指令。指令不是语句（但非常接近语句）。 使用“use strict”指令的目的是说明（脚本或者函数中）后续的代码将会解析为严格代码（strict code）。 对于那些不支持strict模式的浏览器，“use strict”只是一条没有副作用的表达式语句而已，它什么都不做。 严格模式和非严格模式之间的区别主要是以下三点： 在严格模式中禁止使用with语句。 在严格模式中，所有变量都要声明。如果给一个未声明的变量、函数、函数参数、catch从句参数（这两个我需要实例验证一下）或者全局对象的属性赋值，将会抛出一个引用错误异常。 在严格膜使用，调用函数（不是方法）中的this值是undefined。（在非严格模式中，调用的函数中的this值总是全局对象）。可以利用这种特性来判断Javascript实现是否支持严格模式：1var hasStrictMode = (function() &#123; \"use strict\";return this === undefined &#125;())","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中debugger语句","slug":"Javascript中debugger语句","date":"2017-10-04T15:49:12.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/04/Javascript中debugger语句/","link":"","permalink":"/2017/10/04/Javascript中debugger语句/","excerpt":"debugger语句是实战中是为了方便调试用的，但是就我开发体验来说，使用debugger语句的可能性不大。","text":"debugger语句是实战中是为了方便调试用的，但是就我开发体验来说，使用debugger语句的可能性不大。 debugger语句通常什么都不做。然而，当调试程序可用并运行的时候，Javascript解析器将会（非必须）以调试模式运行。 下面是使用的实例：1234function f(o) &#123; if (o === undefined) debugger; // 这一行代码只是用于临时测试 ... // 函数的其他部分&#125; 在chrome中测试以上代码：1f(); // 不输入参数值，触发debugger行为 这时候chrome会进入调试模式，并且指出调试语句。 在ECMAScript 5中,debugger语句正式加入到这门语言里。但在相当长的一段时间里，主流浏览器厂商已经将其实现了。注意，可用的调试器是远远不够的，debugger语句不会启动调试器。但如果调试器已经在运行中，这条语句才会真正产生一个断点。例如，如果使用Firefox的调试扩展插件Firebug，则并必须首先为待测试的网页启用Friebug，这样debugger语句才能正常工作。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中的with语句","slug":"Javascript中的with语句","date":"2017-10-04T15:20:52.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/04/Javascript中的with语句/","link":"","permalink":"/2017/10/04/Javascript中的with语句/","excerpt":"在实战中使用with语句，要注意几点。","text":"在实战中使用with语句，要注意几点。 with语句with语句用于临时扩展作用域链，它具有以下的语法：12with (object)statement 这条语句将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原始状态。 with不效率在严格模式中是严格使用with语句的，并且在非严格模式里也是不推荐使用with语句的，尽可能避免使用with语句。 那些使用with语句的Javascript代码非常难于优化，并且同没有使用with语句的代码相比，它运行更慢。 对于对象嵌套层次很深的情况，使用with语句是可以简化代码编写，比如我们要访问HTML表单元素，我们可以这么做：123456with(document.forms[0]) &#123; // 直接访问表单元素，例如： name.value = \"\"; address.value = \"\"; email.value = \"\";&#125; with小括号后面的对象会临时挂载在作用域链上，这样减少了大量的输入。 有时候为了便于优化代码或者提高性能，我们会使用替代的方法：1234var f = document.forms[0];f.name.value = \"\";f.address.value = \"\";f.email.value = \"\"; with不能创建新属性犀牛书上有一个例子：1with(0) x = 1; 书上的分析是这样的： 如果对象o有一个属性x，那么这行代码给这个属性赋值为1。但如果o中没有定义属性x，这段代码和不使用with语句的代码x=1是一模一样的。它给一个局部变量或者全局变量赋值，或者创建全局对象的一个新属性。with语句提供了一种读取o的属性的快捷方式，但它并不能创建o的属性。 为了便于理解，我在chrome浏览器的console中测试了以下例子：1234var o = &#123;&#125;; // 定义一个新的空对象with(o) x = 1; // =&gt; 1:赋值成功console.log(o.x); // =&gt; undefined：未定义console.log(x); // =&gt; 1：数据绑定在全局对象中 根据这个例子再细读一次犀牛书的原话，应该有所收获。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中for/in循环机理","slug":"Javascript中for-in循环机理","date":"2017-10-03T13:12:36.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/03/Javascript中for-in循环机理/","link":"","permalink":"/2017/10/03/Javascript中for-in循环机理/","excerpt":"for/in循环是非常有用的原生语句，了解for/in循环的作用机理，可以实现意想不到的效果。","text":"for/in循环是非常有用的原生语句，了解for/in循环的作用机理，可以实现意想不到的效果。 基本语法for/in语句也使用了for关键字，但它是和常规的for循环完全不同的一类循环。for/in循环语句的语法如下：12for (variable in object) statement for/in循环是用来方便地遍历对象的属性成员。下面是for/in的一个实例：123for(var p in o) &#123; console.log(o[p]);&#125; 在执行for/in语句的过程中，Javascript解析器首先计算Object表达式。如果表达式为null或者undefined，Javascript解析器将会跳过循环并执行后续的代码。 作用机理只要for/in循环中variable的值可以当作赋值表达式的左值，它可以是任意表达式。**每次循环都会计算这个表达式，也就是说每次循环它计算的值都有可能不同。例如，可以使用下面这段代码将所有对象属性复制至一个数组中：123var o = &#123; x:1,y:2,z:3&#125;;var a = [],i = 0;for (a[i++] in o) /* empty */ ; 分析：上面的for/in循环中，每一次循环都会将i加一，最关键的是，循环体object中的属性值会赋值给variable，所以每一次循环就会将object对应的值复制到数组a中去。 循环遍历for/in循环并不会遍历对象的所有属性，只有“可枚举（enumerable）”的属性才会被遍历到。 在ECMAScript 5中可以通过特殊的手段让可枚举属性变为不可枚举的。 如果for/in的循环体删除了还未枚举的属性，那么这个属性将不会被枚举到。 如果循环体定义了对象的新属性，这些属性通常也不会被枚举到（然而,Javascript的有些实现是枚举这些在循环体内增加的继承属性）。 关于属性枚举的顺序，我也不是特别了解。在这里就不深入讨论了。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript函数声明与函数定义表达式","slug":"Javascript函数声明与函数定义表达式","date":"2017-10-03T12:03:27.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/10/03/Javascript函数声明与函数定义表达式/","link":"","permalink":"/2017/10/03/Javascript函数声明与函数定义表达式/","excerpt":"一直对JS的函数声明和函数定义表达式不太清楚，今天来明确一下定义以及各自的区别。","text":"一直对JS的函数声明和函数定义表达式不太清楚，今天来明确一下定义以及各自的区别。 what?关键字function用来定义函数。 函数声明1function f(x) &#123; return x+1; &#125; 函数定义表达式1var f = function(x) &#123; return x+1; &#125; difference尽管函数声明语句和函数表达式包含相同的函数名，但二者仍然不同。 函数声明语句中函数名是一个变量名，变量指向函数对象。和通过var声明变量一样，函数定义语句中函数被显示地“提前”到了额脚本或函数的顶部。因此它们在整个脚本和函数内都是可见的。 使用var的话，只有变量声明提前了——变量初始化代码仍然在原来的位置。 然而使用函数声明语句的话，函数名称和函数体均提前：脚本中的所有函数和函数中所有嵌套的函数都会在当前上下文中其他代码之前声明。也就是说，可以在声明一个JavaSript函数前调用它。 和var语句一样，函数声明语句创建的变量也是无法删除的。 attention函数定义不能出现在if语句、while循环或其他任何语句中。 正因为有这种限制，函数声明没有被ES 5归纳为语句。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中delete运算符","slug":"Javascript中delete运算符","date":"2017-10-03T11:17:01.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/10/03/Javascript中delete运算符/","link":"","permalink":"/2017/10/03/Javascript中delete运算符/","excerpt":"delete是一元操作符，它用来删除对象属性或者数组属性。就像赋值、递增运算符一样，delete也具有副作用，它是用来做删除操作的，不是用来返回一个值。关于delete需要注意一下几点：","text":"delete是一元操作符，它用来删除对象属性或者数组属性。就像赋值、递增运算符一样，delete也具有副作用，它是用来做删除操作的，不是用来返回一个值。关于delete需要注意一下几点： 直接删除属性先看下面例子：1234var a = [1,2,3]; //定义一个数组delete a[2]; // 删除最后一个数组元素2 in a; // =&gt; false: 元素2在数组中已经不存在了a.length; // 3: 没有改变 大家都知道，Array是Object的一个子类，本质上是对象。在删除数组的属性时，行为跟作用与对象无二。 从上面的例子可以发现，删除属性或者删除数组元素不仅仅是设置了一个undefined的值。当删除一个属性的时候，这个属性将不再存在了。读取一个不存在的属性将返回undefined，但是可以通过in运算符，来检测这个属性是否在对象中存在。 某些属性不能删除并不是所有的属性都可以删除，一些内置核心的客户端属性是不能删除的，用户通过var语句声明的变量不能删除。同样，通过function语句定义的函数和函数参数也是不能删除的。 在ECMAScript 5严格模式中，如果delete是非法的，则会返回语法错误SyntaxError。 在非严格模式中，非法错误将返回false值。 这里有些关于delete运算符的例子：1234567891011var o = &#123; x:1, y=2 &#125;; // 定义一个变量，初始化对象delete o.x; // =&gt; true: 删除成功typeof o.x; // =&gt; \"undefined\"delete o.x; // =&gt; 删除不存在属性，返回\"true\"delete o; // 不能删除通过var声明的变量，返回false // 在严格模式下会抛出异常delete 1; // 参数不是一个左值，返回truethis.x = 1; // 全局定义一个属性，没有用vardelete x; // 试图删除它，在非严格模式下返回true // 在严格模式下会抛出异常，可以用\"delete this.x\"代替x; // 运行错误，没有定义x 关于上面例子，有一点在我看到这个例子的时候特别困惑：this.x并没有用var定义，但为什么在严格模式下执行delete操作会抛出异常呢？按照正常情况下是能够被删除。请注意，严格模式规定变量都需要使用var操作符定义，所以不存在不用var定义这一做法。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中eval()函数详解","slug":"Javascript中eval-函数详解","date":"2017-10-03T06:33:34.000Z","updated":"2018-04-10T03:45:06.000Z","comments":true,"path":"2017/10/03/Javascript中eval-函数详解/","link":"","permalink":"/2017/10/03/Javascript中eval-函数详解/","excerpt":"eval()是一个函数，但它已经被当成是运算符来对待了。如果一个函数调用了eval()，那么解析器将无法对这个函数进行优化。eval()函数可以用来使用制作在线的Javascript解析器，或者是作手动的函数优化。","text":"eval()是一个函数，但它已经被当成是运算符来对待了。如果一个函数调用了eval()，那么解析器将无法对这个函数进行优化。eval()函数可以用来使用制作在线的Javascript解析器，或者是作手动的函数优化。 eval()eval()只有一个参数。如果传入的参数不是字符串，它直接返回这个参数。如果参数是字符串，它会把字符串当成Javascipt代码进行编译。 关于eval()最重要的是，它使用了调用它的变量作用域环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。 如果在最顶层代码中调用eval()，当然，它会作用于全局变量和全局函数。 全局eval()ECMAScript 3标准规定了任何解析器都不允许对eval()赋予别名。如果eval()函数通过别名调用的话，则会抛出一个EvalError异常。 事实上，大多数的实现并不是这么做的。 当通过别名调用的时候，eval()会将其字符串当成顶层的全局代码来执行。执行的代码可能会定义新的全局变量和全局函数。 ECMAScript 5是反对使用EvalError的，并且规范了eval()的行为。“直接的eval”，当直接使用非限定的“eval”名称（eval看起来像是一个保留字）来调用eval()函数时，通常成为“直接eval”。直接调用eval()时，它总是在调用它的上下文作用域内执行。其他的间接调用则会使用全局对象作为其上下文的作用域，并且无法读、写、定义局部变量和函数。 ——摘录自《Javascript权威指南》 上面这段话很长，但是我们可以用简洁的语言归纳：ES 5在打ES 3的脸，浏览器对ES 3的抗议获得大成功，ES 5将大部分浏览器对eval()的实现纳入了标准。 下面有一段示例代码：1234567891011121314var geval = eval; // 使用别名调用eval将会是全局evalvar x = \"global\",y = \"global\"; // 两个全局变量function f() &#123; // 函数内执行的是局部eval var x = \"local\"; // 定义局部变量 eval(\"x += 'changed';\"); // 直接eval更改了局部变量和值 return x; // 返回更改后的局部变量&#125; function g() &#123; // 这个函数内执行了全局eval var y = \"local\"; // 定义局部变量 geval(\"y += 'changed';\"); // 间接调用改变了全局变量的值 return y; // 返回未更改的局部变量&#125;console.log(f(), x); // \"localchanged global\"console.log(g(), y); // \"local globalchanged\" 严格eval()ECMAScript 5严格模式对eval()施加更多的限制。 严格模式下，eval执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新的变量或函数。 此外，严格模式将”eval”列为保留字，这让eval()更像一个运算符。不能用一个别名覆盖eval()函数。并且变量名、函数名、函数参数或者异常捕获的参数都不能取名为”eval”。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript带操作的赋值运算——小坑","slug":"Javascript带操作的赋值运算——小坑","date":"2017-10-01T13:46:49.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/10/01/Javascript带操作的赋值运算——小坑/","link":"","permalink":"/2017/10/01/Javascript带操作的赋值运算——小坑/","excerpt":"所谓“带操作的赋值运算”，就是带“op =”的赋值运算，比如*=。在一般情况下，这种表达式会有几乎等价的语句。但在特殊情况下，它们又是有区别的。","text":"所谓“带操作的赋值运算”，就是带“op =”的赋值运算，比如*=。在一般情况下，这种表达式会有几乎等价的语句。但在特殊情况下，它们又是有区别的。 带操作的赋值运算有很多，如+=、-=、*=、/=、%=等，还有跟二进制运算有关的运算符，我这里就不一一列举出来了。 大多数情况下，表达式为1a op = b 这里op代表一个运算符，这个表达式如下面的表达式等价：1a=a op b 在第一行中，表达式a只计算了一次，在第二行中，表达式a计算了两次。只有a包含具有副作用的表达式的时候，两者才不等价。比如，下面两个表达式就是不等价的：12data[i++] *= 2data[i++] = data[i++] * 2 可能不太容易看懂，我们举个实例12345678910111213// 例一var data = [1,3,5]; // 定义一个数组var i = 0;data[i++] *= 2;console.log(data); // =&gt; [2,3,5]console.log(i); // =&gt; 1：计算了一次// 例二var data = [1,3,5]; // 初始化数组var i = 0;data[i++] = data[i++] * 2console.log(data); // =&gt; [6,3,5]console.log(i); // =&gt; 2:计算了两次 分析： 例一中，表达式将左侧的i++放在了最后，首先计算了data[0]*2的值，得到2，再将2赋值给了data[0]，最后才运算i++； 例二中，表达式首先计算了右侧的i++，所以右侧的值为data[1]*2即6。然后将右侧的值赋值给data[1]，最后再执行一次左侧的i++。 可以说，这种带副作用的运算十分复杂和混乱，建议实际上不要将带副作用的左值放在左侧。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript逻辑运算符——原理详解","slug":"Javascript逻辑运算符——原理详解","date":"2017-09-30T16:38:48.000Z","updated":"2018-04-10T03:45:06.000Z","comments":true,"path":"2017/10/01/Javascript逻辑运算符——原理详解/","link":"","permalink":"/2017/10/01/Javascript逻辑运算符——原理详解/","excerpt":"最开始我看廖学锋的javascript教程，以为&amp;&amp;是直接返回一个布尔值ture或者false，直到我膝盖中了一剪，遇到犀牛书，突然恍然大悟。","text":"最开始我看廖学锋的javascript教程，以为&amp;&amp;是直接返回一个布尔值ture或者false，直到我膝盖中了一剪，遇到犀牛书，突然恍然大悟。 逻辑与（&amp;&amp;）犀牛书中描述了&amp;&amp;的第三层理解： 运算符首先计算左操作数的值，即首先计算“&amp;&amp;”左侧的表达式。如果计算结果是加值，那么整个表达式的结果一定是假值，因此“&amp;&amp;”这时简单地返回左操作数，并不会对右操作数进行计算。 反过来讲，如果左操作数是真值，那么整个表达式的结果则依赖于右操作数的值。 假值是false、null、undefined、0、-0、NaN和&quot;&quot; 1234var o = &#123; x:1 &#125;;var p = null;o &amp;&amp; o.x // =&gt;1:0 是真值，因此返回值为o.xp &amp;&amp; p.x // =&gt;null: p是假值，因此将其返回，并不去计算p.x 逻辑或（||）尽管“||”运算大多情况下只是做简单布尔或（OR）运算，和“&amp;&amp;”一样，它也具有一些更复杂的行为。 它会首先计算第一个操作数的值，也就是说会首先计算左侧的表达式。如果计算结果为真值，那么返回这个真值。否则，再计算第二个操作数的值，即计算右侧的表达式，并返回这个表达式的计算结果。 1234// 如果max_width已经定义了，直接使用它// 否则在preferences对象中查找max_width// 如果没有定义它，则使用一个写死的常量var max = max_width || preferences.max_width || 500; 逻辑非（!）“!”运算符首先将其操作数转换为布尔值，然后再对布尔值求反。 也就是说“!”总是返回true或者false。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中instanceof运算符","slug":"Javascript中instanceof运算符","date":"2017-09-30T16:11:22.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/10/01/Javascript中instanceof运算符/","link":"","permalink":"/2017/10/01/Javascript中instanceof运算符/","excerpt":"了解javascript中instanceof运算符原理，有利于在实际开发中更好地使用这个运算符。","text":"了解javascript中instanceof运算符原理，有利于在实际开发中更好地使用这个运算符。 instanceof运算符实例instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回true；否则返回false。123456789var d = new Date(); // 创建一个Date对象d instanceof Date; // =&gt; trued instanceof Object; // =&gt; falsed instanceof Number; // =&gt; falsevar a = [1,2,3];a instanceof Array; // =&gt; truea instanceof Object; // =&gt; truea instanceof RegExp; // =&gt; false instanceof运算符原理为了理解instanceof运算符是如何工作的，必须首先理解“原型链”。为了计算表达式o instanceof f，Javascript首先计算f.prototype，然后在原型链中查找o，如果找到，返回true，否则为false。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript二进制浮点数和四舍五入错误","slug":"Javascript二进制浮点数和四舍五入错误","date":"2017-09-30T15:11:24.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/09/30/Javascript二进制浮点数和四舍五入错误/","link":"","permalink":"/2017/09/30/Javascript二进制浮点数和四舍五入错误/","excerpt":"Javascript的浮点数采用的是二进制表示法，虽然不清楚具体的算法，但知道这种表示法会造成浮点数的误差。如果网站要进行高精度的计算，涉及经融或大计算领域，尽可能使用整数运算。","text":"Javascript的浮点数采用的是二进制表示法，虽然不清楚具体的算法，但知道这种表示法会造成浮点数的误差。如果网站要进行高精度的计算，涉及经融或大计算领域，尽可能使用整数运算。 实数有无数多个，但Javascript通过浮点数形式只能表示其中的有限个数（确切地说是18 437 736 874 454 810 627个）。也就是说，当在Javascript中使用实数的时候，常常只是真实值的一个近似表示。 Javascript采用了IEEE-754浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如,1/2、1/8和1/1024。遗憾的是，我们常用的分数都是十进制分数1/10、1/100等。二进制浮点数表示法并不能精确表示类似0.1这样简单的数字。 **Javascript中数字具有足够的精度，并可以极其近似于0.1.但事实上，数字不能精确表述的确带来一些问题。看下这段代码：12345var x = .3 - .2; // 30美分减去20美分var y = .2 - .1; // 20美分减去10美分x == y // =&gt; false:两值不相等x == .1 // =&gt; false: .3-.2不等于 .1y == .1 // =&gt; true: .2-.1等于.1 由于舍入误差，0.3和0.2之间的近似差值实际上不等于0.2和0.1之间的近似差值注译1。这个问题并不只在Javascript中才出现，理解这一点非常重要：在任何使用二进制浮点数的编程语言都会有这个问题。通过需要主要的是，上述代码中x和y的值非常接近彼此和最终的正确值。这种计算结果可以胜任大多数的计算任务：这个问题也只有在比较两个值是否相等的时候才会出现。 Javascript的未来版本或许会支持十进制数字类型以避免这些舍入问题。在这之前你可以更愿意使用大整数进行重要的金融计算，例如，要使用整数“分”而不要使用小数“圆”进行基于货币单位的运算。 注译1：在Javascript的真实环境中，0.3-0.2=0.099 999 999 999 999 98","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript作用域链详解","slug":"Javascript作用域链详解","date":"2017-09-30T07:41:32.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/09/30/Javascript作用域链详解/","link":"","permalink":"/2017/09/30/Javascript作用域链详解/","excerpt":"学习的时候碰到了作用域链，但是书上用了大块文字说明作用域链的机制，所以我写一篇文章，以梳理作用域链的知识。","text":"学习的时候碰到了作用域链，但是书上用了大块文字说明作用域链的机制，所以我写一篇文章，以梳理作用域链的知识。 作用域链的变量解析每一段Javascript（全局代码或函数）都有一个与之关联的作用域链（scope chain）。scope n. 范围；余地；视野；眼界；导弹射程 vt. 审视 这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。 当Javascript需要查找变量x的值的时候（这个过程称作“变量解析”），它会从链的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值。 如果没有一个对象拥有属性x，则会抛出一个错误。123 对象A =&gt; 对象B =&gt; 对象C——————————————————————————&gt; 作用域链 作用域链的更新不嵌套时作用域链在不包括嵌套的函数体内，作用域链上有两个对象，第一个是定义函数参数和局部变量的对象，第二个是全局对象。123456789// 对于一个不嵌套的函数function f(x) &#123;&#125;// 作用域链为对象A &#123; 函数参数x： 局部变量：&#125; ↓全局对象window &#123; &#125; 作用域链创建规则当调用这个函f(x)时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建一个新的更长的表示函数调用作用域的“链”。 对于嵌套函数，事情更加有趣。 每次调用外部函数时，内部函数都会重新定义一次。因为每次调用外部函数的时候，作用域链都是不同的。 内部函数在每次定义的时候都有微妙查表——在每次调用外部函数的时候，内部函数的代码都是相同的，而且关联这段代码的作用域链也不想他。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript全局变量声明和不声明的区别","slug":"Javascript全局变量声明和不声明的区别","date":"2017-09-30T07:41:12.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/09/30/Javascript全局变量声明和不声明的区别/","link":"","permalink":"/2017/09/30/Javascript全局变量声明和不声明的区别/","excerpt":"在非严格模式下，利用var声明全局变量，和不用var声明直接赋值，两者在普通的使用上几乎是一样的。唯一的区别是能够被delete。","text":"在非严格模式下，利用var声明全局变量，和不用var声明直接赋值，两者在普通的使用上几乎是一样的。唯一的区别是能够被delete。 当声明一个Javascript全局变量时，实际上是定一个全局变量的属性。 当使用var声明一个变量时，创建的这个属性是不可配置的，也就是收这个变量无法通过delete运算符删除。 如果你没有使用严格模式并给一个未声明的变量赋值的话，Javascript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们： 下面分别通过不同的方式创建全局变量：123var truevar = 1; // 声明一个不可删除的全局变量fakevar = 2; //创建全局对象的一个可删除属性this.fakevar2 = 3; // 同上 利用delete删除变量123delete truevar // =&gt; falsedelete fakevar // =&gt; truedelete this.fakevar2 // =&gt; true true: 变量被删除false: 变量并没有被删除","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript函数作用域","slug":"Javascript函数作用域","date":"2017-09-30T07:05:25.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/09/30/Javascript函数作用域/","link":"","permalink":"/2017/09/30/Javascript函数作用域/","excerpt":"在一些类似C语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域，而Javascript没有块级作用域的概念，取而代之的是函数作用域。——摘录自犀牛书","text":"在一些类似C语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域，而Javascript没有块级作用域的概念，取而代之的是函数作用域。——摘录自犀牛书 Javascript的函数作用域是指函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。Javascript的这个特性被非正式地成为声明提前，即Javascript函数里生命的所有变量都被“提前”至函数体的顶部。 来看以下代码：123456var scope = \"global\";function f() &#123; console.log(scope); // 输出\"undefined\"，而不是\"global\" var scope = \"local\"; console.log(scope); // 输出\"local\"&#125; 你可能会误以为函数中的第一行会输出”global”，因为代码还没执行到var语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部遮盖了同名全局变量。尽管如此，只有在程序执行到var语句的时候，局部变量才真正赋值。因此，上述过程等价于： 将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：123456function f() &#123; var scope; console.log(scope); scope = \"local\"; console.log(scope);&#125; ————以上摘录自《Javascript权威指南》 总结：为了避免声明提前而使访问值变为undefined，尽可能地在狭小的作用域中让变量声明和使用变量的代码尽可能靠近彼此。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript对象转换为原始值详解","slug":"Javascript对象转换为原始值详解","date":"2017-09-30T05:30:52.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/09/30/Javascript对象转换为原始值详解/","link":"","permalink":"/2017/09/30/Javascript对象转换为原始值详解/","excerpt":"对象到布尔值的转换非常简单，所有的对象（包括包装对象）都会转换为true。而对象到数字、对象到字符串，则涉及到两个方法：toString和valueOf，情况相当复杂。就此做知识归纳。","text":"对象到布尔值的转换非常简单，所有的对象（包括包装对象）都会转换为true。而对象到数字、对象到字符串，则涉及到两个方法：toString和valueOf，情况相当复杂。就此做知识归纳。 所有的对象继承了两个转换方法。第一个是toString(),它的作用是返回一个反映这个对象的字符串。 另一个转换对象的函数是valueOf()。默认的valueOf()方法简单地返回对象本身。 下面对这两个函数进行详细分析： toString()实例不同的对象对toString()的实现不一样：12345(&#123;x:1, y:2&#125;).toString() // =&gt; \"[object, Object]\"[1,2,3].toString() // =&gt; \"1,2,3\"(function(x) &#123; f(x); &#125;).toString() // =&gt; \"function(x) &#123;\\n f(x);\\n&#125;\"/\\d+/g.toString() // =&gt; \"/\\\\d+/g\"new Date(2010,0,1).toString() // =&gt; \"Fri Jan 01 2010 00:00:00 GMT-0800 (PST)\" 从上面的实例可以发现，对于一般对象{}，函数返回的字符串确实没有太大价值意义。而function和RegExp直接返回的是实现定义和直接量字符串，Date对象则通过一定的规则转换后得到近似于直接量的字符串。数字[]则是使用了join(“,”)方法，将各个子值拼在一起。 valueOf()实例12345(&#123;x:1, y:2&#125;).valueOf() // =&gt; Object &#123;x: 1, y: 2&#125; 对象[1,2,3].valueOf() // =&gt; [1, 2, 3](function f(x) &#123; f(x); &#125;).valueOf() // =&gt; function f(x) &#123; f(x); &#125; 对象/\\d+/g.valueOf() // =&gt; /\\d+/gnew Date(2010,0,1).valueOf() // =&gt; 1262275200000 对比toString()可以看到，valueOf()对数组、正则、函数、普通对象都只会返回他们自己本身。Date对象返回的是从1970年1月1日开始计算的毫秒数，属于数值类型。 对象与运算符原则和“==”一样， “&lt;”运算符以及其他关系运算符也会做对象到原始值的转换，但除去日期对象的特殊情况。 任何对象都会首先尝试调用valueOf()，然后调用toString()。不管得到的原始值是否直接使用，它都不会进一步被转换为数字或字符串。 看下面例子：123(function f()&#123;return&#125;) &gt; 1 // =&gt; false(function f()&#123;return&#125;) &lt; 1 // =&gt; false(function f()&#123;return&#125;) = 1 // =&gt; false 函数对象先是经过valueOf()转换得到自身，再通过toString()获得&quot;function(x) {\\n f(x);\\n}&quot;的定义表达式，本质是一个字符串。字符串和一个数字比较都会获得false布尔值，由此解释上面的结果。 日期对象在运算符前，日期对象类型的转换稍微不一样，可以观察下面例子：12345var now = new Date(); // 创建一个日期对象typeof (now + 1) // =&gt; \"string\"typeof (now - 1) // =&gt; \"number\"now == now.toString() // =&gt; truenow &gt; (now - 1) // =&gt; true 在+号运算加合数字的时候，日期对象使用toString()会变换为字符串，再将1变成&quot;1&quot;字符串，通过+拼合，得到的结果为&quot;Sat Sep 30 2017 14:11:17 GMT+0800 (中国标准时间)1&quot;。而非使用valueOf()变成数值，在此基础上加一。在使用日期对象进行运算的时候，应该显式转换为数值，再进行运算。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中小数点的处理","slug":"Javascript中小数点的处理","date":"2017-09-29T16:30:12.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/09/30/Javascript中小数点的处理/","link":"","permalink":"/2017/09/30/Javascript中小数点的处理/","excerpt":"在处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数点位置和有效数字位数，或者决定是否需要指数计数法。","text":"在处理财务或科学数据的时候，在做数字到字符串的转换过程中，你期望自己控制输出中小数点位置和有效数字位数，或者决定是否需要指数计数法。 Number类为数字到字符串的转换提供三个方法toFixed()、toExponential()、toPrecision(),它们都有一个必须的数值参数。 先定一个数字1var n = 123456.789 toFixed 固定的根据小数点后的指定位数将数字转换为字符串。它从不使用指数记数法123n.toFixed(0); // \"123457\"n.toFixed(2); // \"123456.79\"n.toFixed(5); // \"123456.78900\" toExponential 指数的使用指数记数法将数字转换为指数类型的字符串，其中小数点前只有一位，小数点后的位数则由参数指定12n.toExponential(1); // \"1.2e+5\"n.toExponential(3); // \"1.235e+5\" toPrecision 精密的根据指定的有效数字位数将数字转换成字符串。如果有效数字少于数字整数部分的位数，则转换成指数形式。123n.toPrecision(4); // \"1.235e+5\"n.toPrecision(7); // \"123456.8\"n.toPrecision(10); // \"123456.7890\" 我们注意到，所有三个方法都会适当地进行四舍五入或填充0. 另外，toExponential、toPrecision的转换都是不可逆，无法通过toString变成原始值。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"Javascript中数字进制的转换","slug":"Javascript中数字进制的转换","date":"2017-09-29T16:05:44.000Z","updated":"2018-04-10T03:45:06.000Z","comments":true,"path":"2017/09/30/Javascript中数字进制的转换/","link":"","permalink":"/2017/09/30/Javascript中数字进制的转换/","excerpt":"看犀牛书的时候，看到了一些数值转换的方法，再次记录一下。","text":"看犀牛书的时候，看到了一些数值转换的方法，再次记录一下。 javascript中的数值转换利用的是全局函数parseInt()和包装对象方法toString()。 parseInt()parseInt()可以将任意字符串转换成十进制整数，前提是字符串符合要求。1parseInt(\"3 blind mice\") // =&gt; 3 对于以0x开头的字符串，函数会自动解析为十六进制字符串12parseInt(\"0xFF\") // =&gt; 255parseInt(\"0xff\") // =&gt; 255 也可以接受第二个可选参数，用来指定数字转换的基数1parseInt(\"077\", 8) // =&gt; 63 (7*8 + 8) 在ECMAScript 3中，parseInt()是可以对以前缀”0”开头的的数字进行八进制的转换，到了ECMAScript 5之后就被禁止了。如果需要做八进制的转换，需要显式设置。 s.toString()先随便定义一个字符串1var n = \"17\"; 关于这个函数的转换机制就不多说了，直接上实例：123var binary_string = n.toString(2) // 转换为\"10001\"var octal_string = \"0\" + n.toString(8) // 转换为\"021\"var hex_string = \"0x\" + n.toString(16) // 转换为\"0x11\" 利用这两个函数，即可在页面上进行随意的数字进制转换。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"}]},{"title":"git入门——安装","slug":"git入门——安装","date":"2017-09-24T13:51:38.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/09/24/git入门——安装/","link":"","permalink":"/2017/09/24/git入门——安装/","excerpt":"如果有很多台电脑，每次都要看看找找教程再安装太麻烦了，干脆在这里写好然后多看看。","text":"如果有很多台电脑，每次都要看看找找教程再安装太麻烦了，干脆在这里写好然后多看看。 安装windows上面的安装下载安装 git for windows Ubuntu上面的安装1$ sudo apt-get install git git的设置因为Git是分布式版本管理系统，所以，每台机器必须自报家门12$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" 创建版本库创建库文件夹在一个合适的地方创建文件夹12$ mkdir learngit$ cd learngit 初始化文件夹1$ git init 这时候会创建一个名为.git的文件夹。 远程仓库创建SSH KEY1$ ssh-keygen -t rsa -C \"youremail@example.com\" 这时候会在主目录下找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 Add SSH KEY登录GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。 远程推送在本地仓库下执行1$ git remote add origin git@github.com:michaelliao/learngit.git 然后将本地的所有内容都推送到远程库上1git push -u origin master 在以后，只要在本地作业，就能通过命令推送到github1git push origin master 克隆库1git clone","categories":[{"name":"网站维护","slug":"网站维护","permalink":"/categories/网站维护/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"git入门——常用操作","slug":"git入门——常用操作","date":"2017-09-24T05:50:03.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/09/24/git入门——常用操作/","link":"","permalink":"/2017/09/24/git入门——常用操作/","excerpt":"看了一下廖雪峰的git教程，觉得要熟悉git的操作需要一段适应时间，于是我干脆在这里写一篇总结性的git常用操作集合，方便自己日后推送和维护项目。","text":"看了一下廖雪峰的git教程，觉得要熟悉git的操作需要一段适应时间，于是我干脆在这里写一篇总结性的git常用操作集合，方便自己日后推送和维护项目。 日常操作12345678910$ git add filename #添加文件$ git commit -m \"some message\" #提交文件$ git status #查看状态$ git diff #查看修改内容$ git log --pretty=oneline #查看提交记录$ git reset --hard HEAD^ #退回上一个版本$ git reflog #查看命令历史$ git checkout -- filename #丢弃工作区的修改$ git reset HEAD filename #丢弃缓存区的修改$ git rm filename #删除文件 分支的使用123456789$ git branch dev #创建分支$ git checkout dev #切换分支$ git checkout -b dev #创建并切换分支$ git branch #查看分支$ git merge dev #合并分支$ git branch -d dev #删除分支$ git merge --no-ff -m \"some message\" dev #合并的同时commit$ git push origin master #推送master主分支$ git push origin dev #推送dev分支 工作现场stash123456$ git stash #存储工作现场$ git stash list #查看工作现场$ git stash apply #恢复工作现场$ git stash drop #删除工作现场$ git stash pop #恢复和删除工作现场$ git stash apply stash@&#123;0&#125; #恢复指定stash 标签tag标签可以用来管理版本号，一般标记在master分支上123456789101112131415$ git tag v1.0 #为当前分支打上标签$ git tag #查看所有标签$ git tag v0.9 6224937 #为指定commit打上标签$ git tag -a v0.1 -m \"version 0.1 released\" 3628164 #附带信息$ git show v0.9 #查看标签信息$ git tag -d v0.1 #本地删除标签$ git push origin v1.0 #远程推送标签$ git push origin --tags #远程推送所有标签删除远程标签// 先从本地删除$ git tag -d &lt;tagname&gt;// 再从远程删除$ git push origin :refs/tags/&lt;tagname&gt; 远程协作12345678910111213141516171819202122232425262728//克隆远程仓库$ git clone git@github.com:michaelliao/learngit.git//创建本地dev分支$ git checkout -b dev origin/dev对dev修改后可以推送提交//推送dev分支$ git push origin dev如果其他人已经推送了新的版本，会显示有冲突//将其他人最新的提交抓去下来$ git pull但是git pull会失败，原因是没有设置链接//建立本地分支和远程分支的关联$ git branch --set-upstream branch-name origin/branch-name//合并库$ git commit -m \"merge &amp; fix hello.py\"如果有冲突，就解决掉//再次推送到dev分支上$ git push origin dev","categories":[{"name":"网站维护","slug":"网站维护","permalink":"/categories/网站维护/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"git","slug":"git","permalink":"/tags/git/"}]},{"title":"JQuery增删cookie","slug":"JQuery增删cookie","date":"2017-09-22T15:03:07.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/09/22/JQuery增删cookie/","link":"","permalink":"/2017/09/22/JQuery增删cookie/","excerpt":"有一些项目需要大量部署cookie增删的代码，比如登录系统。通过使用jquery.cookie.js插件，实现JQuery对cookie的控制。","text":"有一些项目需要大量部署cookie增删的代码，比如登录系统。通过使用jquery.cookie.js插件，实现JQuery对cookie的控制。 引入jquery.cookie.js库文件 下载jquery.cookie.jsCSDN下载地址下载需要1积分，申请帐号后做点小任务吧。 引入jquery和cookie插件。要先引入jQuery的库文件，和 jquery.cookie.js 的库文件。 需要注意的是：JQuery必须先行引入，而后才是cookie文件，反正则错误。 来看一个例子：1234567891011121314151617181920212223242526272829303132&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;js中字符串处理&lt;/title&gt; &lt;/head&gt; &lt;script type=\"text/javascript\" src=\"js/jquery-1.8.0.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/jquery.cookie.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function newCookieFunc()&#123; $.cookie('cookieId',\"201211011\",&#123;expires:2,path: '/'&#125;); $.cookie('cookieName',\"linzhiqiang\",&#123;expires:2,path: '/'&#125;); alert(\"新建cookie成功，值分别为：cookieId：201211011 cookieName：linzhiqiang\"); &#125;; function getCookieFunc()&#123; var cookieId=$.cookie('cookieId'); var cookieName=$.cookie('cookieName'); alert(\"cookie的值分别为：cookieId：\"+cookieId+\" cookieName：\"+cookieName); &#125;; function deleteCookieFunc()&#123; $.cookie('cookieId',null,&#123;expires:-1,path: '/'&#125;); $.cookie('cookieName',null,&#123;expires: -1,path: '/'&#125;); alert(\"删除cookie成功\"); &#125;; &lt;/script&gt; &lt;body&gt; &lt;input type=\"button\" onclick=\"newCookieFunc();\" value=\"利用JQuery新建cookie信息\"&gt;&lt;/br&gt; &lt;input type=\"button\" onclick=\"getCookieFunc();\" value=\"利用JQuery读取cookie信息\"&gt;&lt;/br&gt; &lt;input type=\"button\" onclick=\"deleteCookieFunc();\" value=\"利用JQuery删除cookie信息\"&gt;&lt;/br&gt; &lt;/body&gt; &lt;/html&gt; cookie参数解析1. expires: 365定义cookie的有效时间，值可以是一个数字（从创建cookie时算起，以天为单位）或一个Date 对 象。如果省略，那么创建的cookie是会话cookie，将在用户退出浏览器时被删除。2. path: ‘/‘默认情况：只有设置cookie的网页才能读取该cookie。 定义cookie的有效路径。默认情况下，该参数的值为创建 cookie 的网页所在路径（标准浏览器的行为）。如果你想在整个网站中访问这个cookie需要这样设置有效路径：path: ‘/‘。如果你想删除一个定义 了有效路径的 cookie，你需要在调用函数时包含这个路径:$.cookie(‘the_cookie’, null, { path: ‘/‘ });。 domain: ‘example.com’ 默认值：创建 cookie的网页所拥有的域名。3. secure: true默认值：false。如果为true，cookie的传输需要使用安全协议（HTTPS）。4. raw: true默认值：false。 默认情况下，读取和写入 cookie 的时候自动进行编码和解码（使用encodeURIComponent 编码， decodeURIComponent 解码）。要关闭这个功能设置 raw: true 即可。 参考文章——CSDN","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"/tags/javascript/"},{"name":"JQuery","slug":"JQuery","permalink":"/tags/JQuery/"},{"name":"cookie","slug":"cookie","permalink":"/tags/cookie/"}]},{"title":"碰巧生而为人 You're Just In Fortune","slug":"碰巧生而为人","date":"2017-09-22T14:31:35.000Z","updated":"2019-04-01T14:52:45.953Z","comments":true,"path":"2017/09/22/碰巧生而为人/","link":"","permalink":"/2017/09/22/碰巧生而为人/","excerpt":"偶然看到了一些很有意义的文章，同时也阅读了一些有思考性的书籍，我想通过一篇文章，阐述一下我对人和死亡的思考。由此写下这篇文章。这个故事讲述一个灵魂的不断轮回，由糜烂到新生，导出生而为人的意义。","text":"偶然看到了一些很有意义的文章，同时也阅读了一些有思考性的书籍，我想通过一篇文章，阐述一下我对人和死亡的思考。由此写下这篇文章。这个故事讲述一个灵魂的不断轮回，由糜烂到新生，导出生而为人的意义。 一个让人难以忍受的夏天，我在树上呐喊。而不知为何，此生之始，我便拥有前世的记忆。 那时第一次拥有意识，碰巧生而为人。 记忆中是个遥远的时代，我生于帝王世家。我父亲是天下江山之主，我是他唯一的儿子，也是将来继承父亲王位之人。 四岁那年，父亲请来了全国最好的先生，向我传道授业。先生学识渊博，宽以待人，对我的栽培十分用心。但我辜负了先生的期望，终日嬉戏游玩，不思进取。在先生的一次阻拦中，我用皇家传承之剑刺向了他。先生离去之后，我更荒废度日。在皇城内，有绝世美人的歌舞，有天下厨神开设盛宴。偶然腰钱万贯，坐最豪华的船只游览大河，一去数月，尾随仆从数百。 有一个年轻人脸上有颗痣，在我面前路过。我看不顺眼，找人折磨他，把他的身体一块一块切下来。他在一片尖叫和血水死去，而身边没有一个人敢言半句。那一刻我发现，自己竟然看其他人如畜生一般。 糜烂的日子没有一天消停过，父皇多次请来先生给我上课，而我不屑一顾。不久，国家分崩离析，父皇重病一卧不起。在我在举行杀人比赛的过程中，一些身穿盔甲的人闯进我的寝室，给我射了一箭。临死前，镜子中映照着自己肥硕的身躯。那一刻我发现，自己竟然碰巧生而像人罢了。 大概是上天的惩罚吧，我开始了作为畜生轮回。 记得一次我作为家禽，每天吃着同样的饲料，看着一样的天空。那些称鸡哥鸭哥的兄弟们，只会在原地打转，双目无神，眼看着他们一天比一天肥胖，数量一天比一天少。终于有一天，我被抓住了翅膀，刀在我脖子落下。我意识到，自己将成为“猴子”餐桌上的美食，我的一生已经终结。 我又进入了家禽的轮回，某日我发现自己受够了。 记得那次我又是作为家禽，吃着一样的饲料，关进类似的牢笼。天下大雨，地上有积水。我惊讶地发现脚下的倒影跟我眼前的兄弟们如出一辙，似乎餐桌上的那块肉是谁都可以。我意识到自己短暂的生命，逃不过人类的屠刀，逃不过天敌的爪牙。那个晚上，我没有闭上过眼睛，第二天，绝食死了。 记得一次我作为家猪，逃出了那个“同类”的牢笼，向森林奔去，对那时候的我来说，外面有我的自由，是我作为家猪的梦想。但命运似乎没有打算放过我。我剧烈奔跑，滚下了山崖，死了。 轮回稍微不一样，这次我天生拥有“自由”。 记得一次我作为野狼，总为食物四处奔波，碰巧进入了某个小村落。一个房子里面有一个自己的“同类”，他说自己生活很好，不愁吃不愁住，还邀请自己一同居住。我仅仅给了他一个鄙夷眼神，便走开了。我跟伙伴一同捕猎村中的羊，不慎掉进陷阱里。绝望和饥渴，让我们互食同类。这本是我追求的自由，但是到底有什么不对？ 我又坠入轮回，在今生以蝉诞生。 回忆起前世的种种事情，我希望实现自己的梦想，那就是能在人间留下痕迹。于是我爬上了树，日夜不休地鸣叫。也许我永远无法弥补以前的过错，或许此生知前世只是一个上天的失误。一旦我闭上了眼睛，再次睁开可能是猪的模样。但是我真的很希望，人间有人能记住我。 在第十五个夏日里，我气绝身亡。 时间过得飞快，无数高楼立地而起。在时间的某个断点，一个小伙子健康出生。他本能般抓住自己身边的一点一滴，尝试为身边带来欢乐。他说他自己的梦想是成为一个音乐家，让他原创的音乐留存在每个人心中。 某日，一家意大利快餐店播放着本年度最流行的音乐，电视机播放《动物世界》一头狼的故事，而作曲者他在摆弄着炽热的猪扒。突然上天在他耳边低语，唤醒他前世的记忆。 他喜极而泣，他说，感谢自己碰巧生而为人。","categories":[{"name":"短篇小说","slug":"短篇小说","permalink":"/categories/短篇小说/"}],"tags":[{"name":"短篇小说","slug":"短篇小说","permalink":"/tags/短篇小说/"},{"name":"short novel","slug":"short-novel","permalink":"/tags/short-novel/"}]},{"title":"ajax+flask模拟表单提交","slug":"ajax-flask模拟表单提交","date":"2017-09-22T14:30:58.000Z","updated":"2019-03-27T16:11:29.808Z","comments":true,"path":"2017/09/22/ajax-flask模拟表单提交/","link":"","permalink":"/2017/09/22/ajax-flask模拟表单提交/","excerpt":"首先，当前端页面存在表单时，默认的commit往往不符合预期。即使页面html中存在表单验证功能，效果甚微。而commit之后不管三七二十一直接跳转到另一个页面，如果这符合你预期固然好，不过我一般还是用xhr(XMLHttpRequest)定制自己commit的事件","text":"首先，当前端页面存在表单时，默认的commit往往不符合预期。即使页面html中存在表单验证功能，效果甚微。而commit之后不管三七二十一直接跳转到另一个页面，如果这符合你预期固然好，不过我一般还是用xhr(XMLHttpRequest)定制自己commit的事件 前端首先取得commit的按钮节点1btn = form['commit-btn']; 取消默认行为12345678btn.onclick = function(e) &#123; e.preventDefault(); submit_btn.disabled = true; //禁用commit按钮 //表单验证 //数据处理 //xhr模拟提交 //相应后的操作&#125; 这里需要注意一下。return false也是可以阻止默认行为，但我们一般还需要表单验证，直接就return自然不符合我们的预期。禁用commit按钮是为了避免重复提交表单，需要启用按钮就改为=false就可以。 数据处理1234567// 基本格式name = '丽江';text = 'abc';name = encodeURIComponent(name);text = encodeURIComponent(text);data = 'name=' + name + '&amp;' + 'text=' + text;//name=%E4%B8%BD%E6%B1%9F&amp;text=abc xhr模拟表单提交12345xhr = new XMLHttpRequest();url = '/abc'; //自行修改地址xhr.open(\"post\", url,false); //同步提交为false，异步可以用truexhr.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\");//模拟表单需要修改headerxhr.send(data);//传输数据 获取相应后再操作页面12345678if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;300) || xhr.status == 304 ) &#123; submit_btn.disabled = false; //刷新页面 location.reload(); &#125; else &#123; alert('评论失败，请检查你的网络'); submit_btn.disabled = false; &#125; 提交失败后不要忘记将submit_btn开启(设置disable = false) 后台假设你有一个app.py1234567891011121314from flask import Flask,requestimport urllibfrom urllib import parseapp = Flask(__name__)@app.route('/abc',methods=['POST'])def comment_write(html_src): #一顿操作 passif __name__ == '__main__': app.run(host='0.0.0.0',port=80) //外网访问，host是关键 获取表单内容123name = urllib.parse.unquote(request.form['name']) #丽江text = urllib.parse.unquote(request.form['text']) #abc#unquote方法用来解析url参数 对post请求作出响应1return 'successful' 如果不做出请求响应，前台会认为响应失败，返回400状态码，相对地，相应成功会返回200和304，部分浏览器会返回204响应码。 总结ajax模拟表单提交实际上就是取消默认操作、获取表单数据并处理、xhr发送请求、相应处理的过程。大家可能注意到，即使前台使用默认的commit提交表单，后台代码也仅仅不需要unquote而已。可以说，使用ajax提交表单跟默认提交表单，后台操作是类似的。 在数据处理方面，有值得注意的地方。data数据的格式与get方法在地址栏提交的数据格式几乎一样（就是少了个？），猜测post请求提交数据的过程与get方法提交数据的原理是相似的，只是提交方式有差异。","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"flask","slug":"flask","permalink":"/tags/flask/"},{"name":"Ajax","slug":"Ajax","permalink":"/tags/Ajax/"},{"name":"表单","slug":"表单","permalink":"/tags/表单/"}]},{"title":"python中的Shebang","slug":"python中的Shebang","date":"2017-09-22T14:30:58.000Z","updated":"2020-05-31T11:47:58.560Z","comments":true,"path":"2017/09/22/python中的Shebang/","link":"","permalink":"/2017/09/22/python中的Shebang/","excerpt":"一般情况下，执行python文件的执行是通过python3命令执行。虽然Linux中内置了python解析器，但在并不能直接执行.py文件。原因是没有指定解析器，因此要想直接执行python主文件，可以使用Shebang。","text":"一般情况下，执行python文件的执行是通过python3命令执行。虽然Linux中内置了python解析器，但在并不能直接执行.py文件。原因是没有指定解析器，因此要想直接执行python主文件，可以使用Shebang。 LINUX 上的 Shebang 符号(#!) #!这个符号叫做 Shebang 或者 Sha-bang Shebang 通常在 Unix 系统脚本的中 第一行开头 使用 指明 执行这个脚本文件 的 解释程序 使用 Shebang 的步骤 使用 which 查询 python3 解释器所在路径 1$ which python3 修改要运行的 主 python 文件，在第一行增加以下内容 1#! /usr/bin/python3 修改 主 python 文件 的文件权限，增加执行权限 1$ chmod +x cards_main.py 在需要时执行程序即可 1./cards_main.py","categories":[{"name":"语言学习","slug":"语言学习","permalink":"/categories/语言学习/"}],"tags":[{"name":"python","slug":"python","permalink":"/tags/python/"}]},{"title":"手机端点击input禁止放大","slug":"手机端点击input禁止放大","date":"2017-09-22T14:28:41.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/09/22/手机端点击input禁止放大/","link":"","permalink":"/2017/09/22/手机端点击input禁止放大/","excerpt":"","text":"当点击手机表单，手机会自动放大，将窗口锁定到表单组件。为了让自己的网页看起来更像一个原生的app，我决定把手机发大这一默认行为禁掉。 如果不作特殊设置，在手机端的表单输入文本框会在被点击后放大，如果想取消这一行为，可以在头部加上：1&lt;meta name=\"viewport\" content=\"width=720,inital-scale=1.0,user-scalable=no;\"&gt; 再加上css样式：1input,input:focus,input:active&#123;user-select: text;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}]},{"title":"清除iphone页面input原有样式","slug":"清除iphone页面input原有样式","date":"2017-09-22T14:28:20.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/09/22/清除iphone页面input原有样式/","link":"","permalink":"/2017/09/22/清除iphone页面input原有样式/","excerpt":"","text":"我在做网站的时候遇到过这样的问题: 自己手机预览的页面跟其他手机的不一样。最初以为是手机浏览器问题，跑了一下acid，性能评分100，瞬间就蒙了。考虑到浏览器本身漏洞没有被测出来，用wechat测试了一下页面，预览结果还是不符合预期。最后，发现是iphone自身样式所致。 如果没有给页面的input和textarea设定详细的css样式，iphone显示的页面效果很可能跟自己在chrome上的有出入。原因是iphone页面显示有自带样式，，比如iphone的input圆角半径会较一般浏览器大，可能是内核问题（欢迎补充）。所以编写CSS的时候不要依赖调试浏览器中显示的样式，尽可能地给input设置详细的样式，当然，也可以使用一下代码： 123456input[type=\"text\"],input[type=\"button\"],input[type=\"submit\"],input[type=\"reset\"] &#123;-webkit-appearance: none;&#125;textarea &#123;-webkit-appearance: none;&#125; 参考资料——CSDN","categories":[{"name":"前端","slug":"前端","permalink":"/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}]},{"title":"Ubuntu初体验（三）——ftp安装和配置","slug":"Ubuntu初体验（三）——ftp安装和配置","date":"2017-09-21T16:19:03.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/09/22/Ubuntu初体验（三）——ftp安装和配置/","link":"","permalink":"/2017/09/22/Ubuntu初体验（三）——ftp安装和配置/","excerpt":"一般编辑文件都会在本地，服务器负责提供服务的。我将系统文件准备好，然后通过ftp推送给Ubuntu，过程很快而且很简单。","text":"一般编辑文件都会在本地，服务器负责提供服务的。我将系统文件准备好，然后通过ftp推送给Ubuntu，过程很快而且很简单。 文章大部分来自百度经验帖（文末），图片同样来自百度经验帖。由于按照百度经验操作会有一些坑，所以就自己写一篇更完整的博客。win10 + 阿里云 Ubuntu 14.05 安装一个基本的文本编辑器（gedit）12sudo apt-get install gedit #安装sudo apt-get remove gedit #卸载 Ubuntu中ftp的安装更新源列表1sudo apt-get update 安装vsftpd1sudo apt-get install vsftpd 判断vsftpd是否安装成功1sudo service vsftpd restart 新建用户主目录1sudo mkdir /home/uftp 查看是否成功。显示/home下所有可见文件夹。1sudo ls /home 新建用户uftp并设置密码。12sudo useradd -d /home/uftp -s /bin/bash uftp #新建用户名uftpsudo passwd uftp #依次输入两次密码即可 使用gedit修改配置文件/etc/vsftpd.conf1sudo gedit /etc/vsftpd.conf 向文件中添加添加12345userlist_deny=NOuserlist_enable=YESuserlist_file=/etc/allowed_usersseccomp_sandbox=NO 同时修改1local_enable=YES 保存 使用gedit新建/etc/allowed_users文件打开”终端窗口”，输入1sudo gedit /etc/allowed_users 输入uftp–&gt;保存 使用gedit查看/etc/ftpusers文件中的内容1sudo gedit /etc/ftpusers 打开这个文件后，看一看有没有uftp这个用户名，如果没有，就直接退出。如果有就删除uftp,因为这个文件中记录的是不能访问FTP服务器的用户清单。 win端的配置使用winscp登录FTP服务器除了winscp之外，还有很多优秀的ftp传输软件，如FileZilla,Xftp等。 下载安装WinSCP，运行WinSCP–&gt;输入IP、用户名、密码–&gt;保存–&gt;勾选”保存密码”–&gt;确定–&gt;登录–&gt;登录成功 如果上传失败(大坑)返回服务器终端1chmod -R 777 /home/uftp 修改配置文件1sudo gedit /etc/vsftpd.conf 添加12local_root=/home/uftpwrite_enable=YES 重启vsftpd服务1service vsftpd restart 参考资料——百度经验参考资料——550 Permission denied参考资料——553 Could not create file","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"}]},{"title":"Ubuntu初体验（二）——常用软件安装","slug":"Ubuntu初体验（二）——常用软件安装","date":"2017-09-21T16:18:29.000Z","updated":"2018-04-10T03:45:08.000Z","comments":true,"path":"2017/09/22/Ubuntu初体验（二）——常用软件安装/","link":"","permalink":"/2017/09/22/Ubuntu初体验（二）——常用软件安装/","excerpt":"安装过中文桌面后，还有一些常用的软件需要下载，如winrar等。对于是否安装软件，我的建议是能少就少，有什么从本地ftp推给服务器。","text":"安装过中文桌面后，还有一些常用的软件需要下载，如winrar等。对于是否安装软件，我的建议是能少就少，有什么从本地ftp推给服务器。 安装搜狗输入法 用自带的浏览器（gnome的是firefox）打开网址http://pinyin.sogou.com/linux/?r=pinyin 下载你需要的输入法版本，我这里是64位版的Ubuntu 下载完成后安装deb文件，跟着提示操作即可。 在终端输入im-config。跟着出现的对话框，点击&gt;OK&gt;yes，点击fcixt&gt;OK。 重启服务器，开始使用sogou输入法 参考文章 安装文本编辑器(atom为例) 使用PPA下载 123sudo add-apt-repository ppa:webupd8team/atomsudo apt-get updatesudo apt-get install atom 执行第一条的时候可能会报错sudo:add-apt-repository:command not found 终端运行以下命令后再使用PPA 12sudo apt-get install python-software-propertiessudo apt-get install software-properties-common 如果你想卸载 12sudo apt-get remove atomsudo add-apt-repository --remove ppa:webupd8team/atom WinRAR安装12sudo apt-get install rarsudo ln -fs /usr/bin/rar /usr/bin/unrar","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"}]},{"title":"Ubuntu初体验（一）——配置桌面环境","slug":"Ubuntu初体验（一）——配置桌面环境","date":"2017-09-21T15:22:49.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/09/21/Ubuntu初体验（一）——配置桌面环境/","link":"","permalink":"/2017/09/21/Ubuntu初体验（一）——配置桌面环境/","excerpt":"阿里云的服务器，如果使用的是Linux系统，一开始只有命令行界面，对于想要好好学习的我简直吓坏了，所以安装一个界面方便使用。不过要注意，安装桌面环境会一定程度上降低服务器的性能，但是对于我这种简单部署就不会有大的阻碍。","text":"阿里云的服务器，如果使用的是Linux系统，一开始只有命令行界面，对于想要好好学习的我简直吓坏了，所以安装一个界面方便使用。不过要注意，安装桌面环境会一定程度上降低服务器的性能，但是对于我这种简单部署就不会有大的阻碍。 由于我以前使用的是国产的deepin，之后使用阿里云Ubuntu的时候简直吓坏了，只有命令行界面。在安装桌面环境的时候也遇到了各种各样的问题，比如说中文乱码问题。Ubuntu14.05 桌面gnome3.9 安装桌面环境升级一下12sudo apt-get updatesudo apt-get upgrade 安装gnome3.9桌面依次输入以下命令123apt-get install x-window-system-coreapt-get install gnome-coreapt-get install gdm 输入startx进入桌面环境。可以看到桌面重启后会让你输入root的帐号密码， gnome界面 配置中文环境 有些桌面界面会配置好中文环境（至少deepin对中文很友好，毕竟是国产的），而一般外国的桌面都是英文的，连中文都打不进去，更不要说修改什么什么东西了。当我用ftp传输文件的时候，中文会变成带数字的方块。 首先查看一下系统的设定。进入gnome的system setting，查看Region Language，在Language一栏，发现一开始并没有Chinese选项。（如果有，设定为Chinese后重启大概完事） 返回终端,执行以下命令sudo apt-get install language-pack-zh-han*这样可以安装中文包。 安装完成后重启服务器。这时候可以在Language一栏看到Chinese，将Language改为Chinese，并且把input Sources改为Chinese。 再次重启服务器。重启后发现系统很多原本是英文的地方变成了白色矩形。推测是已经将系统语言变成中文，但是系统并没有装载任何中文字体。 安装中文字体先安装一个字体 12sudo apt-get install xfonts-wqy #文泉驿-正黑sudo apt-get install ttf-wqy-zenhei #思源黑体 进入到字体目录下/usr/share/fonts/ 1cd /usr/share/fonts/ 更新字体 1sudo fc-cache -fv 这时候应该能正常显示中文了。","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"/tags/Ubuntu/"}]},{"title":"Nginx+uWSGI+flask部署app环境","slug":"Nginx-uWSGI-flask部署app环境","date":"2017-09-21T15:09:24.000Z","updated":"2018-04-10T03:45:12.000Z","comments":true,"path":"2017/09/21/Nginx-uWSGI-flask部署app环境/","link":"","permalink":"/2017/09/21/Nginx-uWSGI-flask部署app环境/","excerpt":"想有一个响应速度快、后台稳定的服务器环境，仅靠框架（比如flask）自带服务器系统是不足够的。利用Nginx和uWSGI,实现强有力的服务器环境，可以让页面相应速度上升几十倍。","text":"想有一个响应速度快、后台稳定的服务器环境，仅靠框架（比如flask）自带服务器系统是不足够的。利用Nginx和uWSGI,实现强有力的服务器环境，可以让页面相应速度上升几十倍。 以前用过纯JS写过一个博客，但是毕竟自己研究前端比较多，对于后台配置不太熟悉。当时使用了flask做后台框架，由于flask自带服务器系统，所以平时就开flask服务器就算了。后来发现，flask自带的服务器非常不稳。由于社团项目需要，通过同学的推荐，我决定使用这么一套技术栈搭建后台。Ubuntu 14.04.05 + mysql + uWSGI + python3 + git 安装mysql 终端安装mysql 12345sudo apt-get install mysql-serversudo apt-get install mysql-clientsudo apt-get install libmysqlclient-dev# 用下面语句检查是否安装成功sudo netstat -tap | grep mysql 安装mysql时会有一个用户名debian-sys-maint和一个随机密码。 1sudo vi /etc/mysql/debian.cnf 找到帐号密码然后登录mysql命令行 1mysql -u debian-sys-maint -p 进入控制台后，修改密码 12use mysql;update user set password=PASSWORD('新密码') where user='root'; FLUSH PRIVILEGES; 输入quit退出控制台。 python3安装 终端安装python3 1sudo apt-get install python3 安装pip3 1sudo apt-get install python3-pip 顺便安装pip 1sudo apt-get install python-pip 再把mysql的python驱动装了吧 1sudo pip3 install mysqlclient 安装git1sudo apt-get install git 配置代码运行的环境Python的虚拟环境，可以隔离各个项目，避免python版本冲突1sudo pip3 install virtualenv 假设我的项目目录是/home/jnugeek，进入根目录，执行12virtualenv jnugeeksource jnugeek/bin/activate #进入虚拟环境 这样就创建了名为jnugeek的虚拟环境，直接在后台输入deactivate退出虚拟环境 uWSGI配置uWSGI是高性能http服务器，用来和Python程序交换1(jnugeek)jnugeek root$ pip3 install uwsgi 在虚拟环境下不需要使用sudo，因为virtualenv 是没有权限要求的。在项目目录下创建config.ini作为uWSGI的配置文件123456789[uwsgi]master = truehome = jnugeek #虚拟环境文件夹wsgi-file = manage.pycallable = appsocket = :5000processes = 4threads = 2buffer-size = 32768 (虚拟环境内)运行文件1uwsgi config.ini 如果没有报错的话就是可以的，但是会有一些比较坑爹的错误1!!! no internal routing support, rebuild with pcre support !!! 这个是因为pcre没弄好，一般去掉缓存重装就可以了，-I的作用是重装1pip3 install uwsgi -I --no-cache-dir 安装Flask在根目录下新建一个requirements.txt文件，输入12345678910111213141516171819202122Flask==0.10.1Flask-Login==0.2.11Flask-Mail==0.9.1Flask-Moment==0.4.0Flask-PageDown==0.1.5Flask-SQLAlchemy==2.0Flask-Script==2.0.5Flask-WTF==0.10.2Flask-Cache==0.13.1Flask-Restless==0.15.0Flask-Uploads==0.1.3Jinja2==2.7.3Mako==1.0.0Markdown==2.5.1MarkupSafe==0.23SQLAlchemy==0.9.8WTForms==2.0.1Werkzeug==0.9.6html5lib==1.0b3itsdangerous==0.24six==1.8.0awesome-slugify==1.6 安装清单文件1(jnugeek)jnugeek root$ pip3 install -r requirements.txt supervisor配置uWSGI好是好，但是要是它万一断了，或者出问题了怎么办？要是有这样的一个程序可以自动监控运行uWSGI那岂不是美滋滋，而supervisor就是这样的程序。安装1sudo apt-get install supervisor 在/etc/supervisor/conf.d/下建立一个配置文件sp.conf1234567891011[program:my_flask]# 启动命令入口command=/home/jnugeek/jnugeek/bin/uwsgi /home/jnugeek/config.ini# 命令程序所在目录directory=/home/jnugeek#运行命令的用户名user=rootautostart=trueautorestart=true#日志地址（需要手动新建文件）stdout_logfile=/home/jnugeek/logs/uwsgi_supervisor.log 启动/重启/查看状态命令1sudo service supervisor start/restart/stats 安装Nginx1sudo apt-get install nginx 新建一个default文件（无后缀）123456789101112server &#123; listen 80; server_name X.X.X.X; #公网地址 location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:5000; # 指向uwsgi 所应用的内部地址,所有请求将转发给uwsgi 处理 uwsgi_param UWSGI_PYHOME /home/jnugeek/jnugeek; # 指向虚拟环境目录 uwsgi_param UWSGI_CHDIR /home/jnugeek; # 指向网站根目录 uwsgi_param UWSGI_SCRIPT manage:app; # 指定启动程序 uwsgi_read_timeout 100; &#125; &#125; 测试一下配置是否正确1sudo nginx -t 将/etc/nginx/sites-available/default替换掉1sudo service nginx restart 将你的项目文件装载后，在浏览器中输入你的IP地址，就可以看到你的项目了。 在哪里查看错误日志呢？ /var/log/nginx/error.log 参考资料1——简书参考资料2——博客园参考资料3——同学的博客","categories":[{"name":"服务器部署","slug":"服务器部署","permalink":"/categories/服务器部署/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"/tags/Nginx/"},{"name":"uWSGI","slug":"uWSGI","permalink":"/tags/uWSGI/"},{"name":"flask","slug":"flask","permalink":"/tags/flask/"},{"name":"mysql","slug":"mysql","permalink":"/tags/mysql/"}]},{"title":"hexo主题indigo——配置","slug":"hexo主题indigo——配置","date":"2017-09-21T10:52:28.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/09/21/hexo主题indigo——配置/","link":"","permalink":"/2017/09/21/hexo主题indigo——配置/","excerpt":"修改indigo可以个性化你的页面。由于indigo使用的是utf-8编码，不用担心中英文输入问题。图片的替换只需更好图片内容或者路径即可，相当简单。","text":"修改indigo可以个性化你的页面。由于indigo使用的是utf-8编码，不用担心中英文输入问题。图片的替换只需更好图片内容或者路径即可，相当简单。 无论是主题的安装还是配置，千万千万要看它的文档。（文档链接在末尾） 站点配置编辑站点配置文件，hexo/_config.yml。 启用主题1theme: indigo 基本配置为了得到更好的使用体验，以下内容请务必填写完整，因为这些内容会在主题中得到展示。1234567title: your titlesubtitle: your subtitledescription: your descriptionkeywords: your keywordsauthor: your nameemail: your emailurl: your site url 主题配置编辑主题配置文件，themes/indigo/_config.yml。 ##左侧菜单默认配置如下1234567891011121314151617menu: home: text: 主页 url: / archives: url: /archives tags: url: /tags github: url: https://github.com/yscoder target: _blank weibo: url: http://www.weibo.com/ysweb target: _blank link: text: 测试 url: / 添加新菜单项时，在 menu 下增加子属性即可。属性说明如下：12345menu: link: # fontawesome图标，省略前缀，本主题前缀为 icon-，必须 text: About # 菜单显示的文字，如果省略即默认与图标一致，首字母会转大写 url: /about # 链接，绝对或相对路径，必须 target: _blank # 是否跳出，省略则在当前页面打开 fontawesome 图标已集成到主题中，你可以到这个页面挑选合适的图标。 favicon站点 logo，显示在浏览器当前标签页左上角。1favicon: /favicon.ico 头像位于左侧菜单上方1avatar: /img/logo.jpg email头像下方1email: 634206017@qq.com color设置 Android L Chrome 浏览器状态栏颜色，不需要可去除此项或设为 false。1color: '#3F51B5' 页面标题 (card theme)自定义归档、标签、分类页的大标题。123tags_title: Tagsarchives_title: Archivescategories_title: Categories 文章摘要可以在 Markdown 文件中加 以分割摘要与文章正文。未设置时，按 excerpt_length 设置截取。123456# 文章摘要渲染方式: 为 true 时将渲染为 html，否则为文本excerpt_render: false# 截断长度excerpt_length: 200# 文字正文页链接文字excerpt_link: 阅读全文... 分享文章分享开关，byjiathis-api。1share: true 文章打赏默认开启1234reward: title: 谢谢大爷~ #显示的文字 wechat: /img/wechat.jpg #微信，关闭设为 false alipay: /img/alipay.jpg #支付宝，关闭设为 false 此外在 crad theme 中，可以通过在 markdown 头部添加 reward: false 来控制某些不想开启打赏的页面。 关闭1reward: false 二维码请自行从微信、支付宝中下载。当两个二维码同时存在时，为保持显示效果的一致性，注意截图时的边框留白保持一致。必要时可借助PS等图片处理工具进行图片大小裁剪、压缩等。 站内搜索是否开启搜索1search: true 布局开启后，文章页在大屏下会隐藏左侧菜单，专注阅读。1hideMenu: true Toc开启文章内容导航。123#toc: false #关闭toc: list_number: false # 决定导航使用的标签， true 为 ol， false 为 ul。 copyright (card theme)文章页版权声明内容，hexo中所有变量及辅助函数等均可调用，具体请查阅 hexo.io。1copyright: 这里写留言或版权声明 less设置 less 编译时的入口文件路径，hexo-renderer-less。1234less: compress: true # 是否压缩css paths: - source/css/style.less 评论集成了多说和 disqus，开启其一即可。 duoshuo-key 即多说创建站点时的二级域名。如：abc.duoshuo.com，就填 abc。 1duoshuo: duoshuo-key 或 1disqus_shortname: disqus_shortname 版权起始年份1since_year: 2006 自定义页面关于用户页面中作者相关的描述性文字，如不需要设为 false1about: 用户页面中作者相关的描述性文字，如不需要设为 false indigo主题配置文档","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"},{"name":"indigo","slug":"indigo","permalink":"/tags/indigo/"}]},{"title":"pymysql连接mysql数据库——不支持中文解决","slug":"pymysql连接mysql数据库——不支持中文解决","date":"2017-09-21T10:52:28.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/09/21/pymysql连接mysql数据库——不支持中文解决/","link":"","permalink":"/2017/09/21/pymysql连接mysql数据库——不支持中文解决/","excerpt":"","text":"在mysql的学习中，我用本地的win10搭建了环境。当要将中文字符输入到mysql数据库中，就会报错。上网找了一下方法，完美解决。mysql5.7 windows10 往数据库里插入中文时出现异常:1UnicodeEncodeError: 'latin-1' codec can't encode characters 就是编码的问题,pymysql默认的编码是latin1,我们只需要把它改成utf8就好了 更改pymysql配置文件 打开Python的安装目录:Python34\\Lib\\site-packages\\PyMySQL-0.7.9-py3.4.egg\\pymysql 用记事本打开connections.py文件,找到里面的DEFAULT_CHARSET,后面默认=’latin1’,改成utf8就好了,注意是utf8不是utf-8。 PS：ubuntu中的路径为：usr/local/lib/python3.4/dist-packages/pymysql/connections.py 然而解决了问题了吗？并没有，就算我把connections.py文件所有的latin-1更改为utf8，运行py文件读写数据库依然报错。 于是有了下面的方法： 数据库连接1db = pymysql.connect('localhost', username, password, database) 改为1db = pymysql.connect('localhost', username, password, database,use_unicode=True, charset=\"utf8\") 解决 参考资料——博客园","categories":[{"name":"后端","slug":"后端","permalink":"/categories/后端/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"/tags/mysql/"},{"name":"python","slug":"python","permalink":"/tags/python/"},{"name":"pymysql","slug":"pymysql","permalink":"/tags/pymysql/"}]},{"title":"hexo主题indigo——安装","slug":"hexo主题indigo——安装","date":"2017-09-21T10:52:01.000Z","updated":"2018-04-10T03:45:10.000Z","comments":true,"path":"2017/09/21/hexo主题indigo——安装/","link":"","permalink":"/2017/09/21/hexo主题indigo——安装/","excerpt":"本站使用的是indigo主题。这个主题UI相对比较美观，功能齐全，但是可个性化的部分比较少，图片镶嵌不足。如果想要一个更个性化的主题，我推荐material主题。","text":"本站使用的是indigo主题。这个主题UI相对比较美观，功能齐全，但是可个性化的部分比较少，图片镶嵌不足。如果想要一个更个性化的主题，我推荐material主题。 使用indigo请先下载最新版的git和nodejs，博主曾经因为使用4.0版本的nodejs而折腾了一个下午，最终使用8.x的nodejs完美解决。文章的内容都来自文章末尾的文档链接，想要更详细的可以直接去看文档。 主题安装安装需确认你的 Hexo 版本在 3.0 以上，以及 Node 版本为 6.x 以上，在 Hexo 根目录，执行以下命令。1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 依赖安装还是在 Hexo 根目录，如果以下插件已安装过，无需再次安装。 Less主题默认使用 less 作为 css 预处理工具。1$ npm install hexo-renderer-less --save Feed用于生成 rss。1$ npm install hexo-generator-feed --save Json-content用于生成静态站点数据，用作站内搜索的数据源。1$ npm install hexo-generator-json-content --save QRCode用于生成微信分享二维码。 可选，不安装时会请求 jiathis Api 生成二维码。 1$ npm install hexo-helper-qrcode --save 修改hexo配置文件用文本编辑器（建议不要用win自带的文本编辑器）打开_config.yml，修改theme: indigo 配置完成，在git bash输入hexo s预览主题。 hexo主题列表浏览更多主题indigo主题文档传送门","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"},{"name":"indigo","slug":"indigo","permalink":"/tags/indigo/"}]},{"title":"hexo入门指南（四）——文章模版","slug":"hexo入门指南（四）——文章模版","date":"2017-09-20T12:27:00.000Z","updated":"2018-04-10T03:45:14.000Z","comments":true,"path":"2017/09/20/hexo入门指南（四）——文章模版/","link":"","permalink":"/2017/09/20/hexo入门指南（四）——文章模版/","excerpt":"一般我是记不住文章开头要写些什么关键内容，所以我就做个文章模版，待我写文章的时候就能做参考。","text":"一般我是记不住文章开头要写些什么关键内容，所以我就做个文章模版，待我写文章的时候就能做参考。 新建页面在git bash中输入hexo new &quot;your file name&quot;在路径\\blog\\source_posts中会生成一个md文件 文章模版要注意hexo文章使用的是markdown语法，建议不要去尝试其他文本格式(虽然亲测html是有效的)。 这里附上本文的配置123456789101112---title: hexo入门指南（四）——文章模版date: 2017-09-20 20:27:00categories: \"博客建设\"tags: - Hexo教程 - githubdescription: 写文章的时候要注意---一般我是记不住文章开头要写些什么关键内容，所以我就做个文章模版，待我写文章的时候就能做参考。&lt;!--more--&gt; 文章发布 写文章的时候，可以在git bash中输入hexo s,然后保存文章后刷新页面localhost:4000即可看到最新的变化。 想要发布文章，在git bash中输入hexo clean &amp;&amp; hexo g &amp;&amp; hexo d关于内联语句的含义，可以查看入门指南（一） 于是我们就可以轻松愉快地写文章了。","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"}]},{"title":"hexo入门指南（三）———分类和标签页","slug":"hexo入门指南（三）———分类和标签页","date":"2017-09-20T12:26:11.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/09/20/hexo入门指南（三）———分类和标签页/","link":"","permalink":"/2017/09/20/hexo入门指南（三）———分类和标签页/","excerpt":"hexo的分页和分类功能是没有被初始化的，需要特殊的设置才能使用这两个页面。","text":"hexo的分页和分类功能是没有被初始化的，需要特殊的设置才能使用这两个页面。 win10 + nodejs8.5.0 + git2.14.1 + indigo主题 设置标签页tags 在git bash中输入 1hexo new page tags 修改 hexo/source/tags/index.md 的元数据 123layout: tagscomments: false--- 设置分类页categories 仅 card theme 支持。 1hexo new page categories 修改 hexo/source/tags/index.md 的元数据 123layout: categoriescomments: false--- 设置了标签页和分类页后，hexo会基于你的文章信息进行分类并添加到页面上。基本上不用理会这两个页面。 参考资料","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"}]},{"title":"hexo入门指南（二）——配置hexo","slug":"hexo入门指南（二）——配置hexo","date":"2017-09-20T12:25:24.000Z","updated":"2018-04-10T03:45:16.000Z","comments":true,"path":"2017/09/20/hexo入门指南（二）——配置hexo/","link":"","permalink":"/2017/09/20/hexo入门指南（二）——配置hexo/","excerpt":"按照上一篇文章，通过github pages可以访问你的博客。如果要做更个性化的设定，首先要修改hexo的项目配置文件_config.yml","text":"按照上一篇文章，通过github pages可以访问你的博客。如果要做更个性化的设定，首先要修改hexo的项目配置文件_config.yml 配置文件的详细信息。文件内容可能有差异，但是基本的东西还是不变的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# Site #站点信息title: blog Name #标题subtitle: Subtitle #副标题description: my blog desc #描述author: me #作者language: zh-CN #语言timezone: Asia/Shanghai #时区# URLurl: http://yoururl.com #用于绑定域名, 其他的不需要配置root: /#permalink: :year/:month/:day/:title/permalink: posts/title.htmlpermalink_defaults:# Directory #目录source_dir: source #源文件public_dir: public #生成的网页文件tag_dir: tags #标签archive_dir: archives #归档category_dir: categories #分类code_dir: downloads/codei18n_dir: :lang #国际化skip_render:# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认模板(post page photo draft)titlecase: false #标题转换成大写external_link: true #新标签页里打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight: #语法高亮 enable: true line_number: true #显示行号 auto_detect: true tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Date / Time format #日期时间格式## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination #分页per_page: 10 #每页文章数, 设置成 0 禁用分页pagination_dir: page# Extensions #插件和主题## 插件: http://hexo.io/plugins/## 主题: http://hexo.io/themes/theme: next# Deployment #部署, 同时发布在 GitHub 和 GitCafe 上面deploy:- type: git repo: git@gitcafe.com:username/username.git,gitcafe-pages- type: git repo: git@github.com:username/username.github.io.git,master# Disqus #Disqus评论系统disqus_shortname:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap 参考资料","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"}]},{"title":"hexo入门指南（一）——安装","slug":"hexo入门指南（一）——安装","date":"2017-09-20T10:47:44.000Z","updated":"2019-03-27T16:50:28.405Z","comments":true,"path":"2017/09/20/hexo入门指南（一）——安装/","link":"","permalink":"/2017/09/20/hexo入门指南（一）——安装/","excerpt":"hexo是一个非常优秀的博客建设项目，github + node.js即可打造主题多样的博客界面。本站正是利用hexo建设的博客，稍微复习一下流程。","text":"hexo是一个非常优秀的博客建设项目，github + node.js即可打造主题多样的博客界面。本站正是利用hexo建设的博客，稍微复习一下流程。 为什么要做自己的博客呢？可能是为了装B吧，利用hexo建设的博客可以不用花钱，只可能花掉你部分学习时间。不过我更想有一个集中自己笔记的地方，原来喜欢在简书上面打MD，后来发现还是没自己博客的B装得好，所以就搞了这个博客。 概述hexo搭建博客可以分为以下几个步骤： 安装node.js和git github帐号申请和配置 安装hexo 配置hexo 将hexo和github关联起来 hexo常用操作 第一步：安装node.js和git安装git 先从官网下载git安装包，然后一路默认安装 建议直接安装最新版本（包括node.js），避免某些主题由于git和node.js版本问题而无法使用（此处是坑） 注意选择第二个 安装完成后在cmd中输入git --version检测安装结果 安装node.js 提供地址点击此处 下载对应版本 下载系统的对应版本，然后一路默认安装即可。 安装完成后在cmd中输入node -v和npm -v检测安装结果 第二步：github帐号申请和配置 github是世界上最大的同性交友平台，emm，好吧，它是一个流行的代码托管平台。利用github pages功能，让页面在网络上跑起来。 提供github官网。国内上github官网一般加载很久，解决方法请看此处 申请github帐号 点击New repository 输入Repository name为yourname.github.io 然后点击Create repository 现在应该可以在网址栏输入yourname.github.io查看你的github page（然而什么都没有）。 第三步：安装hexo 在磁盘合适的地方建一个文件夹，本文的路径是E:/blog 在文件夹内右键，点击git bash 在国内利用npm命令容易被墙，利用淘宝镜像可以轻松解决,之后的安装都用cnpm代替npm。$ npm install -g cnpm --registry=https://registry.npm.taobao.org 利用npm命令安装hexocnpm install -g hexo-clicnpm install hexo --save验证是否安装正确hexo -v 如果你的文件夹中有文件，先全部删除。本地运行hexohexo init 这时候会有报错,这时候只要按照报错提示操作即可 如图执行cnpm install hexo安装完成。可在git bash输入hexo -v验证是否安装正确。 第四步：配置hexo安装主题 利用git命令克隆主题文件（以主题next为例）git clone https://github.com/iissnan/hexo-theme-next themes/next这里themes/next是安装路径，http..next是github地址。 更多主题浏览这里 不同主题，需要不同的配置（我只额外的安装包），请仔细查看主题的说明文档，进行相应的配置。 修改配置文件 打开根目录下的_config.yml 修改基本配置 修改主题将theme栏的值改为next即可 测试你的网站在git bash中输入hexo g &amp;&amp; hexo s。打开浏览器，在地址栏输入localhost:4000，查看你的页面。正常情况下，你的页面已经在本地跑起来了。 第五步：将hexo和github关联起来 再次打开根目录下的_config.yml，修改配置。 安装hexo-deployer-git自动部署发布工具cnpm install hexo-deployer-git --save 发布到github上hexo clean &amp;&amp; hexo g &amp;&amp; hexo d第一次发布要求输入你的github帐号密码，可能会比较慢。 访问测试。发布完毕后在浏览器中输入https://yourname.github.io/ 第六步：hexo常用操作12345hexo new page \"page\" #新建页面hexo new \"article\" #新建文章hexo g #生成hexo s #启动服务预览hexo d #部署 更多hexo操作请看这里 参考资料 参考资料1","categories":[{"name":"博客建设","slug":"博客建设","permalink":"/categories/博客建设/"}],"tags":[{"name":"github","slug":"github","permalink":"/tags/github/"},{"name":"Hexo教程","slug":"Hexo教程","permalink":"/tags/Hexo教程/"}]}]}